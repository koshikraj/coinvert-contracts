{
  "address": "0xBdE994684051A3caDa9b90Ede0b44A06A9FAC863",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "smartAccount",
          "type": "address"
        }
      ],
      "name": "AlreadyInitialized",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ExecutionFailed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "smartAccount",
          "type": "address"
        }
      ],
      "name": "NotInitialized",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "sessionKey",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "SessionKeyAdded",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sessionKey",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "targetToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "vault",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "account",
              "type": "address"
            },
            {
              "internalType": "uint48",
              "name": "validAfter",
              "type": "uint48"
            },
            {
              "internalType": "uint48",
              "name": "validUntil",
              "type": "uint48"
            },
            {
              "internalType": "uint256",
              "name": "limitAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "limitUsed",
              "type": "uint256"
            },
            {
              "internalType": "uint48",
              "name": "lastUsed",
              "type": "uint48"
            },
            {
              "internalType": "uint48",
              "name": "refreshInterval",
              "type": "uint48"
            }
          ],
          "internalType": "struct AutoDCASessionModule.SessionData",
          "name": "sessionData",
          "type": "tuple"
        }
      ],
      "name": "addSessionKey",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sessionKey",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "sessionId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "execute",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sessionKey",
          "type": "address"
        }
      ],
      "name": "getSessionData",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "token",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "targetToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "vault",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "account",
              "type": "address"
            },
            {
              "internalType": "uint48",
              "name": "validAfter",
              "type": "uint48"
            },
            {
              "internalType": "uint48",
              "name": "validUntil",
              "type": "uint48"
            },
            {
              "internalType": "uint256",
              "name": "limitAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "limitUsed",
              "type": "uint256"
            },
            {
              "internalType": "uint48",
              "name": "lastUsed",
              "type": "uint48"
            },
            {
              "internalType": "uint48",
              "name": "refreshInterval",
              "type": "uint48"
            }
          ],
          "internalType": "struct AutoDCASessionModule.SessionData[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "smartAccount",
          "type": "address"
        }
      ],
      "name": "isInitialized",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "typeID",
          "type": "uint256"
        }
      ],
      "name": "isModuleType",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "hash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "isValidSignatureWithSender",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "onInstall",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "onUninstall",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "sessionKeyData",
      "outputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "targetToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "vault",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "uint48",
          "name": "validAfter",
          "type": "uint48"
        },
        {
          "internalType": "uint48",
          "name": "validUntil",
          "type": "uint48"
        },
        {
          "internalType": "uint256",
          "name": "limitAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "limitUsed",
          "type": "uint256"
        },
        {
          "internalType": "uint48",
          "name": "lastUsed",
          "type": "uint48"
        },
        {
          "internalType": "uint48",
          "name": "refreshInterval",
          "type": "uint48"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "sessionKeyList",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "initCode",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callData",
              "type": "bytes"
            },
            {
              "internalType": "bytes32",
              "name": "accountGasLimits",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "preVerificationGas",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "gasFees",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "paymasterAndData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct PackedUserOperation",
          "name": "userOp",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "userOpHash",
          "type": "bytes32"
        }
      ],
      "name": "validateUserOp",
      "outputs": [
        {
          "internalType": "ERC7579ValidatorBase.ValidationData",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "version",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x11211e4951e137d490f5eaae32e56833497a2800a18a3b5ca2d63808f6986a90",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x814a545d0F39Ae9Fa190c92968F3e1441952FB2C",
    "contractAddress": null,
    "transactionIndex": 38,
    "gasUsed": "1278890",
    "logsBloom": "0x00020000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000040800000000000000000000100000000000000000000000000000000000000000000000001000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000000000001000000000000000000000000000000100002000000000000000000000000000000200000000000000000000000000000000000100000",
    "blockHash": "0x1ec78db65515750cf9466d35c4505e6fe155e0e70f40e7e975c910c8d9e64428",
    "transactionHash": "0x11211e4951e137d490f5eaae32e56833497a2800a18a3b5ca2d63808f6986a90",
    "logs": [
      {
        "transactionIndex": 38,
        "blockNumber": 61521589,
        "transactionHash": "0x11211e4951e137d490f5eaae32e56833497a2800a18a3b5ca2d63808f6986a90",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000814a545d0f39ae9fa190c92968f3e1441952fb2c",
          "0x000000000000000000000000dfe6ad10265afc05831b332fda6f5bc1ad9d79ce"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000c7ea525584ec9800000000000000000000000000000000000000000000000009275af7887f568d0000000000000000000000000000000000000000000000c7543017f5261a800e000000000000000000000000000000000000000000000000085f70a532fa69f50000000000000000000000000000000000000000000000c754f802477b9f6ca6",
        "logIndex": 112,
        "blockHash": "0x1ec78db65515750cf9466d35c4505e6fe155e0e70f40e7e975c910c8d9e64428"
      }
    ],
    "blockNumber": 61521589,
    "cumulativeGasUsed": "5547456",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 6,
  "solcInputHash": "37354953922cdbb14f5ee16f9bd54d4d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartAccount\",\"type\":\"address\"}],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExecutionFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartAccount\",\"type\":\"address\"}],\"name\":\"NotInitialized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sessionKey\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"SessionKeyAdded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sessionKey\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"targetToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"validAfter\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"validUntil\",\"type\":\"uint48\"},{\"internalType\":\"uint256\",\"name\":\"limitAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitUsed\",\"type\":\"uint256\"},{\"internalType\":\"uint48\",\"name\":\"lastUsed\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"refreshInterval\",\"type\":\"uint48\"}],\"internalType\":\"struct AutoDCASessionModule.SessionData\",\"name\":\"sessionData\",\"type\":\"tuple\"}],\"name\":\"addSessionKey\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sessionKey\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sessionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sessionKey\",\"type\":\"address\"}],\"name\":\"getSessionData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"targetToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"validAfter\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"validUntil\",\"type\":\"uint48\"},{\"internalType\":\"uint256\",\"name\":\"limitAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitUsed\",\"type\":\"uint256\"},{\"internalType\":\"uint48\",\"name\":\"lastUsed\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"refreshInterval\",\"type\":\"uint48\"}],\"internalType\":\"struct AutoDCASessionModule.SessionData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartAccount\",\"type\":\"address\"}],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"typeID\",\"type\":\"uint256\"}],\"name\":\"isModuleType\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"isValidSignatureWithSender\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onInstall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onUninstall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sessionKeyData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"targetToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"validAfter\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"validUntil\",\"type\":\"uint48\"},{\"internalType\":\"uint256\",\"name\":\"limitAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limitUsed\",\"type\":\"uint256\"},{\"internalType\":\"uint48\",\"name\":\"lastUsed\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"refreshInterval\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sessionKeyList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"accountGasLimits\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"gasFees\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct PackedUserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"userOpHash\",\"type\":\"bytes32\"}],\"name\":\"validateUserOp\",\"outputs\":[{\"internalType\":\"ERC7579ValidatorBase.ValidationData\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"addSessionKey(address,(address,address,address,address,uint48,uint48,uint256,uint256,uint48,uint48))\":{\"details\":\"Adds a session key to the mapping.\"},\"execute(address,uint256,address,uint256,bytes)\":{\"details\":\"Executes a transaction on behalf of a session.\",\"params\":{\"data\":\"The data to include with the transaction.\",\"sessionKey\":\"The session key associated with the transaction.\",\"to\":\"The address to which the transaction is being sent.\",\"value\":\"The amount of ether to send with the transaction.\"},\"returns\":{\"_0\":\"The result of the transaction execution.\"}},\"isInitialized(address)\":{\"details\":\"Returns if the module was already initialized for a provided smartaccount\"},\"onInstall(bytes)\":{\"details\":\"This function is called by the smart account during installation of the module\",\"params\":{\"data\":\"arbitrary data that may be required on the module during `onInstall` initialization MUST revert on error (i.e. if module is already enabled)\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/AutoDCA/AutoDCASessionModule.sol\":\"AutoDCASessionModule\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@account-abstraction/contracts/core/Helpers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable no-inline-assembly */\\n\\n\\n /*\\n  * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\\n  * must return this value in case of signature failure, instead of revert.\\n  */\\nuint256 constant SIG_VALIDATION_FAILED = 1;\\n\\n\\n/*\\n * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\\n * return this value on success.\\n */\\nuint256 constant SIG_VALIDATION_SUCCESS = 0;\\n\\n\\n/**\\n * Returned data from validateUserOp.\\n * validateUserOp returns a uint256, which is created by `_packedValidationData` and\\n * parsed by `_parseValidationData`.\\n * @param aggregator  - address(0) - The account validated the signature by itself.\\n *                      address(1) - The account failed to validate the signature.\\n *                      otherwise - This is an address of a signature aggregator that must\\n *                                  be used to validate the signature.\\n * @param validAfter  - This UserOp is valid only after this timestamp.\\n * @param validaUntil - This UserOp is valid only up to this timestamp.\\n */\\nstruct ValidationData {\\n    address aggregator;\\n    uint48 validAfter;\\n    uint48 validUntil;\\n}\\n\\n/**\\n * Extract sigFailed, validAfter, validUntil.\\n * Also convert zero validUntil to type(uint48).max.\\n * @param validationData - The packed validation data.\\n */\\nfunction _parseValidationData(\\n    uint256 validationData\\n) pure returns (ValidationData memory data) {\\n    address aggregator = address(uint160(validationData));\\n    uint48 validUntil = uint48(validationData >> 160);\\n    if (validUntil == 0) {\\n        validUntil = type(uint48).max;\\n    }\\n    uint48 validAfter = uint48(validationData >> (48 + 160));\\n    return ValidationData(aggregator, validAfter, validUntil);\\n}\\n\\n/**\\n * Helper to pack the return value for validateUserOp.\\n * @param data - The ValidationData to pack.\\n */\\nfunction _packValidationData(\\n    ValidationData memory data\\n) pure returns (uint256) {\\n    return\\n        uint160(data.aggregator) |\\n        (uint256(data.validUntil) << 160) |\\n        (uint256(data.validAfter) << (160 + 48));\\n}\\n\\n/**\\n * Helper to pack the return value for validateUserOp, when not using an aggregator.\\n * @param sigFailed  - True for signature failure, false for success.\\n * @param validUntil - Last timestamp this UserOperation is valid (or zero for infinite).\\n * @param validAfter - First timestamp this UserOperation is valid.\\n */\\nfunction _packValidationData(\\n    bool sigFailed,\\n    uint48 validUntil,\\n    uint48 validAfter\\n) pure returns (uint256) {\\n    return\\n        (sigFailed ? 1 : 0) |\\n        (uint256(validUntil) << 160) |\\n        (uint256(validAfter) << (160 + 48));\\n}\\n\\n/**\\n * keccak function over calldata.\\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\\n */\\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\\n        assembly (\\\"memory-safe\\\") {\\n            let mem := mload(0x40)\\n            let len := data.length\\n            calldatacopy(mem, data.offset, len)\\n            ret := keccak256(mem, len)\\n        }\\n    }\\n\\n\\n/**\\n * The minimum of two numbers.\\n * @param a - First number.\\n * @param b - Second number.\\n */\\n    function min(uint256 a, uint256 b) pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\",\"keccak256\":\"0x6247e011a6cb0b263b3aa098822977181674d91b62e5bdfe04c6e66f72da25d6\",\"license\":\"GPL-3.0\"},\"@account-abstraction/contracts/core/UserOperationLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable no-inline-assembly */\\n\\nimport \\\"../interfaces/PackedUserOperation.sol\\\";\\nimport {calldataKeccak, min} from \\\"./Helpers.sol\\\";\\n\\n/**\\n * Utility functions helpful when working with UserOperation structs.\\n */\\nlibrary UserOperationLib {\\n\\n    uint256 public constant PAYMASTER_VALIDATION_GAS_OFFSET = 20;\\n    uint256 public constant PAYMASTER_POSTOP_GAS_OFFSET = 36;\\n    uint256 public constant PAYMASTER_DATA_OFFSET = 52;\\n    /**\\n     * Get sender from user operation data.\\n     * @param userOp - The user operation data.\\n     */\\n    function getSender(\\n        PackedUserOperation calldata userOp\\n    ) internal pure returns (address) {\\n        address data;\\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\\n        assembly {\\n            data := calldataload(userOp)\\n        }\\n        return address(uint160(data));\\n    }\\n\\n    /**\\n     * Relayer/block builder might submit the TX with higher priorityFee,\\n     * but the user should not pay above what he signed for.\\n     * @param userOp - The user operation data.\\n     */\\n    function gasPrice(\\n        PackedUserOperation calldata userOp\\n    ) internal view returns (uint256) {\\n        unchecked {\\n            (uint256 maxPriorityFeePerGas, uint256 maxFeePerGas) = unpackUints(userOp.gasFees);\\n            if (maxFeePerGas == maxPriorityFeePerGas) {\\n                //legacy mode (for networks that don't support basefee opcode)\\n                return maxFeePerGas;\\n            }\\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\\n        }\\n    }\\n\\n    /**\\n     * Pack the user operation data into bytes for hashing.\\n     * @param userOp - The user operation data.\\n     */\\n    function encode(\\n        PackedUserOperation calldata userOp\\n    ) internal pure returns (bytes memory ret) {\\n        address sender = getSender(userOp);\\n        uint256 nonce = userOp.nonce;\\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\\n        bytes32 accountGasLimits = userOp.accountGasLimits;\\n        uint256 preVerificationGas = userOp.preVerificationGas;\\n        bytes32 gasFees = userOp.gasFees;\\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\\n\\n        return abi.encode(\\n            sender, nonce,\\n            hashInitCode, hashCallData,\\n            accountGasLimits, preVerificationGas, gasFees,\\n            hashPaymasterAndData\\n        );\\n    }\\n\\n    function unpackUints(\\n        bytes32 packed\\n    ) internal pure returns (uint256 high128, uint256 low128) {\\n        return (uint128(bytes16(packed)), uint128(uint256(packed)));\\n    }\\n\\n    //unpack just the high 128-bits from a packed value\\n    function unpackHigh128(bytes32 packed) internal pure returns (uint256) {\\n        return uint256(packed) >> 128;\\n    }\\n\\n    // unpack just the low 128-bits from a packed value\\n    function unpackLow128(bytes32 packed) internal pure returns (uint256) {\\n        return uint128(uint256(packed));\\n    }\\n\\n    function unpackMaxPriorityFeePerGas(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackHigh128(userOp.gasFees);\\n    }\\n\\n    function unpackMaxFeePerGas(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackLow128(userOp.gasFees);\\n    }\\n\\n    function unpackVerificationGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackHigh128(userOp.accountGasLimits);\\n    }\\n\\n    function unpackCallGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackLow128(userOp.accountGasLimits);\\n    }\\n\\n    function unpackPaymasterVerificationGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET]));\\n    }\\n\\n    function unpackPostOpGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]));\\n    }\\n\\n    function unpackPaymasterStaticFields(\\n        bytes calldata paymasterAndData\\n    ) internal pure returns (address paymaster, uint256 validationGasLimit, uint256 postOpGasLimit) {\\n        return (\\n            address(bytes20(paymasterAndData[: PAYMASTER_VALIDATION_GAS_OFFSET])),\\n            uint128(bytes16(paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET])),\\n            uint128(bytes16(paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]))\\n        );\\n    }\\n\\n    /**\\n     * Hash the user operation data.\\n     * @param userOp - The user operation data.\\n     */\\n    function hash(\\n        PackedUserOperation calldata userOp\\n    ) internal pure returns (bytes32) {\\n        return keccak256(encode(userOp));\\n    }\\n}\\n\",\"keccak256\":\"0x9d50ece985d35f82e33e5da417595c86fac10449e3d10895d08363d33aad454b\",\"license\":\"GPL-3.0\"},\"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.7.5;\\n\\n/**\\n * User Operation struct\\n * @param sender                - The sender account of this request.\\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\\n * @param initCode              - If set, the account contract will be created by this constructor/\\n * @param callData              - The method call to execute on this account.\\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\\n *                                Covers batch overhead.\\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\\n *                                The paymaster will pay for the transaction instead of the sender.\\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n */\\nstruct PackedUserOperation {\\n    address sender;\\n    uint256 nonce;\\n    bytes initCode;\\n    bytes callData;\\n    bytes32 accountGasLimits;\\n    uint256 preVerificationGas;\\n    bytes32 gasFees;\\n    bytes paymasterAndData;\\n    bytes signature;\\n}\\n\",\"keccak256\":\"0x1129b46381db68eddbc5cb49e50664667b66b03c480453858e7b25eabe444359\",\"license\":\"GPL-3.0\"},\"account-abstraction/interfaces/PackedUserOperation.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.7.5;\\n\\n/**\\n * User Operation struct\\n * @param sender                - The sender account of this request.\\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\\n * @param initCode              - If set, the account contract will be created by this constructor/\\n * @param callData              - The method call to execute on this account.\\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\\n *                                Covers batch overhead.\\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\\n *                                The paymaster will pay for the transaction instead of the sender.\\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n */\\nstruct PackedUserOperation {\\n    address sender;\\n    uint256 nonce;\\n    bytes initCode;\\n    bytes callData;\\n    bytes32 accountGasLimits;\\n    uint256 preVerificationGas;\\n    bytes32 gasFees;\\n    bytes paymasterAndData;\\n    bytes signature;\\n}\\n\",\"keccak256\":\"0x1129b46381db68eddbc5cb49e50664667b66b03c480453858e7b25eabe444359\",\"license\":\"GPL-3.0\"},\"contracts/AutoDCA/AutoDCASessionModule.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.23;\\n\\nimport { Execution } from \\\"modulekit/Accounts.sol\\\";\\nimport {\\n    ERC20Integration, ERC4626Integration\\n} from \\\"modulekit/Integrations.sol\\\";\\nimport { UniswapV3Integration } from \\\"../integrations/Uniswap.sol\\\";\\n\\nimport { IERC20 } from \\\"forge-std/interfaces/IERC20.sol\\\";\\nimport { IERC4626 } from \\\"forge-std/interfaces/IERC4626.sol\\\";\\n\\nimport { ERC7579ValidatorBase } from \\\"../module-bases/ERC7579ValidatorBase.sol\\\";\\nimport { PackedUserOperation } from\\n    \\\"@account-abstraction/contracts/core/UserOperationLib.sol\\\";\\n\\nimport { SignatureCheckerLib } from \\\"solady/utils/SignatureCheckerLib.sol\\\";\\nimport { ECDSA } from \\\"solady/utils/ECDSA.sol\\\";\\nimport { ExecutionLib } from \\\"../safe7579/lib/ExecutionLib.sol\\\";\\n\\nimport { ERC7579ExecutorBase } from \\\"../module-bases/ERC7579ExecutorBase.sol\\\";\\n\\n\\ncontract AutoDCASessionModule is ERC7579ValidatorBase, ERC7579ExecutorBase {\\n    using SignatureCheckerLib for address;\\n    using ExecutionLib for bytes;\\n\\n    // account => sessionKeys\\n    mapping(address => address[]) public sessionKeyList;\\n\\n    // sessionKey => account=> SessionData\\n    // mapping(address => mapping(address => SessionData))\\n    //     public sessionKeyData;\\n\\n    mapping(address =>  SessionData[]) public sessionKeyData;\\n\\n    struct SessionData {\\n\\n        address token;\\n        address targetToken;\\n        address vault;\\n        address account;\\n        uint48 validAfter;\\n        uint48 validUntil;\\n\\n        uint256 limitAmount;\\n        uint256 limitUsed;\\n\\n        uint48 lastUsed;\\n        uint48 refreshInterval;\\n    }\\n\\n            \\n    event SessionKeyAdded(address indexed sessionKey, address indexed account);\\n\\n    error ExecutionFailed();\\n\\n    function onInstall(bytes calldata data) external override {\\n    }\\n\\n    function onUninstall(bytes calldata) external override {\\n\\n        // delete the Safe account sessions\\n    }\\n\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash\\n    )\\n        external\\n        view\\n        override\\n        returns (ValidationData)\\n    {\\n\\n        // Extract the execution calldata from the user operation.\\n        bytes calldata executionCalldata = userOp.callData[100:];\\n\\n        // Extract the target address and the session key from the execution calldata.\\n        (address target , uint256 value, bytes calldata callData) = executionCalldata.decodeSingle();\\n\\n        address sessionKey = address(bytes20(callData[16:]));\\n\\n        // Check if the session key is valid.\\n        bool validSig =  sessionKey.isValidSignatureNow(\\n            ECDSA.toEthSignedMessageHash(userOpHash), userOp.signature\\n        );\\n        return _packValidationData(!validSig, type(uint48).max, 0);\\n    }\\n\\n    function isValidSignatureWithSender(\\n        address,\\n        bytes32 hash,\\n        bytes calldata data\\n    )\\n        external\\n        view\\n        override\\n        returns (bytes4)\\n    {\\n\\n        //Implement the session key sig validation\\n\\n        // return SignatureCheckerLib.isValidSignatureNowCalldata(owner, hash, data)\\n        //     ? EIP1271_SUCCESS\\n        //     : EIP1271_FAILED;\\n    }\\n\\n\\n    /**\\n     * @dev Adds a session key to the mapping.\\n     */\\n    // Add a session key to the mapping\\n    function addSessionKey(address sessionKey, SessionData memory sessionData) public  returns (uint256) {\\n\\n        sessionData.account = msg.sender; \\n        sessionKeyData[sessionKey].push(sessionData);\\n        emit SessionKeyAdded(sessionKey, msg.sender);\\n\\n        return sessionKeyData[sessionKey].length - 1;\\n\\n    }\\n\\n\\n    /**\\n     * @dev Executes a transaction on behalf of a session.\\n     * @param sessionKey The session key associated with the transaction.\\n     * @param to The address to which the transaction is being sent.\\n     * @param value The amount of ether to send with the transaction.\\n     * @param data The data to include with the transaction.\\n     * @return The result of the transaction execution.\\n     */\\n    function execute(address sessionKey, uint256 sessionId, address to, uint256 value, bytes calldata data) public returns (bytes memory) {\\n\\n            address token = value == 0 ? to : address(0);\\n\\n            uint256 tokenValue = value == 0 ? _getTokenSpendAmount(data) : value;\\n\\n            if(!updateSpendLimitUsage(tokenValue, sessionKey, sessionId, token))  {\\n            revert ExecutionFailed();\\n            }\\n\\n            // return _execute(msg.sender, to, value, data);\\n\\n            SessionData storage sessionData = sessionKeyData[sessionKey][sessionId];\\n\\n           uint256 amountIn =  tokenValue;\\n\\n            Execution[] memory swap = UniswapV3Integration.approveAndSwap({\\n                smartAccount: sessionData.account,\\n                tokenIn: IERC20(token),\\n                tokenOut: IERC20(sessionData.targetToken),\\n                amountIn: tokenValue,\\n                sqrtPriceLimitX96: 0\\n            });\\n\\n            bytes[] memory results = _execute(swap);\\n            amountIn = abi.decode(results[2], (uint256));\\n\\n\\n        // approve and deposit to vault\\n        Execution[] memory approveAndDeposit = new Execution[](3);\\n        (approveAndDeposit[0], approveAndDeposit[1]) =\\n            ERC20Integration.safeApprove(IERC20(sessionData.targetToken), sessionData.vault, amountIn);\\n        approveAndDeposit[2] = ERC4626Integration.deposit(IERC4626(sessionData.vault), amountIn, sessionData.account);\\n\\n        // execute deposit to vault on account\\n        _execute(approveAndDeposit);\\n\\n        }\\n\\n        function _getTokenSpendAmount(bytes memory callData) internal pure returns (uint256) {\\n\\n        // Expected length: 68 bytes (4 selector + 32 address + 32 amount)\\n        if (callData.length < 68) {\\n            return 0;\\n        }\\n\\n        // Load the amount being sent/approved.\\n        // Solidity doesn't support access a whole word from a bytes memory at once, only a single byte, and\\n        // trying to use abi.decode would require copying the data to remove the selector, which is expensive.\\n        // Instead, we use inline assembly to load the amount directly. This is safe because we've checked the\\n        // length of the call data.\\n        uint256 amount;\\n        assembly (\\\"memory-safe\\\") {\\n            // Jump 68 words forward: 32 for the length field, 4 for the selector, and 32 for the to address.\\n            amount := mload(add(callData, 68))\\n        }\\n        return amount;\\n        \\n        // Unrecognized function selector\\n        return 0;\\n    }\\n\\n    function updateSpendLimitUsage(\\n        uint256 newUsage,\\n        address sessionKey,\\n        uint256 sessionId,\\n        address token\\n    ) internal returns (bool) {\\n\\n\\n        SessionData storage sessionData = sessionKeyData[sessionKey][sessionId];\\n\\n        if(token != sessionData.token) {\\n            return false;\\n        }\\n\\n            uint48 refreshInterval =  sessionData.refreshInterval;\\n            uint48 lastUsed = sessionData.lastUsed;\\n            uint256 spendLimit = sessionData.limitAmount;\\n            uint256 currentUsage = sessionData.limitUsed;\\n\\n        \\n        if(block.timestamp < sessionData.validAfter || block.timestamp > sessionData.validUntil) {\\n            return false;\\n        }\\n\\n\\n        if (refreshInterval == 0 || lastUsed + refreshInterval > block.timestamp) {\\n            // We either don't have a refresh interval, or the current one is still active.\\n\\n            // Must re-check the limits to handle changes due to other user ops.\\n            // We manually check for overflows here to give a more informative error message.\\n            uint256 newTotalUsage;\\n            unchecked {\\n                newTotalUsage = newUsage + currentUsage;\\n            }\\n            if (newTotalUsage < newUsage || newTotalUsage > spendLimit) {\\n                // If we overflow, or if the limit is exceeded, fail here and revert in the parent context.\\n                return false;\\n            }\\n\\n            // We won't update the refresh interval last used variable now, so just update the spend limit.\\n            sessionData.limitUsed = newTotalUsage;\\n        } else {\\n            // We have a interval active that is currently resetting.\\n            // Must re-check the amount to handle changes due to other user ops.\\n            // It only needs to fit within the new refresh interval, since the old one has passed.\\n            if (newUsage > spendLimit) {\\n                return false;\\n            }\\n\\n            // The refresh interval has passed, so we can reset the spend limit to the new usage.\\n            sessionData.limitUsed = newUsage;\\n            sessionData.lastUsed = uint48(block.timestamp);\\n        }\\n\\n        return true;\\n    }\\n\\n\\n    // Function to get the array of SessionData for a specific address\\n    function getSessionData(address sessionKey) public view returns (SessionData[] memory) {\\n        return sessionKeyData[sessionKey];\\n    }\\n\\n\\n    function name() external pure returns (string memory) {\\n        return \\\"AutoDCASessionModule\\\";\\n    }\\n\\n    function version() external pure returns (string memory) {\\n        return \\\"0.0.1\\\";\\n    }\\n\\n    function isModuleType(uint256 typeID) external pure override returns (bool) {\\n        return typeID == TYPE_VALIDATOR || typeID == TYPE_EXECUTOR;\\n    }\\n\\n    function isInitialized(address smartAccount) external view returns (bool) { }\\n}\",\"keccak256\":\"0x6e02f360d5c730d42e51383c9eb9330b74e5fa0baaa17f98512ef9776a9bc485\",\"license\":\"GPL-3.0\"},\"contracts/integrations/ISwapRouter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.4;\\npragma abicoder v2;\\n\\nimport { IUniswapV3SwapCallback } from \\\"./IUniswapV3SwapCallback.sol\\\";\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter is IUniswapV3SwapCallback {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in\\n    /// calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified\\n    /// path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams`\\n    /// in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in\\n    /// calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the\\n    /// specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as\\n    /// `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amountIn);\\n}\",\"keccak256\":\"0x0dd323e47ca555c707656c152a6a27020eccb8522c2eadef596b282a966dc366\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/IUniswapV3SwapCallback.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical\\n    /// UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received\\n    /// (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received\\n    /// (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    )\\n        external;\\n}\",\"keccak256\":\"0xa2c3808fc38c61788f6358f40bdbc98bc0789a0428f94825ab737659d78a8249\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/SwapRouterConfigLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nlibrary SwapRouterConfigLibrary {\\n    struct RouterConfig {\\n        address payable routerAddress;\\n        uint24 fee;\\n    }\\n\\n    // Define configurations inside a pure function\\n    function getSwapRouterConfig(uint256 chainId) internal pure returns (RouterConfig memory) {\\n        if (chainId == 1) { // Ethereum Mainnet\\n            return RouterConfig(payable(0xE592427A0AEce92De3Edee1F18E0157C05861564), 3000);\\n        } else if (chainId == 137) { // Polygon\\n            return RouterConfig(payable(0xE592427A0AEce92De3Edee1F18E0157C05861564), 3000);\\n        } else if (chainId == 42161) { // Arbitrum\\n            return RouterConfig(payable(0xE592427A0AEce92De3Edee1F18E0157C05861564), 500);\\n        } else {\\n            revert(\\\"Unsupported network\\\");\\n        }\\n    }\\n}\",\"keccak256\":\"0x8963dc7b792c4761705c8cbfa4ef1f04b7aa1e87ae7ebe955947b9a25377662e\",\"license\":\"MIT\"},\"contracts/integrations/Uniswap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport \\\"./SwapRouterConfigLibrary.sol\\\";\\nimport { ISwapRouter } from \\\"./ISwapRouter.sol\\\";\\nimport { IERC20 } from \\\"forge-std/interfaces/IERC20.sol\\\";\\nimport { ERC20Integration } from \\\"modulekit/Integrations.sol\\\";\\nimport { Execution } from \\\"modulekit/Accounts.sol\\\";\\n\\n/// @author zeroknots\\nlibrary UniswapV3Integration {\\n    using ERC20Integration for IERC20;\\n    using SwapRouterConfigLibrary for uint256;\\n\\n\\n    function approveAndSwap(\\n        address smartAccount,\\n        IERC20 tokenIn,\\n        IERC20 tokenOut,\\n        uint256 amountIn,\\n        uint160 sqrtPriceLimitX96\\n    )\\n        internal\\n        view\\n        returns (Execution[] memory exec)\\n    {\\n        SwapRouterConfigLibrary.RouterConfig memory config = block.chainid.getSwapRouterConfig();\\n\\n        exec = new Execution[](3);\\n        (exec[0], exec[1]) = ERC20Integration.safeApprove(tokenIn, config.routerAddress, amountIn);\\n        exec[2] = swapExactInputSingle(smartAccount, tokenIn, tokenOut, amountIn, sqrtPriceLimitX96, config.routerAddress, config.fee);\\n    }\\n\\n    function swapExactInputSingle(\\n        address smartAccount,\\n        IERC20 tokenIn,\\n        IERC20 tokenOut,\\n        uint256 amountIn,\\n        uint160 sqrtPriceLimitX96,\\n        address payable swapRouter,\\n        uint24 fee\\n    )\\n        internal\\n        view\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: swapRouter,\\n            value: 0,\\n            callData: abi.encodeCall(\\n                ISwapRouter.exactInputSingle,\\n                (\\n                    ISwapRouter.ExactInputSingleParams({\\n                        tokenIn: address(tokenIn),\\n                        tokenOut: address(tokenOut),\\n                        fee: fee,\\n                        recipient: smartAccount,\\n                        deadline: block.timestamp,\\n                        amountIn: amountIn,\\n                        amountOutMinimum: 0,\\n                        sqrtPriceLimitX96: sqrtPriceLimitX96\\n                    })\\n                )\\n            )\\n        });\\n    }\\n\\n    function swapExactOutputSingle(\\n        address smartAccount,\\n        IERC20 tokenIn,\\n        IERC20 tokenOut,\\n        uint256 amountOut,\\n        uint256 amountInMaximum,\\n        address payable swapRouter,\\n        uint24 fee\\n    )\\n        internal\\n        view\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: swapRouter,\\n            value: 0,\\n            callData: abi.encodeCall(\\n                ISwapRouter.exactOutputSingle,\\n                (\\n                    ISwapRouter.ExactOutputSingleParams({\\n                        tokenIn: address(tokenIn),\\n                        tokenOut: address(tokenOut),\\n                        fee: fee,\\n                        recipient: smartAccount,\\n                        deadline: block.timestamp,\\n                        amountOut: amountOut,\\n                        amountInMaximum: amountInMaximum,\\n                        sqrtPriceLimitX96: 0\\n                    })\\n                )\\n            )\\n        });\\n    }\\n}\",\"keccak256\":\"0x98395b345e9eef42ac399ebae142d4cff9119f43ac9ee133eb9586d1d975720a\",\"license\":\"MIT\"},\"contracts/module-bases/ERC7579ExecutorBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport \\\"../safe7579/external/ERC7579.sol\\\";\\nimport { ERC7579ModuleBase } from \\\"./ERC7579ModuleBase.sol\\\";\\n\\nabstract contract ERC7579ExecutorBase is IERC7579Executor, ERC7579ModuleBase {\\n    function _execute(\\n        address account,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    )\\n        internal\\n        returns (bytes memory result)\\n    {\\n        ModeCode modeCode = ERC7579ModeLib.encode({\\n            callType: CALLTYPE_SINGLE,\\n            execType: EXECTYPE_DEFAULT,\\n            mode: MODE_DEFAULT,\\n            payload: ModePayload.wrap(bytes22(0))\\n        });\\n\\n        return IERC7579Account(account).executeFromExecutor(\\n            modeCode, ERC7579ExecutionLib.encodeSingle(to, value, data)\\n        )[0];\\n    }\\n\\n    function _execute(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    )\\n        internal\\n        returns (bytes memory result)\\n    {\\n        return _execute(msg.sender, to, value, data);\\n    }\\n\\n    function _execute(\\n        address account,\\n        Execution[] memory execs\\n    )\\n        internal\\n        returns (bytes[] memory results)\\n    {\\n        ModeCode modeCode = ERC7579ModeLib.encode({\\n            callType: CALLTYPE_BATCH,\\n            execType: EXECTYPE_DEFAULT,\\n            mode: MODE_DEFAULT,\\n            payload: ModePayload.wrap(bytes22(0))\\n        });\\n        results = IERC7579Account(account).executeFromExecutor(\\n            modeCode, ERC7579ExecutionLib.encodeBatch(execs)\\n        );\\n    }\\n\\n    function _execute(Execution[] memory execs) internal returns (bytes[] memory results) {\\n        return _execute(msg.sender, execs);\\n    }\\n\\n    // Note: Not every account will support delegatecalls\\n    function _executeDelegateCall(\\n        address account,\\n        address delegateTarget,\\n        bytes memory callData\\n    )\\n        internal\\n        returns (bytes[] memory results)\\n    {\\n        ModeCode modeCode = ERC7579ModeLib.encode({\\n            callType: CALLTYPE_DELEGATECALL,\\n            execType: EXECTYPE_DEFAULT,\\n            mode: MODE_DEFAULT,\\n            payload: ModePayload.wrap(bytes22(0))\\n        });\\n        results = IERC7579Account(account).executeFromExecutor(\\n            modeCode, abi.encodePacked(delegateTarget, callData)\\n        );\\n    }\\n\\n    // Note: Not every account will support delegatecalls\\n    function _executeDelegateCall(\\n        address delegateTarget,\\n        bytes memory callData\\n    )\\n        internal\\n        returns (bytes[] memory results)\\n    {\\n        return _executeDelegateCall(msg.sender, delegateTarget, callData);\\n    }\\n}\",\"keccak256\":\"0xa4729b5793bfae51db97ecd2706ce1cb652cd0ff43fd9ba1fe6793438b1301f2\",\"license\":\"MIT\"},\"contracts/module-bases/ERC7579ModuleBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { IERC7579Module } from \\\"../safe7579/external/ERC7579.sol\\\";\\n\\nabstract contract ERC7579ModuleBase is IERC7579Module {\\n    uint256 constant TYPE_VALIDATOR = 1;\\n    uint256 constant TYPE_EXECUTOR = 2;\\n    uint256 constant TYPE_FALLBACK = 3;\\n    uint256 constant TYPE_HOOK = 4;\\n}\",\"keccak256\":\"0x44e42a9254211dc12fc684d8d3a18363368244007ac4348f24e270376521cf9c\",\"license\":\"MIT\"},\"contracts/module-bases/ERC7579ValidatorBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport {PackedUserOperation} from \\\"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\\\";\\nimport {_packValidationData as _packValidationData4337} from \\\"@account-abstraction/contracts/core/Helpers.sol\\\";\\nimport { ERC7579ModuleBase } from \\\"./ERC7579ModuleBase.sol\\\";\\n\\nabstract contract ERC7579ValidatorBase is ERC7579ModuleBase {\\n    type ValidationData is uint256;\\n\\n    ValidationData internal constant VALIDATION_SUCCESS = ValidationData.wrap(0);\\n    ValidationData internal constant VALIDATION_FAILED = ValidationData.wrap(1);\\n    bytes4 internal constant EIP1271_SUCCESS = 0x1626ba7e;\\n    bytes4 internal constant EIP1271_FAILED = 0xFFFFFFFF;\\n\\n    /**\\n     * Helper to pack the return value for validateUserOp, when not using an aggregator.\\n     * @param sigFailed  - True for signature failure, false for success.\\n     * @param validUntil - Last timestamp this UserOperation is valid (or zero for\\n     * infinite).\\n     * @param validAfter - First timestamp this UserOperation is valid.\\n     */\\n    function _packValidationData(\\n        bool sigFailed,\\n        uint48 validUntil,\\n        uint48 validAfter\\n    )\\n        internal\\n        pure\\n        returns (ValidationData)\\n    {\\n        return ValidationData.wrap(_packValidationData4337(sigFailed, validUntil, validAfter));\\n    }\\n\\n    function _unpackValidationData(ValidationData _packedData)\\n        internal\\n        pure\\n        returns (bool sigFailed, uint48 validUntil, uint48 validAfter)\\n    {\\n        uint256 packedData = ValidationData.unwrap(_packedData);\\n        sigFailed = (packedData & 1) == 1;\\n        validUntil = uint48((packedData >> 160) & ((1 << 48) - 1));\\n        validAfter = uint48((packedData >> (160 + 48)) & ((1 << 48) - 1));\\n    }\\n\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash\\n    )\\n        external\\n        virtual\\n        returns (ValidationData);\\n\\n    function isValidSignatureWithSender(\\n        address sender,\\n        bytes32 hash,\\n        bytes calldata data\\n    )\\n        external\\n        view\\n        virtual\\n        returns (bytes4);\\n}\",\"keccak256\":\"0x4ea546f37886f86f2639297a82224dea7132aa2264bc7907fb7e200e58a6965a\",\"license\":\"MIT\"},\"contracts/safe7579/external/ERC7579.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable no-unused-import */\\nimport { MSAFactory as ERC7579AccountFactory } from \\\"erc7579/MSAFactory.sol\\\";\\nimport { MSAAdvanced as ERC7579Account } from \\\"erc7579/MSAAdvanced.sol\\\";\\nimport { Execution, IERC7579Account } from \\\"erc7579/interfaces/IERC7579Account.sol\\\";\\nimport {\\n    IModule as IERC7579Module,\\n    IValidator as IERC7579Validator,\\n    IExecutor as IERC7579Executor,\\n    IHook as IERC7579Hook,\\n    IFallback as IERC7579Fallback,\\n    MODULE_TYPE_VALIDATOR,\\n    MODULE_TYPE_EXECUTOR,\\n    MODULE_TYPE_HOOK,\\n    MODULE_TYPE_FALLBACK\\n} from \\\"erc7579/interfaces/IERC7579Module.sol\\\";\\n\\nimport {\\n    ModeLib as ERC7579ModeLib,\\n    ModeCode,\\n    CallType,\\n    ExecType,\\n    ModePayload,\\n    CALLTYPE_SINGLE,\\n    CALLTYPE_BATCH,\\n    CALLTYPE_DELEGATECALL,\\n    EXECTYPE_DEFAULT,\\n    MODE_DEFAULT\\n} from \\\"erc7579/lib/ModeLib.sol\\\";\\nimport { Execution, ExecutionLib as ERC7579ExecutionLib } from \\\"erc7579/lib/ExecutionLib.sol\\\";\\n\\nimport {\\n    Bootstrap as ERC7579Bootstrap,\\n    BootstrapConfig as ERC7579BootstrapConfig\\n} from \\\"erc7579/utils/Bootstrap.sol\\\";\\n/* solhint-enable no-unused-import */\",\"keccak256\":\"0x1b7b6abd1abcb25b27f79008941523c83f0965817c0d9384419c2423acc1fac0\",\"license\":\"MIT\"},\"contracts/safe7579/interfaces/IERC7579Account.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { CallType, ExecType, ModeCode } from \\\"../lib/ModeLib.sol\\\";\\n\\nstruct Execution {\\n    address target;\\n    uint256 value;\\n    bytes callData;\\n}\\n\\ninterface IERC7579AccountEvents {\\n    event ModuleInstalled(uint256 moduleTypeId, address module);\\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\\n}\\n\\ninterface IERC7579Account is IERC7579AccountEvents {\\n    // Error thrown when an unsupported ModuleType is requested\\n    error UnsupportedModuleType(uint256 moduleTypeId);\\n    // Error thrown when an execution with an unsupported CallType was made\\n    error UnsupportedCallType(CallType callType);\\n    // Error thrown when an execution with an unsupported ExecType was made\\n    error UnsupportedExecType(ExecType execType);\\n    // Error thrown when account initialization fails\\n    error AccountInitializationFailed();\\n    /**\\n     * @dev Executes a transaction on behalf of the account.\\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * If a mode is requested that is not supported by the Account, it MUST revert\\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\\n     * @param executionCalldata The encoded execution call data\\n     */\\n\\n    function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\\n\\n    /**\\n     * @dev Executes a transaction on behalf of the account.\\n     *         This function is intended to be called by Executor Modules\\n     * @dev Ensure adequate authorization control: i.e. onlyExecutorModule\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * If a mode is requested that is not supported by the Account, it MUST revert\\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\\n     * @param executionCalldata The encoded execution call data\\n     */\\n    function executeFromExecutor(\\n        ModeCode mode,\\n        bytes calldata executionCalldata\\n    )\\n        external\\n        payable\\n        returns (bytes[] memory returnData);\\n\\n    /**\\n     * @dev ERC-1271 isValidSignature\\n     *         This function is intended to be used to validate a smart account signature\\n     * and may forward the call to a validator module\\n     *\\n     * @param hash The hash of the data that is signed\\n     * @param data The data that is signed\\n     */\\n    function isValidSignature(bytes32 hash, bytes calldata data) external returns (bytes4);\\n\\n    /**\\n     * @dev installs a Module of a certain type on the smart account\\n     * @dev Implement Authorization control of your chosing\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     * @param module the module address\\n     * @param initData arbitrary data that may be required on the module during `onInstall`\\n     * initialization.\\n     */\\n    function installModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata initData\\n    )\\n        external\\n        payable;\\n\\n    /**\\n     * @dev uninstalls a Module of a certain type on the smart account\\n     * @dev Implement Authorization control of your chosing\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     * @param module the module address\\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\\n     * de-initialization.\\n     */\\n    function uninstallModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata deInitData\\n    )\\n        external\\n        payable;\\n\\n    /**\\n     * Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\\n     * @param encodedMode the encoded mode\\n     */\\n    function supportsExecutionMode(ModeCode encodedMode) external view returns (bool);\\n\\n    /**\\n     * Function to check if the account supports installation of a certain module type Id\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     */\\n    function supportsModule(uint256 moduleTypeId) external view returns (bool);\\n\\n    /**\\n     * Function to check if the account has a certain module installed\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\\n     *            thus may be necessary to query multiple module types\\n     * @param module the module address\\n     * @param additionalContext additional context data that the smart account may interpret to\\n     *                          identifiy conditions under which the module is installed.\\n     *                          usually this is not necessary, but for some special hooks that\\n     *                          are stored in mappings, this param might be needed\\n     */\\n    function isModuleInstalled(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata additionalContext\\n    )\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the account id of the smart account\\n     * @return accountImplementationId the account id of the smart account\\n     * the accountId should be structured like so:\\n     *        \\\"vendorname.accountname.semver\\\"\\n     */\\n    function accountId() external view returns (string memory accountImplementationId);\\n}\\n\",\"keccak256\":\"0x55c67ffa09b0087e97322a0881494dd497250af4586904403181c536baadb164\",\"license\":\"MIT\"},\"contracts/safe7579/lib/ExecutionLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { Execution } from \\\"../interfaces/IERC7579Account.sol\\\";\\n\\n/**\\n * Helper Library for decoding Execution calldata\\n * malloc for memory allocation is bad for gas. use this assembly instead\\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\\n */\\nlibrary ExecutionLib {\\n    function decodeBatch(bytes calldata callData)\\n        internal\\n        pure\\n        returns (Execution[] calldata executionBatch)\\n    {\\n        /*\\n         * Batch Call Calldata Layout\\n         * Offset (in bytes)    | Length (in bytes) | Contents\\n         * 0x0                  | 0x4               | bytes4 function selector\\n        *  0x4                  | -                 |\\n        abi.encode(IERC7579Execution.Execution[])\\n         */\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            let dataPointer := add(callData.offset, calldataload(callData.offset))\\n\\n            // Extract the ERC7579 Executions\\n            executionBatch.offset := add(dataPointer, 32)\\n            executionBatch.length := calldataload(dataPointer)\\n        }\\n    }\\n\\n    function encodeBatch(Execution[] memory executions)\\n        internal\\n        pure\\n        returns (bytes memory callData)\\n    {\\n        callData = abi.encode(executions);\\n    }\\n\\n    function decodeSingle(bytes calldata executionCalldata)\\n        internal\\n        pure\\n        returns (address target, uint256 value, bytes calldata callData)\\n    {\\n        target = address(bytes20(executionCalldata[0:20]));\\n        value = uint256(bytes32(executionCalldata[20:52]));\\n        callData = executionCalldata[52:];\\n    }\\n\\n    function encodeSingle(\\n        address target,\\n        uint256 value,\\n        bytes memory callData\\n    )\\n        internal\\n        pure\\n        returns (bytes memory userOpCalldata)\\n    {\\n        userOpCalldata = abi.encodePacked(target, value, callData);\\n    }\\n}\\n\",\"keccak256\":\"0x5852404ef72dbe607a5402af160494067e7d9e6bf1fbf9460ff309e53b4db399\",\"license\":\"MIT\"},\"contracts/safe7579/lib/ModeLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/**\\n * @title ModeLib\\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\\n * To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\\n * encoding is used.\\n *    Function Signature of execute function:\\n *           function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\\n * This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\\n * context.\\n * NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\\n * implement\\n * more complex execution modes may use the entire bytes32.\\n *\\n * |--------------------------------------------------------------------|\\n * | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\\n * |--------------------------------------------------------------------|\\n * | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\\n * |--------------------------------------------------------------------|\\n *\\n * CALLTYPE: 1 byte\\n * CallType is used to determine how the executeCalldata paramter of the execute function has to be\\n * decoded.\\n * It can be either single, batch or delegatecall. In the future different calls could be added.\\n * CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\\n *\\n * EXECTYPE: 1 byte\\n * ExecType is used to determine how the account should handle the execution.\\n * It can indicate if the execution should revert on failure or continue execution.\\n * In the future more execution modes may be added.\\n * Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\\n * a batch fails, the entire batch is reverted\\n *\\n * UNUSED: 4 bytes\\n * Unused bytes are reserved for future use.\\n *\\n * ModeSelector: bytes4\\n * The \\\"optional\\\" mode selector can be used by account vendors, to implement custom behavior in\\n * their accounts.\\n * the way a ModeSelector is to be calculated is bytes4(keccak256(\\\"vendorname.featurename\\\"))\\n * this is to prevent collisions between different vendors, while allowing innovation and the\\n * development of new features without coordination between ERC-7579 implementing accounts\\n *\\n * ModePayload: 22 bytes\\n * Mode payload is used to pass additional data to the smart account execution, this may be\\n * interpreted depending on the ModeSelector\\n *\\n * ExecutionCallData: n bytes\\n * single, delegatecall or batch exec abi.encoded as bytes\\n */\\n\\n// Custom type for improved developer experience\\ntype ModeCode is bytes32;\\n\\ntype CallType is bytes1;\\n\\ntype ExecType is bytes1;\\n\\ntype ModeSelector is bytes4;\\n\\ntype ModePayload is bytes22;\\n\\n// Default CallType\\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\\n// Batched CallType\\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\\n// @dev Implementing delegatecall is OPTIONAL!\\n// implement delegatecall with extreme care.\\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\\n\\n// @dev default behavior is to revert on failure\\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\\n// Since this is value 0x00, no additional encoding is required for simple accounts\\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\\n// @dev account may elect to change execution behavior. For example \\\"try exec\\\" / \\\"allow fail\\\"\\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\\n\\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\\n// Example declaration of a custom mode selector\\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\\\"default.mode.offset\\\")));\\n\\n/**\\n * @dev ModeLib is a helper library to encode/decode ModeCodes\\n */\\nlibrary ModeLib {\\n    function decode(ModeCode mode)\\n        internal\\n        pure\\n        returns (\\n            CallType _calltype,\\n            ExecType _execType,\\n            ModeSelector _modeSelector,\\n            ModePayload _modePayload\\n        )\\n    {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            _calltype := mode\\n            _execType := shl(8, mode)\\n            _modeSelector := shl(48, mode)\\n            _modePayload := shl(80, mode)\\n        }\\n    }\\n\\n    function encode(\\n        CallType callType,\\n        ExecType execType,\\n        ModeSelector mode,\\n        ModePayload payload\\n    )\\n        internal\\n        pure\\n        returns (ModeCode)\\n    {\\n        return ModeCode.wrap(\\n            bytes32(\\n                abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)\\n            )\\n        );\\n    }\\n\\n    function encodeSimpleBatch() internal pure returns (ModeCode mode) {\\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\\n    }\\n\\n    function encodeSimpleSingle() internal pure returns (ModeCode mode) {\\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\\n    }\\n\\n    function getCallType(ModeCode mode) internal pure returns (CallType calltype) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            calltype := mode\\n        }\\n    }\\n}\\n\\nusing { eqModeSelector as == } for ModeSelector global;\\nusing { eqCallType as == } for CallType global;\\nusing { eqExecType as == } for ExecType global;\\n\\nfunction eqCallType(CallType a, CallType b) pure returns (bool) {\\n    return CallType.unwrap(a) == CallType.unwrap(b);\\n}\\n\\nfunction eqExecType(ExecType a, ExecType b) pure returns (bool) {\\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\\n}\\n\\nfunction eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\\n}\\n\",\"keccak256\":\"0xcfd7f705b61c9e23c6847c964719b7ccd62773692777a4be9b473cf5209c89fd\",\"license\":\"MIT\"},\"erc7579/MSAAdvanced.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport \\\"./lib/ModeLib.sol\\\";\\nimport { ExecutionLib } from \\\"./lib/ExecutionLib.sol\\\";\\nimport { ExecutionHelper } from \\\"./core/ExecutionHelper.sol\\\";\\nimport { PackedUserOperation } from \\\"account-abstraction/interfaces/PackedUserOperation.sol\\\";\\nimport \\\"./interfaces/IERC7579Module.sol\\\";\\nimport { IERC7579Account } from \\\"./interfaces/IERC7579Account.sol\\\";\\nimport { IMSA } from \\\"./interfaces/IMSA.sol\\\";\\nimport { ModuleManager } from \\\"./core/ModuleManager.sol\\\";\\nimport { HookManager } from \\\"./core/HookManager.sol\\\";\\n\\n/**\\n * @author zeroknots.eth | rhinestone.wtf\\n * Reference implementation of a very simple ERC7579 Account.\\n * This account implements CallType: SINGLE, BATCH and DELEGATECALL.\\n * This account implements ExecType: DEFAULT and TRY.\\n * Hook support is implemented\\n */\\ncontract MSAAdvanced is IMSA, ExecutionHelper, ModuleManager, HookManager {\\n    using ExecutionLib for bytes;\\n    using ModeLib for ModeCode;\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     * @dev this function is only callable by the entry point or the account itself\\n     * @dev this function demonstrates how to implement\\n     * CallType SINGLE and BATCH and ExecType DEFAULT and TRY\\n     * @dev this function demonstrates how to implement hook support (modifier)\\n     */\\n    function execute(\\n        ModeCode mode,\\n        bytes calldata executionCalldata\\n    )\\n        external\\n        payable\\n        onlyEntryPointOrSelf\\n        withHook\\n    {\\n        (CallType callType, ExecType execType,,) = mode.decode();\\n\\n        // check if calltype is batch or single\\n        if (callType == CALLTYPE_BATCH) {\\n            // destructure executionCallData according to batched exec\\n            Execution[] calldata executions = executionCalldata.decodeBatch();\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) _execute(executions);\\n            else if (execType == EXECTYPE_TRY) _tryExecute(executions);\\n            else revert UnsupportedExecType(execType);\\n        } else if (callType == CALLTYPE_SINGLE) {\\n            // destructure executionCallData according to single exec\\n            (address target, uint256 value, bytes calldata callData) =\\n                executionCalldata.decodeSingle();\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) _execute(target, value, callData);\\n            // TODO: implement event emission for tryExecute singleCall\\n            else if (execType == EXECTYPE_TRY) _tryExecute(target, value, callData);\\n            else revert UnsupportedExecType(execType);\\n        } else if (callType == CALLTYPE_DELEGATECALL) {\\n            // destructure executionCallData according to single exec\\n            address delegate = address(uint160(bytes20(executionCalldata[0:20])));\\n            bytes calldata callData = executionCalldata[20:];\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) _executeDelegatecall(delegate, callData);\\n            else if (execType == EXECTYPE_TRY) _tryExecuteDelegatecall(delegate, callData);\\n            else revert UnsupportedExecType(execType);\\n        } else {\\n            revert UnsupportedCallType(callType);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     * @dev this function is only callable by an installed executor module\\n     * @dev this function demonstrates how to implement\\n     * CallType SINGLE and BATCH and ExecType DEFAULT and TRY\\n     * @dev this function demonstrates how to implement hook support (modifier)\\n     */\\n    function executeFromExecutor(\\n        ModeCode mode,\\n        bytes calldata executionCalldata\\n    )\\n        external\\n        payable\\n        onlyExecutorModule\\n        withHook\\n        returns (\\n            bytes[] memory returnData // TODO returnData is not used\\n        )\\n    {\\n        (CallType callType, ExecType execType,,) = mode.decode();\\n\\n        // check if calltype is batch or single\\n        if (callType == CALLTYPE_BATCH) {\\n            // destructure executionCallData according to batched exec\\n            Execution[] calldata executions = executionCalldata.decodeBatch();\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) returnData = _execute(executions);\\n            else if (execType == EXECTYPE_TRY) returnData = _tryExecute(executions);\\n            else revert UnsupportedExecType(execType);\\n        } else if (callType == CALLTYPE_SINGLE) {\\n            // destructure executionCallData according to single exec\\n            (address target, uint256 value, bytes calldata callData) =\\n                executionCalldata.decodeSingle();\\n            returnData = new bytes[](1);\\n            bool success;\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) {\\n                returnData[0] = _execute(target, value, callData);\\n            }\\n            // TODO: implement event emission for tryExecute singleCall\\n            else if (execType == EXECTYPE_TRY) {\\n                (success, returnData[0]) = _tryExecute(target, value, callData);\\n                if (!success) emit TryExecuteUnsuccessful(0, returnData[0]);\\n            } else {\\n                revert UnsupportedExecType(execType);\\n            }\\n        } else if (callType == CALLTYPE_DELEGATECALL) {\\n            // destructure executionCallData according to single exec\\n            address delegate = address(uint160(bytes20(executionCalldata[0:20])));\\n            bytes calldata callData = executionCalldata[20:];\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) _executeDelegatecall(delegate, callData);\\n            else if (execType == EXECTYPE_TRY) _tryExecuteDelegatecall(delegate, callData);\\n            else revert UnsupportedExecType(execType);\\n        } else {\\n            revert UnsupportedCallType(callType);\\n        }\\n    }\\n\\n    /**\\n     * @dev ERC-4337 executeUserOp according to ERC-4337 v0.7\\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\\n     *      The implementation of the function is OPTIONAL\\n     *\\n     * @param userOp PackedUserOperation struct (see ERC-4337 v0.7+)\\n     */\\n    function executeUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash\\n    )\\n        external\\n        payable\\n        onlyEntryPoint\\n    {\\n        bytes calldata callData = userOp.callData[4:];\\n        (bool success,) = address(this).delegatecall(callData);\\n        if (!success) revert ExecutionFailed();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function installModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata initData\\n    )\\n        external\\n        payable\\n        onlyEntryPointOrSelf\\n        withHook\\n    {\\n        if (!IModule(module).isModuleType(moduleTypeId)) revert MismatchModuleTypeId(moduleTypeId);\\n\\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) _installValidator(module, initData);\\n        else if (moduleTypeId == MODULE_TYPE_EXECUTOR) _installExecutor(module, initData);\\n        else if (moduleTypeId == MODULE_TYPE_FALLBACK) _installFallbackHandler(module, initData);\\n        else if (moduleTypeId == MODULE_TYPE_HOOK) _installHook(module, initData);\\n        else revert UnsupportedModuleType(moduleTypeId);\\n        emit ModuleInstalled(moduleTypeId, module);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function uninstallModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata deInitData\\n    )\\n        external\\n        payable\\n        onlyEntryPointOrSelf\\n        withHook\\n    {\\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\\n            _uninstallValidator(module, deInitData);\\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\\n            _uninstallExecutor(module, deInitData);\\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\\n            _uninstallFallbackHandler(module, deInitData);\\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\\n            _uninstallHook(module, deInitData);\\n        } else {\\n            revert UnsupportedModuleType(moduleTypeId);\\n        }\\n        emit ModuleUninstalled(moduleTypeId, module);\\n    }\\n\\n    /**\\n     * @dev ERC-4337 validateUserOp according to ERC-4337 v0.7\\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\\n     * this validation function should decode / sload the validator module to validate the userOp\\n     * and call it.\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * @param userOp PackedUserOperation struct (see ERC-4337 v0.7+)\\n     */\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 missingAccountFunds\\n    )\\n        external\\n        payable\\n        virtual\\n        onlyEntryPoint\\n        payPrefund(missingAccountFunds)\\n        returns (uint256 validSignature)\\n    {\\n        address validator;\\n        // @notice validator encoding in nonce is just an example!\\n        // @notice this is not part of the standard!\\n        // Account Vendors may choose any other way to implement validator selection\\n        uint256 nonce = userOp.nonce;\\n        assembly {\\n            validator := shr(96, nonce)\\n        }\\n\\n        // check if validator is enabled. If not terminate the validation phase.\\n        if (!_isValidatorInstalled(validator)) return VALIDATION_FAILED;\\n\\n        // bubble up the return value of the validator module\\n        validSignature = IValidator(validator).validateUserOp(userOp, userOpHash);\\n    }\\n\\n    /**\\n     * @dev ERC-1271 isValidSignature\\n     *         This function is intended to be used to validate a smart account signature\\n     * and may forward the call to a validator module\\n     *\\n     * @param hash The hash of the data that is signed\\n     * @param data The data that is signed\\n     */\\n    function isValidSignature(\\n        bytes32 hash,\\n        bytes calldata data\\n    )\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bytes4)\\n    {\\n        address validator = address(bytes20(data[0:20]));\\n        if (!_isValidatorInstalled(validator)) revert InvalidModule(validator);\\n        return IValidator(validator).isValidSignatureWithSender(msg.sender, hash, data[20:]);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function isModuleInstalled(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata additionalContext\\n    )\\n        external\\n        view\\n        override\\n        returns (bool)\\n    {\\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\\n            return _isValidatorInstalled(module);\\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\\n            return _isExecutorInstalled(module);\\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\\n            return _isFallbackHandlerInstalled(abi.decode(additionalContext, (bytes4)), module);\\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\\n            return _isHookInstalled(module);\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function accountId() external view virtual override returns (string memory) {\\n        // vendor.flavour.SemVer\\n        return \\\"uMSA.advanced/withHook.v0.1\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function supportsExecutionMode(ModeCode mode)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bool isSupported)\\n    {\\n        (CallType callType, ExecType execType,,) = mode.decode();\\n        if (callType == CALLTYPE_BATCH) isSupported = true;\\n        else if (callType == CALLTYPE_SINGLE) isSupported = true;\\n        else if (callType == CALLTYPE_DELEGATECALL) isSupported = true;\\n        // if callType is not single, batch or delegatecall return false\\n        else return false;\\n\\n        if (execType == EXECTYPE_DEFAULT) isSupported = true;\\n        else if (execType == EXECTYPE_TRY) isSupported = true;\\n        // if execType is not default or try, return false\\n        else return false;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function supportsModule(uint256 modulTypeId) external view virtual override returns (bool) {\\n        if (modulTypeId == MODULE_TYPE_VALIDATOR) return true;\\n        else if (modulTypeId == MODULE_TYPE_EXECUTOR) return true;\\n        else if (modulTypeId == MODULE_TYPE_FALLBACK) return true;\\n        else if (modulTypeId == MODULE_TYPE_HOOK) return true;\\n        else return false;\\n    }\\n\\n    /**\\n     * @dev Initializes the account. Function might be called directly, or by a Factory\\n     * @param data. encoded data that can be used during the initialization phase\\n     */\\n    function initializeAccount(bytes calldata data) public payable virtual {\\n        // checks if already initialized and reverts before setting the state to initialized\\n        _initModuleManager();\\n\\n        // this is just implemented for demonstration purposes. You can use any other initialization\\n        // logic here.\\n        (address bootstrap, bytes memory bootstrapCall) = abi.decode(data, (address, bytes));\\n        (bool success,) = bootstrap.delegatecall(bootstrapCall);\\n        if (!success) revert();\\n    }\\n}\\n\",\"keccak256\":\"0x4e9527aaf0860dcb4e97c73f282795236672c807b6c3b25f6fa1773071d01ff4\",\"license\":\"MIT\"},\"erc7579/MSAFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { LibClone } from \\\"solady/utils/LibClone.sol\\\";\\nimport { IMSA } from \\\"./interfaces/IMSA.sol\\\";\\n\\ncontract MSAFactory {\\n    address public immutable implementation;\\n\\n    constructor(address _msaImplementation) {\\n        implementation = _msaImplementation;\\n    }\\n\\n    function createAccount(\\n        bytes32 salt,\\n        bytes calldata initCode\\n    )\\n        public\\n        payable\\n        virtual\\n        returns (address)\\n    {\\n        bytes32 _salt = _getSalt(salt, initCode);\\n        (bool alreadyDeployed, address account) =\\n            LibClone.createDeterministicERC1967(msg.value, implementation, _salt);\\n\\n        if (!alreadyDeployed) {\\n            IMSA(account).initializeAccount(initCode);\\n        }\\n        return account;\\n    }\\n\\n    function getAddress(\\n        bytes32 salt,\\n        bytes calldata initcode\\n    )\\n        public\\n        view\\n        virtual\\n        returns (address)\\n    {\\n        bytes32 _salt = _getSalt(salt, initcode);\\n        return LibClone.predictDeterministicAddressERC1967(implementation, _salt, address(this));\\n    }\\n\\n    function _getSalt(\\n        bytes32 _salt,\\n        bytes calldata initCode\\n    )\\n        public\\n        pure\\n        virtual\\n        returns (bytes32 salt)\\n    {\\n        salt = keccak256(abi.encodePacked(_salt, initCode));\\n    }\\n}\\n\",\"keccak256\":\"0x59cf4ab16a3c0ce97f3b619be9521292628d21539783ed1b057d45f08c488dd6\",\"license\":\"MIT\"},\"erc7579/core/AccountBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\n/**\\n * @title reference implementation of the minimal modular smart account with Hook Extension\\n * @author zeroknots.eth | rhinestone.wtf\\n */\\ncontract AccountBase {\\n    error AccountAccessUnauthorized();\\n\\n    /////////////////////////////////////////////////////\\n    // Access Control\\n    ////////////////////////////////////////////////////\\n\\n    modifier onlyEntryPointOrSelf() virtual {\\n        if (!(msg.sender == entryPoint() || msg.sender == address(this))) {\\n            revert AccountAccessUnauthorized();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyEntryPoint() virtual {\\n        if (msg.sender != entryPoint()) {\\n            revert AccountAccessUnauthorized();\\n        }\\n        _;\\n    }\\n\\n    function entryPoint() public view virtual returns (address) {\\n        return 0x0000000071727De22E5E9d8BAf0edAc6f37da032;\\n    }\\n\\n    /// @dev Sends to the EntryPoint (i.e. `msg.sender`) the missing funds for this transaction.\\n    /// Subclass MAY override this modifier for better funds management.\\n    /// (e.g. send to the EntryPoint more than the minimum required, so that in future transactions\\n    /// it will not be required to send again)\\n    ///\\n    /// `missingAccountFunds` is the minimum value this modifier should send the EntryPoint,\\n    /// which MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\\n    modifier payPrefund(uint256 missingAccountFunds) virtual {\\n        _;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if missingAccountFunds {\\n                // Ignore failure (it's EntryPoint's job to verify, not the account's).\\n                pop(call(gas(), caller(), missingAccountFunds, codesize(), 0x00, codesize(), 0x00))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x11805c609cfd00250d52f440983ea54daaddc2d2bd0da83676ffef6192fecb82\",\"license\":\"MIT\"},\"erc7579/core/ExecutionHelper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { Execution } from \\\"../interfaces/IERC7579Account.sol\\\";\\n\\n/**\\n * @title Execution\\n * @dev This contract executes calls in the context of this contract.\\n * @author zeroknots.eth | rhinestone.wtf\\n * shoutout to solady (vectorized, ross) for this code\\n * https://github.com/Vectorized/solady/blob/main/src/accounts/ERC4337.sol\\n */\\ncontract ExecutionHelper {\\n    error ExecutionFailed();\\n\\n    event TryExecuteUnsuccessful(uint256 batchExecutionindex, bytes result);\\n\\n    function _execute(Execution[] calldata executions) internal returns (bytes[] memory result) {\\n        uint256 length = executions.length;\\n        result = new bytes[](length);\\n\\n        for (uint256 i; i < length; i++) {\\n            Execution calldata _exec = executions[i];\\n            result[i] = _execute(_exec.target, _exec.value, _exec.callData);\\n        }\\n    }\\n\\n    function _tryExecute(Execution[] calldata executions)\\n        internal\\n        returns (bytes[] memory result)\\n    {\\n        uint256 length = executions.length;\\n        result = new bytes[](length);\\n\\n        for (uint256 i; i < length; i++) {\\n            Execution calldata _exec = executions[i];\\n            bool success;\\n            (success, result[i]) = _tryExecute(_exec.target, _exec.value, _exec.callData);\\n            if (!success) emit TryExecuteUnsuccessful(i, result[i]);\\n        }\\n    }\\n\\n    function _execute(\\n        address target,\\n        uint256 value,\\n        bytes calldata callData\\n    )\\n        internal\\n        virtual\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, callData.offset, callData.length)\\n            if iszero(call(gas(), target, value, result, callData.length, codesize(), 0x00)) {\\n                // Bubble up the revert if the call reverts.\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n\\n    function _tryExecute(\\n        address target,\\n        uint256 value,\\n        bytes calldata callData\\n    )\\n        internal\\n        virtual\\n        returns (bool success, bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, callData.offset, callData.length)\\n            success := call(gas(), target, value, result, callData.length, codesize(), 0x00)\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Execute a delegatecall with `delegate` on this account.\\n    function _executeDelegatecall(\\n        address delegate,\\n        bytes calldata callData\\n    )\\n        internal\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, callData.offset, callData.length)\\n            // Forwards the `data` to `delegate` via delegatecall.\\n            if iszero(delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)) {\\n                // Bubble up the revert if the call reverts.\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Execute a delegatecall with `delegate` on this account and catch reverts.\\n    function _tryExecuteDelegatecall(\\n        address delegate,\\n        bytes calldata callData\\n    )\\n        internal\\n        returns (bool success, bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, callData.offset, callData.length)\\n            // Forwards the `data` to `delegate` via delegatecall.\\n            success := delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa8ccc4cdddbcbb51594644a6a3b96657bae861da6461a149ca8e4c2678da0b20\",\"license\":\"MIT\"},\"erc7579/core/HookManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport \\\"./ModuleManager.sol\\\";\\nimport \\\"../interfaces/IERC7579Account.sol\\\";\\nimport \\\"../interfaces/IERC7579Module.sol\\\";\\n\\n/**\\n * @title reference implementation of HookManager\\n * @author zeroknots.eth | rhinestone.wtf\\n */\\nabstract contract HookManager {\\n    /// @custom:storage-location erc7201:hookmanager.storage.msa\\n    struct HookManagerStorage {\\n        IHook _hook;\\n    }\\n\\n    // keccak256(\\\"hookmanager.storage.msa\\\");\\n    bytes32 constant HOOKMANAGER_STORAGE_LOCATION =\\n        0x36e05829dd1b9a4411d96a3549582172d7f071c1c0db5c573fcf94eb28431608;\\n\\n    error HookPostCheckFailed();\\n    error HookAlreadyInstalled(address currentHook);\\n\\n    modifier withHook() {\\n        address hook = _getHook();\\n        if (hook == address(0)) {\\n            _;\\n        } else {\\n            bytes memory hookData = IHook(hook).preCheck(msg.sender, msg.value, msg.data);\\n            _;\\n            IHook(hook).postCheck(hookData);\\n        }\\n    }\\n\\n    function _setHook(address hook) internal virtual {\\n        bytes32 slot = HOOKMANAGER_STORAGE_LOCATION;\\n        assembly {\\n            sstore(slot, hook)\\n        }\\n    }\\n\\n    function _installHook(address hook, bytes calldata data) internal virtual {\\n        address currentHook = _getHook();\\n        if (currentHook != address(0)) {\\n            revert HookAlreadyInstalled(currentHook);\\n        }\\n        _setHook(hook);\\n        IHook(hook).onInstall(data);\\n    }\\n\\n    function _uninstallHook(address hook, bytes calldata data) internal virtual {\\n        _setHook(address(0));\\n        IHook(hook).onUninstall(data);\\n    }\\n\\n    function _getHook() internal view returns (address _hook) {\\n        bytes32 slot = HOOKMANAGER_STORAGE_LOCATION;\\n        assembly {\\n            _hook := sload(slot)\\n        }\\n    }\\n\\n    function _isHookInstalled(address module) internal view returns (bool) {\\n        return _getHook() == module;\\n    }\\n\\n    function getActiveHook() external view returns (address hook) {\\n        return _getHook();\\n    }\\n}\\n\",\"keccak256\":\"0xea44de4892ede553b9642b7bbcfe35745e5129d5a02bd04c90cfa2e15c5ece77\",\"license\":\"MIT\"},\"erc7579/core/ModuleManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { SentinelListLib, SENTINEL } from \\\"sentinellist/SentinelList.sol\\\";\\nimport {\\n    CallType, CALLTYPE_SINGLE, CALLTYPE_DELEGATECALL, CALLTYPE_STATIC\\n} from \\\"../lib/ModeLib.sol\\\";\\nimport { AccountBase } from \\\"./AccountBase.sol\\\";\\nimport \\\"../interfaces/IERC7579Module.sol\\\";\\nimport \\\"forge-std/interfaces/IERC165.sol\\\";\\nimport \\\"./Receiver.sol\\\";\\n\\n/**\\n * @title ModuleManager\\n * @author zeroknots.eth | rhinestone.wtf\\n * @dev This contract manages Validator, Executor and Fallback modules for the MSA\\n * @dev it uses SentinelList to manage the linked list of modules\\n * NOTE: the linked list is just an example. accounts may implement this differently\\n */\\nabstract contract ModuleManager is AccountBase, Receiver {\\n    using SentinelListLib for SentinelListLib.SentinelList;\\n\\n    error InvalidModule(address module);\\n    error NoFallbackHandler(bytes4 selector);\\n    error CannotRemoveLastValidator();\\n\\n    // keccak256(\\\"modulemanager.storage.msa\\\");\\n    bytes32 internal constant MODULEMANAGER_STORAGE_LOCATION =\\n        0xf88ce1fdb7fb1cbd3282e49729100fa3f2d6ee9f797961fe4fb1871cea89ea02;\\n\\n    struct FallbackHandler {\\n        address handler;\\n        CallType calltype;\\n    }\\n\\n    /// @custom:storage-location erc7201:modulemanager.storage.msa\\n    struct ModuleManagerStorage {\\n        // linked list of validators. List is initialized by initializeAccount()\\n        SentinelListLib.SentinelList $valdiators;\\n        // linked list of executors. List is initialized by initializeAccount()\\n        SentinelListLib.SentinelList $executors;\\n        // single fallback handler for all fallbacks\\n        // account vendors may implement this differently. This is just a reference implementation\\n        mapping(bytes4 selector => FallbackHandler fallbackHandler) $fallbacks;\\n    }\\n\\n    function $moduleManager() internal pure virtual returns (ModuleManagerStorage storage $ims) {\\n        bytes32 position = MODULEMANAGER_STORAGE_LOCATION;\\n        assembly {\\n            $ims.slot := position\\n        }\\n    }\\n\\n    modifier onlyExecutorModule() {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\\n        if (!$executors.contains(msg.sender)) revert InvalidModule(msg.sender);\\n        _;\\n    }\\n\\n    modifier onlyValidatorModule(address validator) {\\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\\n        if (!$valdiators.contains(validator)) revert InvalidModule(validator);\\n        _;\\n    }\\n\\n    function _initModuleManager() internal virtual {\\n        ModuleManagerStorage storage $ims = $moduleManager();\\n        $ims.$executors.init();\\n        $ims.$valdiators.init();\\n    }\\n\\n    function isAlreadyInitialized() internal view virtual returns (bool) {\\n        ModuleManagerStorage storage $ims = $moduleManager();\\n        return $ims.$valdiators.alreadyInitialized();\\n    }\\n\\n    /////////////////////////////////////////////////////\\n    //  Manage Validators\\n    ////////////////////////////////////////////////////\\n    function _installValidator(address validator, bytes calldata data) internal virtual {\\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\\n        $valdiators.push(validator);\\n        IValidator(validator).onInstall(data);\\n    }\\n\\n    function _uninstallValidator(address validator, bytes calldata data) internal {\\n        // TODO: check if its the last validator. this might brick the account\\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\\n        (address prev, bytes memory disableModuleData) = abi.decode(data, (address, bytes));\\n        $valdiators.pop(prev, validator);\\n        IValidator(validator).onUninstall(disableModuleData);\\n    }\\n\\n    function _isValidatorInstalled(address validator) internal view virtual returns (bool) {\\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\\n        return $valdiators.contains(validator);\\n    }\\n\\n    /**\\n     * THIS IS NOT PART OF THE STANDARD\\n     * Helper Function to access linked list\\n     */\\n    function getValidatorPaginated(\\n        address cursor,\\n        uint256 size\\n    )\\n        external\\n        view\\n        virtual\\n        returns (address[] memory array, address next)\\n    {\\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\\n        return $valdiators.getEntriesPaginated(cursor, size);\\n    }\\n\\n    /////////////////////////////////////////////////////\\n    //  Manage Executors\\n    ////////////////////////////////////////////////////\\n\\n    function _installExecutor(address executor, bytes calldata data) internal {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\\n        $executors.push(executor);\\n        IExecutor(executor).onInstall(data);\\n    }\\n\\n    function _uninstallExecutor(address executor, bytes calldata data) internal {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\\n        (address prev, bytes memory disableModuleData) = abi.decode(data, (address, bytes));\\n        $executors.pop(prev, executor);\\n        IExecutor(executor).onUninstall(disableModuleData);\\n    }\\n\\n    function _isExecutorInstalled(address executor) internal view virtual returns (bool) {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\\n        return $executors.contains(executor);\\n    }\\n\\n    /**\\n     * THIS IS NOT PART OF THE STANDARD\\n     * Helper Function to access linked list\\n     */\\n    function getExecutorsPaginated(\\n        address cursor,\\n        uint256 size\\n    )\\n        external\\n        view\\n        virtual\\n        returns (address[] memory array, address next)\\n    {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\\n        return $executors.getEntriesPaginated(cursor, size);\\n    }\\n\\n    /////////////////////////////////////////////////////\\n    //  Manage Fallback\\n    ////////////////////////////////////////////////////\\n\\n    function _installFallbackHandler(address handler, bytes calldata params) internal virtual {\\n        bytes4 selector = bytes4(params[0:4]);\\n        CallType calltype = CallType.wrap(bytes1(params[4]));\\n        bytes memory initData = params[5:];\\n\\n        if (_isFallbackHandlerInstalled(selector)) {\\n            revert(\\\"Function selector already used\\\");\\n        }\\n        $moduleManager().$fallbacks[selector] = FallbackHandler(handler, calltype);\\n        IFallback(handler).onInstall(initData);\\n    }\\n\\n    function _uninstallFallbackHandler(\\n        address handler,\\n        bytes calldata deInitData\\n    )\\n        internal\\n        virtual\\n    {\\n        bytes4 selector = bytes4(deInitData[0:4]);\\n        bytes memory _deInitData = deInitData[4:];\\n\\n        if (!_isFallbackHandlerInstalled(selector)) {\\n            revert(\\\"Function selector not used\\\");\\n        }\\n\\n        FallbackHandler memory activeFallback = $moduleManager().$fallbacks[selector];\\n\\n        if (activeFallback.handler != handler) {\\n            revert(\\\"Function selector not used by this handler\\\");\\n        }\\n\\n        CallType callType = activeFallback.calltype;\\n\\n        $moduleManager().$fallbacks[selector] = FallbackHandler(address(0), CallType.wrap(0x00));\\n\\n        IFallback(handler).onUninstall(_deInitData);\\n    }\\n\\n    function _isFallbackHandlerInstalled(bytes4 functionSig) internal view virtual returns (bool) {\\n        FallbackHandler storage $fallback = $moduleManager().$fallbacks[functionSig];\\n        return $fallback.handler != address(0);\\n    }\\n\\n    function _isFallbackHandlerInstalled(\\n        bytes4 functionSig,\\n        address _handler\\n    )\\n        internal\\n        view\\n        virtual\\n        returns (bool)\\n    {\\n        FallbackHandler storage $fallback = $moduleManager().$fallbacks[functionSig];\\n        return $fallback.handler == _handler;\\n    }\\n\\n    function getActiveFallbackHandler(bytes4 functionSig)\\n        external\\n        view\\n        virtual\\n        returns (FallbackHandler memory)\\n    {\\n        return $moduleManager().$fallbacks[functionSig];\\n    }\\n\\n    // FALLBACK\\n    fallback() external payable override(Receiver) receiverFallback {\\n        FallbackHandler storage $fallbackHandler = $moduleManager().$fallbacks[msg.sig];\\n        address handler = $fallbackHandler.handler;\\n        CallType calltype = $fallbackHandler.calltype;\\n        if (handler == address(0)) revert NoFallbackHandler(msg.sig);\\n\\n        if (calltype == CALLTYPE_STATIC) {\\n            assembly {\\n                function allocate(length) -> pos {\\n                    pos := mload(0x40)\\n                    mstore(0x40, add(pos, length))\\n                }\\n\\n                let calldataPtr := allocate(calldatasize())\\n                calldatacopy(calldataPtr, 0, calldatasize())\\n\\n                // The msg.sender address is shifted to the left by 12 bytes to remove the padding\\n                // Then the address without padding is stored right after the calldata\\n                let senderPtr := allocate(20)\\n                mstore(senderPtr, shl(96, caller()))\\n\\n                // Add 20 bytes for the address appended add the end\\n                let success :=\\n                    staticcall(gas(), handler, calldataPtr, add(calldatasize(), 20), 0, 0)\\n\\n                let returnDataPtr := allocate(returndatasize())\\n                returndatacopy(returnDataPtr, 0, returndatasize())\\n                if iszero(success) { revert(returnDataPtr, returndatasize()) }\\n                return(returnDataPtr, returndatasize())\\n            }\\n        }\\n        if (calltype == CALLTYPE_SINGLE) {\\n            assembly {\\n                function allocate(length) -> pos {\\n                    pos := mload(0x40)\\n                    mstore(0x40, add(pos, length))\\n                }\\n\\n                let calldataPtr := allocate(calldatasize())\\n                calldatacopy(calldataPtr, 0, calldatasize())\\n\\n                // The msg.sender address is shifted to the left by 12 bytes to remove the padding\\n                // Then the address without padding is stored right after the calldata\\n                let senderPtr := allocate(20)\\n                mstore(senderPtr, shl(96, caller()))\\n\\n                // Add 20 bytes for the address appended add the end\\n                let success := call(gas(), handler, 0, calldataPtr, add(calldatasize(), 20), 0, 0)\\n\\n                let returnDataPtr := allocate(returndatasize())\\n                returndatacopy(returnDataPtr, 0, returndatasize())\\n                if iszero(success) { revert(returnDataPtr, returndatasize()) }\\n                return(returnDataPtr, returndatasize())\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe74e93d4912692c5fc816e8706030eb8401ec8b862c98c3566230dfd3ed8791f\",\"license\":\"MIT\"},\"erc7579/core/Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/**\\n * @title Receiver\\n * @dev This contract receives safe-transferred ERC721 and ERC1155 tokens.\\n * @author Modified from Solady\\n * (https://github.com/Vectorized/solady/blob/main/src/accounts/Receiver.sol)\\n */\\nabstract contract Receiver {\\n    /// @dev For receiving ETH.\\n    receive() external payable virtual { }\\n\\n    /// @dev Fallback function with the `receiverFallback` modifier.\\n    fallback() external payable virtual receiverFallback { }\\n\\n    /// @dev Modifier for the fallback function to handle token callbacks.\\n    modifier receiverFallback() virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := shr(224, calldataload(0))\\n            // 0x150b7a02: `onERC721Received(address,address,uint256,bytes)`.\\n            // 0xf23a6e61: `onERC1155Received(address,address,uint256,uint256,bytes)`.\\n            // 0xbc197c81: `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\\n            if or(eq(s, 0x150b7a02), or(eq(s, 0xf23a6e61), eq(s, 0xbc197c81))) {\\n                mstore(0x20, s) // Store `msg.sig`.\\n                return(0x3c, 0x20) // Return `msg.sig`.\\n            }\\n        }\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x42d41b30a6582d95d737fd75122b621a8af1ec3123782d91a29385b67612b9e4\",\"license\":\"MIT\"},\"erc7579/interfaces/IERC4337Account.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { PackedUserOperation } from \\\"account-abstraction/interfaces/PackedUserOperation.sol\\\";\\n\\ninterface IERC4337Account {\\n    /**\\n     * Validate user's signature and nonce\\n     * the entryPoint will make the call to the recipient only if this validation call returns\\n     * successfully.\\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\\n     * This allows making a \\\"simulation call\\\" without a valid signature\\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to\\n     * signal failure.\\n     *\\n     * @dev Must validate caller is the entryPoint.\\n     *      Must validate the signature and nonce\\n     * @param userOp              - The operation that is about to be executed.\\n     * @param userOpHash          - Hash of the user's request data. can be used as the basis for\\n     * signature.\\n     * @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\\n     *                              This is the minimum amount to transfer to the sender(entryPoint)\\n     * to be\\n     *                              able to make the call. The excess is left as a deposit in the\\n     * entrypoint\\n     *                              for future calls. Can be withdrawn anytime using\\n     * \\\"entryPoint.withdrawTo()\\\".\\n     *                              In case there is a paymaster in the request (or the current\\n     * deposit is high\\n     *                              enough), this value will be zero.\\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData`\\n     * and\\n     *                              `_unpackValidationData` to encode and decode.\\n     *                              <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark\\n     * signature failure,\\n     *                                 otherwise, an address of an \\\"authorizer\\\" contract.\\n     *                              <6-byte> validUntil - Last timestamp this operation is valid. 0\\n     * for \\\"indefinite\\\"\\n     *                              <6-byte> validAfter - First timestamp this operation is valid\\n     *                                                    If an account doesn't use time-range, it\\n     * is enough to\\n     *                                                    return SIG_VALIDATION_FAILED value (1) for\\n     * signature failure.\\n     *                              Note that the validation code cannot use block.timestamp (or\\n     * block.number) directly.\\n     */\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 missingAccountFunds\\n    )\\n        external\\n        payable\\n        returns (uint256 validationData);\\n\\n    /**\\n     * Account may implement this execute method.\\n     * passing this methodSig at the beginning of callData will cause the entryPoint to pass the\\n     * full UserOp (and hash)\\n     * to the account.\\n     * The account should skip the methodSig, and use the callData (and optionally, other UserOp\\n     * fields)\\n     *\\n     * @param userOp              - The operation that was just validated.\\n     * @param userOpHash          - Hash of the user's request data.\\n     */\\n    function executeUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash\\n    )\\n        external\\n        payable;\\n}\\n\",\"keccak256\":\"0x55f4a9fe65535a8b3f6db727c764aad1eb237a22828f2565941d0c079e9b7e3e\",\"license\":\"MIT\"},\"erc7579/interfaces/IERC7579Account.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { CallType, ExecType, ModeCode } from \\\"../lib/ModeLib.sol\\\";\\n\\nstruct Execution {\\n    address target;\\n    uint256 value;\\n    bytes callData;\\n}\\n\\ninterface IERC7579Account {\\n    event ModuleInstalled(uint256 moduleTypeId, address module);\\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\\n\\n    /**\\n     * @dev Executes a transaction on behalf of the account.\\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * If a mode is requested that is not supported by the Account, it MUST revert\\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\\n     * @param executionCalldata The encoded execution call data\\n     */\\n    function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\\n\\n    /**\\n     * @dev Executes a transaction on behalf of the account.\\n     *         This function is intended to be called by Executor Modules\\n     * @dev Ensure adequate authorization control: i.e. onlyExecutorModule\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * If a mode is requested that is not supported by the Account, it MUST revert\\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\\n     * @param executionCalldata The encoded execution call data\\n     */\\n    function executeFromExecutor(\\n        ModeCode mode,\\n        bytes calldata executionCalldata\\n    )\\n        external\\n        payable\\n        returns (bytes[] memory returnData);\\n\\n    /**\\n     * @dev ERC-1271 isValidSignature\\n     *         This function is intended to be used to validate a smart account signature\\n     * and may forward the call to a validator module\\n     *\\n     * @param hash The hash of the data that is signed\\n     * @param data The data that is signed\\n     */\\n    function isValidSignature(bytes32 hash, bytes calldata data) external view returns (bytes4);\\n\\n    /**\\n     * @dev installs a Module of a certain type on the smart account\\n     * @dev Implement Authorization control of your chosing\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     * @param module the module address\\n     * @param initData arbitrary data that may be required on the module during `onInstall`\\n     * initialization.\\n     */\\n    function installModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata initData\\n    )\\n        external\\n        payable;\\n\\n    /**\\n     * @dev uninstalls a Module of a certain type on the smart account\\n     * @dev Implement Authorization control of your chosing\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     * @param module the module address\\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\\n     * de-initialization.\\n     */\\n    function uninstallModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata deInitData\\n    )\\n        external\\n        payable;\\n\\n    /**\\n     * Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\\n     * @param encodedMode the encoded mode\\n     */\\n    function supportsExecutionMode(ModeCode encodedMode) external view returns (bool);\\n\\n    /**\\n     * Function to check if the account supports installation of a certain module type Id\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     */\\n    function supportsModule(uint256 moduleTypeId) external view returns (bool);\\n\\n    /**\\n     * Function to check if the account has a certain module installed\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\\n     *            thus may be necessary to query multiple module types\\n     * @param module the module address\\n     * @param additionalContext additional context data that the smart account may interpret to\\n     *                          identifiy conditions under which the module is installed.\\n     *                          usually this is not necessary, but for some special hooks that\\n     *                          are stored in mappings, this param might be needed\\n     */\\n    function isModuleInstalled(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata additionalContext\\n    )\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the account id of the smart account\\n     * @return accountImplementationId the account id of the smart account\\n     * the accountId should be structured like so:\\n     *        \\\"vendorname.accountname.semver\\\"\\n     */\\n    function accountId() external view returns (string memory accountImplementationId);\\n}\\n\",\"keccak256\":\"0x08368aba5f1bb83eb57e9f8d31a04edee4be69159b4844a6443f65100917011c\",\"license\":\"MIT\"},\"erc7579/interfaces/IERC7579Module.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { PackedUserOperation } from \\\"account-abstraction/interfaces/PackedUserOperation.sol\\\";\\n\\nuint256 constant VALIDATION_SUCCESS = 0;\\nuint256 constant VALIDATION_FAILED = 1;\\n\\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\\nuint256 constant MODULE_TYPE_FALLBACK = 3;\\nuint256 constant MODULE_TYPE_HOOK = 4;\\n\\ninterface IModule {\\n    error AlreadyInitialized(address smartAccount);\\n    error NotInitialized(address smartAccount);\\n\\n    /**\\n     * @dev This function is called by the smart account during installation of the module\\n     * @param data arbitrary data that may be required on the module during `onInstall`\\n     * initialization\\n     *\\n     * MUST revert on error (i.e. if module is already enabled)\\n     */\\n    function onInstall(bytes calldata data) external;\\n\\n    /**\\n     * @dev This function is called by the smart account during uninstallation of the module\\n     * @param data arbitrary data that may be required on the module during `onUninstall`\\n     * de-initialization\\n     *\\n     * MUST revert on error\\n     */\\n    function onUninstall(bytes calldata data) external;\\n\\n    /**\\n     * @dev Returns boolean value if module is a certain type\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     *\\n     * MUST return true if the module is of the given type and false otherwise\\n     */\\n    function isModuleType(uint256 moduleTypeId) external view returns (bool);\\n\\n    /**\\n     * @dev Returns if the module was already initialized for a provided smartaccount\\n     */\\n    function isInitialized(address smartAccount) external view returns (bool);\\n}\\n\\ninterface IValidator is IModule {\\n    error InvalidTargetAddress(address target);\\n\\n    /**\\n     * @dev Validates a transaction on behalf of the account.\\n     *         This function is intended to be called by the MSA during the ERC-4337 validaton phase\\n     *         Note: solely relying on bytes32 hash and signature is not suffcient for some\\n     * validation implementations (i.e. SessionKeys often need access to userOp.calldata)\\n     * @param userOp The user operation to be validated. The userOp MUST NOT contain any metadata.\\n     * The MSA MUST clean up the userOp before sending it to the validator.\\n     * @param userOpHash The hash of the user operation to be validated\\n     * @return return value according to ERC-4337\\n     */\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash\\n    )\\n        external\\n        returns (uint256);\\n\\n    /**\\n     * Validator can be used for ERC-1271 validation\\n     */\\n    function isValidSignatureWithSender(\\n        address sender,\\n        bytes32 hash,\\n        bytes calldata data\\n    )\\n        external\\n        view\\n        returns (bytes4);\\n}\\n\\ninterface IExecutor is IModule { }\\n\\ninterface IHook is IModule {\\n    function preCheck(\\n        address msgSender,\\n        uint256 msgValue,\\n        bytes calldata msgData\\n    )\\n        external\\n        returns (bytes memory hookData);\\n\\n    function postCheck(bytes calldata hookData) external;\\n}\\n\\ninterface IFallback is IModule { }\\n\",\"keccak256\":\"0x78ab984fc364972382a73a0d793c558f52800999d5e0e69c4df326a1de840604\",\"license\":\"MIT\"},\"erc7579/interfaces/IMSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { IERC7579Account } from \\\"./IERC7579Account.sol\\\";\\nimport { IERC4337Account } from \\\"./IERC4337Account.sol\\\";\\n\\nimport { CallType, ExecType, ModeCode } from \\\"../lib/ModeLib.sol\\\";\\n\\ninterface IMSA is IERC7579Account, IERC4337Account {\\n    // Error thrown when an unsupported ModuleType is requested\\n    error UnsupportedModuleType(uint256 moduleTypeId);\\n    // Error thrown when an execution with an unsupported CallType was made\\n    error UnsupportedCallType(CallType callType);\\n    // Error thrown when an execution with an unsupported ExecType was made\\n    error UnsupportedExecType(ExecType execType);\\n    // Error thrown when account initialization fails\\n    error AccountInitializationFailed();\\n    // Error thrown when account installs/unistalls module with mismatched input `moduleTypeId`\\n    error MismatchModuleTypeId(uint256 moduleTypeId);\\n\\n    /**\\n     * @dev Initializes the account. Function might be called directly, or by a Factory\\n     * @param data. encoded data that can be used during the initialization phase\\n     */\\n    function initializeAccount(bytes calldata data) external payable;\\n}\\n\",\"keccak256\":\"0x649ef44dfc5ba9b485b31cda765335e96f35aa6e595fd8d86c28a62aa8982cbe\",\"license\":\"MIT\"},\"erc7579/lib/ExecutionLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { Execution } from \\\"../interfaces/IERC7579Account.sol\\\";\\n\\n/**\\n * Helper Library for decoding Execution calldata\\n * malloc for memory allocation is bad for gas. use this assembly instead\\n */\\nlibrary ExecutionLib {\\n    function decodeBatch(bytes calldata callData)\\n        internal\\n        pure\\n        returns (Execution[] calldata executionBatch)\\n    {\\n        /*\\n         * Batch Call Calldata Layout\\n         * Offset (in bytes)    | Length (in bytes) | Contents\\n         * 0x0                  | 0x4               | bytes4 function selector\\n        *  0x4                  | -                 |\\n        abi.encode(IERC7579Execution.Execution[])\\n         */\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            let dataPointer := add(callData.offset, calldataload(callData.offset))\\n\\n            // Extract the ERC7579 Executions\\n            executionBatch.offset := add(dataPointer, 32)\\n            executionBatch.length := calldataload(dataPointer)\\n        }\\n    }\\n\\n    function encodeBatch(Execution[] memory executions)\\n        internal\\n        pure\\n        returns (bytes memory callData)\\n    {\\n        callData = abi.encode(executions);\\n    }\\n\\n    function decodeSingle(bytes calldata executionCalldata)\\n        internal\\n        pure\\n        returns (address target, uint256 value, bytes calldata callData)\\n    {\\n        target = address(bytes20(executionCalldata[0:20]));\\n        value = uint256(bytes32(executionCalldata[20:52]));\\n        callData = executionCalldata[52:];\\n    }\\n\\n    function encodeSingle(\\n        address target,\\n        uint256 value,\\n        bytes memory callData\\n    )\\n        internal\\n        pure\\n        returns (bytes memory userOpCalldata)\\n    {\\n        userOpCalldata = abi.encodePacked(target, value, callData);\\n    }\\n}\\n\",\"keccak256\":\"0xa6d41aa7532a4bff83a8c335a8050ebe0c7a73c456d70594d2123dc293892c5c\",\"license\":\"MIT\"},\"erc7579/lib/ModeLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/**\\n * @title ModeLib\\n * To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\\n * encoding is used.\\n *    Function Signature of execute function:\\n *           function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\\n * This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\\n * context.\\n * NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\\n * implement\\n * more complex execution modes may use the entire bytes32.\\n *\\n * |--------------------------------------------------------------------|\\n * | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\\n * |--------------------------------------------------------------------|\\n * | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\\n * |--------------------------------------------------------------------|\\n *\\n * CALLTYPE: 1 byte\\n * CallType is used to determine how the executeCalldata paramter of the execute function has to be\\n * decoded.\\n * It can be either single, batch or delegatecall. In the future different calls could be added.\\n * CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\\n *\\n * EXECTYPE: 1 byte\\n * ExecType is used to determine how the account should handle the execution.\\n * It can indicate if the execution should revert on failure or continue execution.\\n * In the future more execution modes may be added.\\n * Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\\n * a batch fails, the entire batch is reverted\\n *\\n * UNUSED: 4 bytes\\n * Unused bytes are reserved for future use.\\n *\\n * ModeSelector: bytes4\\n * The \\\"optional\\\" mode selector can be used by account vendors, to implement custom behavior in\\n * their accounts.\\n * the way a ModeSelector is to be calculated is bytes4(keccak256(\\\"vendorname.featurename\\\"))\\n * this is to prevent collisions between different vendors, while allowing innovation and the\\n * development of new features without coordination between ERC-7579 implementing accounts\\n *\\n * ModePayload: 22 bytes\\n * Mode payload is used to pass additional data to the smart account execution, this may be\\n * interpreted depending on the ModeSelector\\n *\\n * ExecutionCallData: n bytes\\n * single, delegatecall or batch exec abi.encoded as bytes\\n */\\nimport { Execution } from \\\"../interfaces/IERC7579Account.sol\\\";\\n\\n// Custom type for improved developer experience\\ntype ModeCode is bytes32;\\n\\ntype CallType is bytes1;\\n\\ntype ExecType is bytes1;\\n\\ntype ModeSelector is bytes4;\\n\\ntype ModePayload is bytes22;\\n\\n// Default CallType\\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\\n// Batched CallType\\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\\n// @dev Implementing delegatecall is OPTIONAL!\\n// implement delegatecall with extreme care.\\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\\n\\n// @dev default behavior is to revert on failure\\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\\n// Since this is value 0x00, no additional encoding is required for simple accounts\\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\\n// @dev account may elect to change execution behavior. For example \\\"try exec\\\" / \\\"allow fail\\\"\\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\\n\\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\\n// Example declaration of a custom mode selector\\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\\\"default.mode.offset\\\")));\\n\\n/**\\n * @dev ModeLib is a helper library to encode/decode ModeCodes\\n */\\nlibrary ModeLib {\\n    function decode(ModeCode mode)\\n        internal\\n        pure\\n        returns (\\n            CallType _calltype,\\n            ExecType _execType,\\n            ModeSelector _modeSelector,\\n            ModePayload _modePayload\\n        )\\n    {\\n        assembly {\\n            _calltype := mode\\n            _execType := shl(8, mode)\\n            _modeSelector := shl(48, mode)\\n            _modePayload := shl(80, mode)\\n        }\\n    }\\n\\n    function encode(\\n        CallType callType,\\n        ExecType execType,\\n        ModeSelector mode,\\n        ModePayload payload\\n    )\\n        internal\\n        pure\\n        returns (ModeCode)\\n    {\\n        return ModeCode.wrap(\\n            bytes32(\\n                abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)\\n            )\\n        );\\n    }\\n\\n    function encodeSimpleBatch() internal pure returns (ModeCode mode) {\\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\\n    }\\n\\n    function encodeSimpleSingle() internal pure returns (ModeCode mode) {\\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\\n    }\\n\\n    function getCallType(ModeCode mode) internal pure returns (CallType calltype) {\\n        assembly {\\n            calltype := mode\\n        }\\n    }\\n}\\n\\nusing { eqModeSelector as == } for ModeSelector global;\\nusing { eqCallType as == } for CallType global;\\nusing { eqExecType as == } for ExecType global;\\n\\nfunction eqCallType(CallType a, CallType b) pure returns (bool) {\\n    return CallType.unwrap(a) == CallType.unwrap(b);\\n}\\n\\nfunction eqExecType(ExecType a, ExecType b) pure returns (bool) {\\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\\n}\\n\\nfunction eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\\n}\\n\",\"keccak256\":\"0x02ce0fc8805d1427841f32e2335157e3fae18e99d5c49ba46d53e12fcd1a5185\",\"license\":\"MIT\"},\"erc7579/utils/Bootstrap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport \\\"../core/ModuleManager.sol\\\";\\nimport \\\"../core/HookManager.sol\\\";\\n\\nimport \\\"../interfaces/IERC7579Module.sol\\\";\\n\\nstruct BootstrapConfig {\\n    address module;\\n    bytes data;\\n}\\n\\ncontract Bootstrap is ModuleManager, HookManager {\\n    function singleInitMSA(IModule validator, bytes calldata data) external {\\n        // init validator\\n        _installValidator(address(validator), data);\\n    }\\n\\n    /**\\n     * This function is intended to be called by the MSA with a delegatecall.\\n     * Make sure that the MSA already initilazed the linked lists in the ModuleManager prior to\\n     * calling this function\\n     */\\n    function initMSA(\\n        BootstrapConfig[] calldata $valdiators,\\n        BootstrapConfig[] calldata $executors,\\n        BootstrapConfig calldata _hook,\\n        BootstrapConfig[] calldata _fallbacks\\n    )\\n        external\\n    {\\n        // init validators\\n        for (uint256 i; i < $valdiators.length; i++) {\\n            _installValidator($valdiators[i].module, $valdiators[i].data);\\n        }\\n\\n        // init executors\\n        for (uint256 i; i < $executors.length; i++) {\\n            if ($executors[i].module == address(0)) continue;\\n            _installExecutor($executors[i].module, $executors[i].data);\\n        }\\n\\n        // init hook\\n        if (_hook.module != address(0)) {\\n            _installHook(_hook.module, _hook.data);\\n        }\\n\\n        // init fallback\\n        for (uint256 i; i < _fallbacks.length; i++) {\\n            if (_fallbacks[i].module == address(0)) continue;\\n            _installFallbackHandler(_fallbacks[i].module, _fallbacks[i].data);\\n        }\\n    }\\n\\n    function _getInitMSACalldata(\\n        BootstrapConfig[] calldata $valdiators,\\n        BootstrapConfig[] calldata $executors,\\n        BootstrapConfig calldata _hook,\\n        BootstrapConfig[] calldata _fallbacks\\n    )\\n        external\\n        view\\n        returns (bytes memory init)\\n    {\\n        init = abi.encode(\\n            address(this),\\n            abi.encodeCall(this.initMSA, ($valdiators, $executors, _hook, _fallbacks))\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x0f1474b9f03cc19e781766784dc28d701036d2a06145c16fb3b88e7746249ef3\",\"license\":\"MIT\"},\"forge-std/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    /// uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x414b2861b1acbf816ccb7346d3f16cf6c1e002e9e5e40d2f1f26fa5ddc2ea600\",\"license\":\"MIT\"},\"forge-std/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\n/// @dev Interface of the ERC20 standard as defined in the EIP.\\n/// @dev This includes the optional name, symbol, and decimals metadata.\\ninterface IERC20 {\\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\\n    /// is the new allowance.\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice Returns the amount of tokens in existence.\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Returns the amount of tokens owned by `account`.\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\\n    /// to spend on behalf of `owner`\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\\n    /// `amount` is then deducted from the caller's allowance.\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Returns the name of the token.\\n    function name() external view returns (string memory);\\n\\n    /// @notice Returns the symbol of the token.\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Returns the decimals places of the token.\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x4cab887298790f908c27de107e4e2907ca5413aee482ef776f8d2f353c5ef947\",\"license\":\"MIT\"},\"forge-std/interfaces/IERC4626.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/// @dev Interface of the ERC4626 \\\"Tokenized Vault Standard\\\", as defined in\\n/// https://eips.ethereum.org/EIPS/eip-4626\\ninterface IERC4626 is IERC20 {\\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\\n    );\\n\\n    /// @notice Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\\n    /// @dev\\n    /// - MUST be an ERC-20 token contract.\\n    /// - MUST NOT revert.\\n    function asset() external view returns (address assetTokenAddress);\\n\\n    /// @notice Returns the total amount of the underlying asset that is \\u201cmanaged\\u201d by Vault.\\n    /// @dev\\n    /// - SHOULD include any compounding that occurs from yield.\\n    /// - MUST be inclusive of any fees that are charged against assets in the Vault.\\n    /// - MUST NOT revert.\\n    function totalAssets() external view returns (uint256 totalManagedAssets);\\n\\n    /// @notice Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\\n    /// scenario where all the conditions are met.\\n    /// @dev\\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n    /// - MUST NOT show any variations depending on the caller.\\n    /// - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: This calculation MAY NOT reflect the \\u201cper-user\\u201d price-per-share, and instead should reflect the\\n    /// \\u201caverage-user\\u2019s\\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n    /// from.\\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\\n\\n    /// @notice Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\\n    /// scenario where all the conditions are met.\\n    /// @dev\\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n    /// - MUST NOT show any variations depending on the caller.\\n    /// - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: This calculation MAY NOT reflect the \\u201cper-user\\u201d price-per-share, and instead should reflect the\\n    /// \\u201caverage-user\\u2019s\\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n    /// from.\\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n\\n    /// @notice Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\\n    /// through a deposit call.\\n    /// @dev\\n    /// - MUST return a limited value if receiver is subject to some deposit limit.\\n    /// - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\\n    /// - MUST NOT revert.\\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\\n\\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\\n    /// current on-chain conditions.\\n    /// @dev\\n    /// - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\\n    ///   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\\n    ///   in the same transaction.\\n    /// - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\\n    ///   deposit would be accepted, regardless if the user has enough tokens approved, etc.\\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\\n    /// share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\\n\\n    /// @notice Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\\n    /// @dev\\n    /// - MUST emit the Deposit event.\\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n    ///   deposit execution, and are accounted for during deposit.\\n    /// - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\\n    ///   approving enough underlying tokens to the Vault contract, etc).\\n    ///\\n    /// NOTE: most implementations will require pre-approval of the Vault with the Vault\\u2019s underlying asset token.\\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\\n\\n    /// @notice Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\\n    /// @dev\\n    /// - MUST return a limited value if receiver is subject to some mint limit.\\n    /// - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\\n    /// - MUST NOT revert.\\n    function maxMint(address receiver) external view returns (uint256 maxShares);\\n\\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\\n    /// current on-chain conditions.\\n    /// @dev\\n    /// - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\\n    ///   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\\n    ///   same transaction.\\n    /// - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\\n    ///   would be accepted, regardless if the user has enough tokens approved, etc.\\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\\n    /// share price or some other type of condition, meaning the depositor will lose assets by minting.\\n    function previewMint(uint256 shares) external view returns (uint256 assets);\\n\\n    /// @notice Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\\n    /// @dev\\n    /// - MUST emit the Deposit event.\\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\\n    ///   execution, and are accounted for during mint.\\n    /// - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\\n    ///   approving enough underlying tokens to the Vault contract, etc).\\n    ///\\n    /// NOTE: most implementations will require pre-approval of the Vault with the Vault\\u2019s underlying asset token.\\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\\n\\n    /// @notice Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\\n    /// Vault, through a withdraw call.\\n    /// @dev\\n    /// - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n    /// - MUST NOT revert.\\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\\n\\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\\n    /// given current on-chain conditions.\\n    /// @dev\\n    /// - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\\n    ///   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\\n    ///   called\\n    ///   in the same transaction.\\n    /// - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\\n    ///   the withdrawal would be accepted, regardless if the user has enough shares, etc.\\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\\n    /// share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\\n\\n    /// @notice Burns shares from owner and sends exactly assets of underlying tokens to receiver.\\n    /// @dev\\n    /// - MUST emit the Withdraw event.\\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n    ///   withdraw execution, and are accounted for during withdraw.\\n    /// - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\\n    ///   not having enough shares, etc).\\n    ///\\n    /// Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n    /// Those methods should be performed separately.\\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\\n\\n    /// @notice Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\\n    /// through a redeem call.\\n    /// @dev\\n    /// - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n    /// - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\\n    /// - MUST NOT revert.\\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\\n\\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\\n    /// given current on-chain conditions.\\n    /// @dev\\n    /// - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\\n    ///   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\\n    ///   same transaction.\\n    /// - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\\n    ///   redemption would be accepted, regardless if the user has enough shares, etc.\\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\\n    /// share price or some other type of condition, meaning the depositor will lose assets by redeeming.\\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\\n\\n    /// @notice Burns exactly shares from owner and sends assets of underlying tokens to receiver.\\n    /// @dev\\n    /// - MUST emit the Withdraw event.\\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n    ///   redeem execution, and are accounted for during redeem.\\n    /// - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\\n    ///   not having enough shares, etc).\\n    ///\\n    /// NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n    /// Those methods should be performed separately.\\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\\n}\\n\",\"keccak256\":\"0x324b43bdb94d78fe11220102056ba27362b7083fbc394fddc86dd68f75c0e46e\",\"license\":\"MIT\"},\"forge-std/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/// @title ERC-721 Non-Fungible Token Standard\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// Note: the ERC-165 identifier for this interface is 0x80ac58cd.\\ninterface IERC721 is IERC165 {\\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\\n    /// This event emits when NFTs are created (`from` == 0) and destroyed\\n    /// (`to` == 0). Exception: during contract creation, any number of NFTs\\n    /// may be created and assigned without emitting Transfer. At the time of\\n    /// any transfer, the approved address for that NFT (if any) is reset to none.\\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\\n\\n    /// @dev This emits when the approved address for an NFT is changed or\\n    /// reaffirmed. The zero address indicates there is no approved address.\\n    /// When a Transfer event emits, this also indicates that the approved\\n    /// address for that NFT (if any) is reset to none.\\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\\n\\n    /// @dev This emits when an operator is enabled or disabled for an owner.\\n    /// The operator can manage all NFTs of the owner.\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n    /// @notice Count all NFTs assigned to an owner\\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\\n    /// function throws for queries about the zero address.\\n    /// @param _owner An address for whom to query the balance\\n    /// @return The number of NFTs owned by `_owner`, possibly zero\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    /// @notice Find the owner of an NFT\\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\\n    /// about them do throw.\\n    /// @param _tokenId The identifier for an NFT\\n    /// @return The address of the owner of the NFT\\n    function ownerOf(uint256 _tokenId) external view returns (address);\\n\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n    /// operator, or the approved address for this NFT. Throws if `_from` is\\n    /// not the current owner. Throws if `_to` is the zero address. Throws if\\n    /// `_tokenId` is not a valid NFT. When transfer is complete, this function\\n    /// checks if `_to` is a smart contract (code size > 0). If so, it calls\\n    /// `onERC721Received` on `_to` and throws if the return value is not\\n    /// `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    /// @param data Additional data with no specified format, sent in call to `_to`\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\\n\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\n    /// @dev This works identically to the other function with an extra data parameter,\\n    /// except this function just sets data to \\\"\\\".\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\\n\\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\n    /// TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\n    /// THEY MAY BE PERMANENTLY LOST\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n    /// operator, or the approved address for this NFT. Throws if `_from` is\\n    /// not the current owner. Throws if `_to` is the zero address. Throws if\\n    /// `_tokenId` is not a valid NFT.\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\\n\\n    /// @notice Change or reaffirm the approved address for an NFT\\n    /// @dev The zero address indicates there is no approved address.\\n    /// Throws unless `msg.sender` is the current NFT owner, or an authorized\\n    /// operator of the current owner.\\n    /// @param _approved The new approved NFT controller\\n    /// @param _tokenId The NFT to approve\\n    function approve(address _approved, uint256 _tokenId) external payable;\\n\\n    /// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\n    /// all of `msg.sender`'s assets\\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\\n    /// multiple operators per owner.\\n    /// @param _operator Address to add to the set of authorized operators\\n    /// @param _approved True if the operator is approved, false to revoke approval\\n    function setApprovalForAll(address _operator, bool _approved) external;\\n\\n    /// @notice Get the approved address for a single NFT\\n    /// @dev Throws if `_tokenId` is not a valid NFT.\\n    /// @param _tokenId The NFT to find the approved address for\\n    /// @return The approved address for this NFT, or the zero address if there is none\\n    function getApproved(uint256 _tokenId) external view returns (address);\\n\\n    /// @notice Query if an address is an authorized operator for another address\\n    /// @param _owner The address that owns the NFTs\\n    /// @param _operator The address that acts on behalf of the owner\\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\\n}\\n\\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\\ninterface IERC721TokenReceiver {\\n    /// @notice Handle the receipt of an NFT\\n    /// @dev The ERC721 smart contract calls this function on the recipient\\n    /// after a `transfer`. This function MAY throw to revert and reject the\\n    /// transfer. Return of other than the magic value MUST result in the\\n    /// transaction being reverted.\\n    /// Note: the contract address is always the message sender.\\n    /// @param _operator The address which called `safeTransferFrom` function\\n    /// @param _from The address which previously owned the token\\n    /// @param _tokenId The NFT identifier which is being transferred\\n    /// @param _data Additional data with no specified format\\n    /// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    ///  unless throwing\\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data)\\n        external\\n        returns (bytes4);\\n}\\n\\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// Note: the ERC-165 identifier for this interface is 0x5b5e139f.\\ninterface IERC721Metadata is IERC721 {\\n    /// @notice A descriptive name for a collection of NFTs in this contract\\n    function name() external view returns (string memory _name);\\n\\n    /// @notice An abbreviated name for NFTs in this contract\\n    function symbol() external view returns (string memory _symbol);\\n\\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\\n    /// 3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\n    /// Metadata JSON Schema\\\".\\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\\n}\\n\\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// Note: the ERC-165 identifier for this interface is 0x780e9d63.\\ninterface IERC721Enumerable is IERC721 {\\n    /// @notice Count NFTs tracked by this contract\\n    /// @return A count of valid NFTs tracked by this contract, where each one of\\n    /// them has an assigned and queryable owner not equal to the zero address\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Enumerate valid NFTs\\n    /// @dev Throws if `_index` >= `totalSupply()`.\\n    /// @param _index A counter less than `totalSupply()`\\n    /// @return The token identifier for the `_index`th NFT,\\n    /// (sort order not specified)\\n    function tokenByIndex(uint256 _index) external view returns (uint256);\\n\\n    /// @notice Enumerate NFTs assigned to an owner\\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\\n    /// `_owner` is the zero address, representing invalid NFTs.\\n    /// @param _owner An address where we are interested in NFTs owned by them\\n    /// @param _index A counter less than `balanceOf(_owner)`\\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\\n    /// (sort order not specified)\\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xf069262a264fdb69f8f37a10d2df7374649e9ba73f8414c9c8a3b51184625f15\",\"license\":\"MIT\"},\"modulekit/Accounts.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable no-unused-import */\\nimport { Execution, IERC7579Account } from \\\"./external/ERC7579.sol\\\";\\n\",\"keccak256\":\"0xbebda0e48bf4fe679dedb8a413cce6591b671a165d7ed534ca1a4a10e5e1e169\",\"license\":\"MIT\"},\"modulekit/Integrations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable no-unused-import */\\nimport { ERC20Integration } from \\\"./integrations/ERC20.sol\\\";\\nimport { ERC721Integration } from \\\"./integrations/ERC721.sol\\\";\\nimport { ERC4626Integration } from \\\"./integrations/ERC4626.sol\\\";\\nimport { UniswapV3Integration, SWAPROUTER_ADDRESS } from \\\"./integrations/uniswap/v3/Uniswap.sol\\\";\\n\",\"keccak256\":\"0x88dc1c5c76d3e00df19a173bd71632240bfcac5d2edaff628d1ac38f8e1af9bb\",\"license\":\"MIT\"},\"modulekit/external/ERC7579.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable no-unused-import */\\nimport { MSAFactory as ERC7579AccountFactory } from \\\"erc7579/MSAFactory.sol\\\";\\nimport { MSAAdvanced as ERC7579Account } from \\\"erc7579/MSAAdvanced.sol\\\";\\nimport { Execution, IERC7579Account } from \\\"erc7579/interfaces/IERC7579Account.sol\\\";\\nimport { IMSA } from \\\"erc7579/interfaces/IMSA.sol\\\";\\nimport {\\n    IModule as IERC7579Module,\\n    IValidator as IERC7579Validator,\\n    IExecutor as IERC7579Executor,\\n    IHook as IERC7579Hook,\\n    IFallback as IERC7579Fallback,\\n    MODULE_TYPE_VALIDATOR,\\n    MODULE_TYPE_EXECUTOR,\\n    MODULE_TYPE_HOOK,\\n    MODULE_TYPE_FALLBACK\\n} from \\\"erc7579/interfaces/IERC7579Module.sol\\\";\\n\\nimport {\\n    ModeLib as ERC7579ModeLib,\\n    ModeCode,\\n    CallType,\\n    ExecType,\\n    ModePayload,\\n    CALLTYPE_SINGLE,\\n    CALLTYPE_BATCH,\\n    CALLTYPE_DELEGATECALL,\\n    EXECTYPE_DEFAULT,\\n    MODE_DEFAULT,\\n    CALLTYPE_STATIC\\n} from \\\"erc7579/lib/ModeLib.sol\\\";\\nimport { Execution, ExecutionLib as ERC7579ExecutionLib } from \\\"erc7579/lib/ExecutionLib.sol\\\";\\n\\nimport {\\n    Bootstrap as ERC7579Bootstrap,\\n    BootstrapConfig as ERC7579BootstrapConfig\\n} from \\\"erc7579/utils/Bootstrap.sol\\\";\\n/* solhint-enable no-unused-import */\\n\",\"keccak256\":\"0x485f6b18d331a6a77ea7ae61d4a100e2bd4c3575e1acc46b83c9a512a7135f00\",\"license\":\"MIT\"},\"modulekit/integrations/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { IERC20 } from \\\"forge-std/interfaces/IERC20.sol\\\";\\nimport { Execution } from \\\"../Accounts.sol\\\";\\nimport { ERC7579Exec } from \\\"./ERC7579Exec.sol\\\";\\n\\nlibrary ERC20Integration {\\n    using ERC7579Exec for address;\\n\\n    error SafeERC20TransferFailed();\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 amount\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec0, Execution memory exec1)\\n    {\\n        exec0 = Execution({\\n            target: address(token),\\n            value: 0,\\n            callData: abi.encodeCall(IERC20.approve, (spender, 0))\\n        });\\n        exec1 = Execution({\\n            target: address(token),\\n            value: 0,\\n            callData: abi.encodeCall(IERC20.approve, (spender, amount))\\n        });\\n    }\\n\\n    function approve(\\n        IERC20 token,\\n        address spender,\\n        uint256 amount\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(token),\\n            value: 0,\\n            callData: abi.encodeCall(IERC20.approve, (spender, amount))\\n        });\\n    }\\n\\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\\n        safeTransfer(token, msg.sender, to, amount);\\n    }\\n\\n    function safeTransfer(IERC20 token, address account, address to, uint256 amount) internal {\\n        bytes memory ret = account.exec7579({\\n            to: address(token),\\n            value: 0,\\n            data: abi.encodeCall(IERC20.transfer, (to, amount))\\n        });\\n        if (ret.length != 0) {\\n            bool success = abi.decode(ret, (bool));\\n            if (!success) revert SafeERC20TransferFailed();\\n        }\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\\n        safeTransferFrom(token, msg.sender, from, to, amount);\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address account,\\n        address from,\\n        address to,\\n        uint256 amount\\n    )\\n        internal\\n    {\\n        bytes memory ret = account.exec7579({\\n            to: address(token),\\n            value: 0,\\n            data: abi.encodeCall(IERC20.transferFrom, (from, to, amount))\\n        });\\n\\n        bytes[] memory retValues = abi.decode(ret, (bytes[]));\\n        if (retValues[0].length != 0) {\\n            bool success = abi.decode(retValues[0], (bool));\\n            if (!success) revert SafeERC20TransferFailed();\\n        }\\n    }\\n\\n    function transfer(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(token),\\n            value: 0,\\n            callData: abi.encodeCall(IERC20.transfer, (to, amount))\\n        });\\n    }\\n\\n    function transferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(token),\\n            value: 0,\\n            callData: abi.encodeCall(IERC20.transferFrom, (from, to, amount))\\n        });\\n    }\\n}\\n\",\"keccak256\":\"0x9d7b52e2e6ec3a1a3490c33da159d6c8a3da811f74934dbc78373bebd8303279\",\"license\":\"MIT\"},\"modulekit/integrations/ERC4626.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { IERC4626 } from \\\"forge-std/interfaces/IERC4626.sol\\\";\\nimport { Execution } from \\\"../Accounts.sol\\\";\\n\\nlibrary ERC4626Integration {\\n    function deposit(\\n        IERC4626 vault,\\n        uint256 assets,\\n        address receiver\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(vault),\\n            value: 0,\\n            callData: abi.encodeCall(IERC4626.deposit, (assets, receiver))\\n        });\\n    }\\n\\n    function mint(\\n        IERC4626 vault,\\n        uint256 shares,\\n        address receiver\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(vault),\\n            value: 0,\\n            callData: abi.encodeCall(IERC4626.mint, (shares, receiver))\\n        });\\n    }\\n\\n    function withdraw(\\n        IERC4626 vault,\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(vault),\\n            value: 0,\\n            callData: abi.encodeCall(IERC4626.withdraw, (assets, receiver, owner))\\n        });\\n    }\\n\\n    function redeem(\\n        IERC4626 vault,\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(vault),\\n            value: 0,\\n            callData: abi.encodeCall(IERC4626.redeem, (shares, receiver, owner))\\n        });\\n    }\\n}\\n\",\"keccak256\":\"0xb6abc217507eb5400a9a3442a6dfc590f17828484409c011736165ddefff9d11\",\"license\":\"MIT\"},\"modulekit/integrations/ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { IERC721 } from \\\"forge-std/interfaces/IERC721.sol\\\";\\nimport { Execution } from \\\"../Accounts.sol\\\";\\n\\nlibrary ERC721Integration {\\n    function approve(\\n        IERC721 token,\\n        address spender,\\n        uint256 tokenId\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(token),\\n            value: 0,\\n            callData: abi.encodeCall(IERC721.approve, (spender, tokenId))\\n        });\\n    }\\n\\n    function transferFrom(\\n        IERC721 token,\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(token),\\n            value: 0,\\n            callData: abi.encodeCall(IERC721.transferFrom, (from, to, tokenId))\\n        });\\n    }\\n}\\n\",\"keccak256\":\"0x8df645b376135530e56438175589ed57396a9f4495c2360685ead1cf5da39b76\",\"license\":\"MIT\"},\"modulekit/integrations/ERC7579Exec.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.25;\\n\\nimport \\\"../external/ERC7579.sol\\\";\\n\\nlibrary ERC7579Exec {\\n    function exec7579(\\n        address account,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    )\\n        internal\\n        returns (bytes memory result)\\n    {\\n        ModeCode modeCode = ERC7579ModeLib.encode({\\n            callType: CALLTYPE_SINGLE,\\n            execType: EXECTYPE_DEFAULT,\\n            mode: MODE_DEFAULT,\\n            payload: ModePayload.wrap(bytes22(0))\\n        });\\n\\n        return IERC7579Account(account).executeFromExecutor(\\n            modeCode, ERC7579ExecutionLib.encodeSingle(to, value, data)\\n        )[0];\\n    }\\n\\n    function exec7579(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    )\\n        internal\\n        returns (bytes memory result)\\n    {\\n        return exec7579(msg.sender, to, value, data);\\n    }\\n\\n    function exec7579(\\n        address account,\\n        Execution[] memory execs\\n    )\\n        internal\\n        returns (bytes[] memory results)\\n    {\\n        ModeCode modeCode = ERC7579ModeLib.encode({\\n            callType: CALLTYPE_BATCH,\\n            execType: EXECTYPE_DEFAULT,\\n            mode: MODE_DEFAULT,\\n            payload: ModePayload.wrap(bytes22(0))\\n        });\\n        results = IERC7579Account(account).executeFromExecutor(\\n            modeCode, ERC7579ExecutionLib.encodeBatch(execs)\\n        );\\n    }\\n\\n    function exec7579(Execution[] memory execs) internal returns (bytes[] memory results) {\\n        return exec7579(msg.sender, execs);\\n    }\\n\\n    // Note: Not every account will support delegatecalls\\n    function exec7579(\\n        address account,\\n        address delegateTarget,\\n        bytes memory callData\\n    )\\n        internal\\n        returns (bytes[] memory results)\\n    {\\n        ModeCode modeCode = ERC7579ModeLib.encode({\\n            callType: CALLTYPE_DELEGATECALL,\\n            execType: EXECTYPE_DEFAULT,\\n            mode: MODE_DEFAULT,\\n            payload: ModePayload.wrap(bytes22(0))\\n        });\\n        results = IERC7579Account(account).executeFromExecutor(\\n            modeCode, abi.encodePacked(delegateTarget, callData)\\n        );\\n    }\\n\\n    // Note: Not every account will support delegatecalls\\n    function exec7579(\\n        address delegateTarget,\\n        bytes memory callData\\n    )\\n        internal\\n        returns (bytes[] memory results)\\n    {\\n        return exec7579(msg.sender, delegateTarget, callData);\\n    }\\n}\\n\",\"keccak256\":\"0x4105e4d8e78e8ed28c92d70dcb551ae68a5763822e9a990164a2adc4f4d23143\",\"license\":\"AGPL-3.0-only\"},\"modulekit/integrations/interfaces/uniswap/v3/ISwapRouter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.4;\\npragma abicoder v2;\\n\\nimport { IUniswapV3SwapCallback } from \\\"./IUniswapV3SwapCallback.sol\\\";\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter is IUniswapV3SwapCallback {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in\\n    /// calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(\\n        ExactInputSingleParams calldata params\\n    )\\n        external\\n        payable\\n        returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified\\n    /// path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams`\\n    /// in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(\\n        ExactInputParams calldata params\\n    )\\n        external\\n        payable\\n        returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in\\n    /// calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(\\n        ExactOutputSingleParams calldata params\\n    )\\n        external\\n        payable\\n        returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the\\n    /// specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as\\n    /// `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(\\n        ExactOutputParams calldata params\\n    )\\n        external\\n        payable\\n        returns (uint256 amountIn);\\n}\\n\",\"keccak256\":\"0x69e1bac2845466d8117eb5855c84ee730c571c3a93d3066fb5c22755f50b6d5c\",\"license\":\"GPL-2.0-or-later\"},\"modulekit/integrations/interfaces/uniswap/v3/IUniswapV3Factory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\nabstract contract IUniswapV3Factory {\\n    function getPool(\\n        address token0,\\n        address token1,\\n        uint24 fee\\n    )\\n        external\\n        view\\n        virtual\\n        returns (address poolAddress);\\n}\\n\",\"keccak256\":\"0x4d305c2ff3c3350153da53f01e95d091648f561db67322b1af5e1eb418d03906\",\"license\":\"MIT\"},\"modulekit/integrations/interfaces/uniswap/v3/IUniswapV3Pool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\nabstract contract IUniswapV3Pool {\\n    struct Slot0 {\\n        // the current price\\n        uint160 sqrtPriceX96;\\n        // the current tick\\n        int24 tick;\\n        // the most-recently updated index of the observations array\\n        uint16 observationIndex;\\n        // the current maximum number of observations that are being stored\\n        uint16 observationCardinality;\\n        // the next maximum number of observations to store, triggered in observations.write\\n        uint16 observationCardinalityNext;\\n        // the current protocol fee as a percentage of the swap fee taken on withdrawal\\n        // represented as an integer denominator (1/x)%\\n        uint8 feeProtocol;\\n        // whether the pool is locked\\n        bool unlocked;\\n    }\\n\\n    function slot0() external view virtual returns (Slot0 memory);\\n\\n    function fee() external view virtual returns (uint24 fee);\\n\\n    function flash(\\n        address recipient,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes memory data\\n    )\\n        external\\n        virtual;\\n\\n    function token0() external view virtual returns (address);\\n    function token1() external view virtual returns (address);\\n}\\n\",\"keccak256\":\"0xe3bb1a1c66f5362d892b9dc81ac9560a951873116856268a25f6bf98609fbe9a\",\"license\":\"MIT\"},\"modulekit/integrations/interfaces/uniswap/v3/IUniswapV3SwapCallback.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical\\n    /// UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received\\n    /// (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received\\n    /// (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    )\\n        external;\\n}\\n\",\"keccak256\":\"0x923496e539a4b65b83344d901ad1402c5fe29258646ecfdd5e145d95bac3ee4b\",\"license\":\"GPL-2.0-or-later\"},\"modulekit/integrations/uniswap/helpers/MainnetAddresses.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\naddress payable constant SWAPROUTER_ADDRESS = payable(0xE592427A0AEce92De3Edee1F18E0157C05861564);\\nuint24 constant SWAPROUTER_DEFAULTFEE = 3000;\\naddress constant QUOTER_ADDRESS = 0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6;\\naddress constant FACTORY_ADDRESS = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\\n\",\"keccak256\":\"0xb116979986a1694219a669ed3b2dcd8802387d7f83ed3882b67190bfd8f74844\",\"license\":\"MIT\"},\"modulekit/integrations/uniswap/v3/Uniswap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport {\\n    SWAPROUTER_ADDRESS,\\n    SWAPROUTER_DEFAULTFEE,\\n    FACTORY_ADDRESS\\n} from \\\"../helpers/MainnetAddresses.sol\\\";\\nimport { ISwapRouter } from \\\"../../interfaces/uniswap/v3/ISwapRouter.sol\\\";\\nimport { IUniswapV3Factory } from \\\"../../interfaces/uniswap/v3/IUniswapV3Factory.sol\\\";\\nimport { IUniswapV3Pool } from \\\"../../interfaces/uniswap/v3/IUniswapV3Pool.sol\\\";\\nimport { IERC20 } from \\\"forge-std/interfaces/IERC20.sol\\\";\\nimport { ERC20Integration } from \\\"../../ERC20.sol\\\";\\nimport { Execution } from \\\"../../../Accounts.sol\\\";\\n\\n/// @author zeroknots\\nlibrary UniswapV3Integration {\\n    using ERC20Integration for IERC20;\\n\\n    error PoolDoesNotExist();\\n\\n    function approveAndSwap(\\n        address smartAccount,\\n        IERC20 tokenIn,\\n        IERC20 tokenOut,\\n        uint256 amountIn,\\n        uint160 sqrtPriceLimitX96\\n    )\\n        internal\\n        view\\n        returns (Execution[] memory exec)\\n    {\\n        exec = new Execution[](3);\\n        (exec[0], exec[1]) = ERC20Integration.safeApprove(tokenIn, SWAPROUTER_ADDRESS, amountIn);\\n        exec[2] = swapExactInputSingle(smartAccount, tokenIn, tokenOut, amountIn, sqrtPriceLimitX96);\\n    }\\n\\n    function swapExactInputSingle(\\n        address smartAccount,\\n        IERC20 tokenIn,\\n        IERC20 tokenOut,\\n        uint256 amountIn,\\n        uint160 sqrtPriceLimitX96\\n    )\\n        internal\\n        view\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: SWAPROUTER_ADDRESS,\\n            value: 0,\\n            callData: abi.encodeCall(\\n                ISwapRouter.exactInputSingle,\\n                (\\n                    ISwapRouter.ExactInputSingleParams({\\n                        tokenIn: address(tokenIn),\\n                        tokenOut: address(tokenOut),\\n                        fee: SWAPROUTER_DEFAULTFEE,\\n                        recipient: smartAccount,\\n                        deadline: block.timestamp,\\n                        amountIn: amountIn,\\n                        amountOutMinimum: 0,\\n                        sqrtPriceLimitX96: sqrtPriceLimitX96\\n                    })\\n                )\\n            )\\n        });\\n    }\\n\\n    function swapExactOutputSingle(\\n        address smartAccount,\\n        IERC20 tokenIn,\\n        IERC20 tokenOut,\\n        uint256 amountOut,\\n        uint256 amountInMaximum\\n    )\\n        internal\\n        view\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: SWAPROUTER_ADDRESS,\\n            value: 0,\\n            callData: abi.encodeCall(\\n                ISwapRouter.exactOutputSingle,\\n                (\\n                    ISwapRouter.ExactOutputSingleParams({\\n                        tokenIn: address(tokenIn),\\n                        tokenOut: address(tokenOut),\\n                        fee: SWAPROUTER_DEFAULTFEE,\\n                        recipient: smartAccount,\\n                        deadline: block.timestamp,\\n                        amountOut: amountOut,\\n                        amountInMaximum: amountInMaximum,\\n                        sqrtPriceLimitX96: 0\\n                    })\\n                )\\n            )\\n        });\\n    }\\n\\n    function getPoolAddress(\\n        address token0,\\n        address token1\\n    )\\n        public\\n        view\\n        returns (address poolAddress)\\n    {\\n        IUniswapV3Factory factory = IUniswapV3Factory(FACTORY_ADDRESS);\\n        address poolAddress = factory.getPool(token0, token1, SWAPROUTER_DEFAULTFEE);\\n        if (poolAddress == address(0)) {\\n            revert PoolDoesNotExist();\\n        }\\n        return poolAddress;\\n    }\\n\\n    function getSqrtPriceX96(address poolAddress) public view returns (uint160 sqrtPriceX96) {\\n        IUniswapV3Pool pool = IUniswapV3Pool(poolAddress);\\n        IUniswapV3Pool.Slot0 memory slot0 = pool.slot0();\\n        uint160 sqrtPriceX96 = slot0.sqrtPriceX96;\\n        return sqrtPriceX96;\\n    }\\n\\n    function sqrtPriceX96toPriceRatio(\\n        uint160 sqrtPriceX96\\n    )\\n        internal\\n        pure\\n        returns (uint256 priceRatio)\\n    {\\n        uint256 decodedSqrtPrice = sqrtPriceX96 / (2 ** 96);\\n        uint256 priceRatio = decodedSqrtPrice * decodedSqrtPrice;\\n        return priceRatio;\\n    }\\n\\n    function priceRatioToPrice(\\n        uint256 priceRatio,\\n        address poolAddress,\\n        address tokenSwappedFrom\\n    )\\n        internal\\n        view\\n        returns (uint256 price)\\n    {\\n        IUniswapV3Pool pool = IUniswapV3Pool(poolAddress);\\n        address poolToken0 = pool.token0();\\n        address poolToken1 = pool.token1();\\n        uint256 token0Decimals = IERC20(poolToken0).decimals();\\n        uint256 token1Decimals = IERC20(poolToken1).decimals();\\n\\n        bool swapToken0to1 = (tokenSwappedFrom == poolToken0);\\n        if (swapToken0to1) {\\n            price = 10 ** token1Decimals / priceRatio;\\n        } else {\\n            price = priceRatio * 10 ** token0Decimals;\\n        }\\n        return price;\\n    }\\n\\n    function priceRatioToSqrtPriceX96(uint256 priceRatio) internal pure returns (uint160) {\\n        uint256 sqrtPriceRatio = sqrt256(priceRatio * 1e18); // Scale priceRatio to 18 decimals for\\n            // precision\\n\\n        uint256 sqrtPriceX96 = (sqrtPriceRatio * 2 ** 96) / 1e9; // Adjust back from the scaling\\n\\n        return uint160(sqrtPriceX96);\\n    }\\n\\n    function checkTokenOrder(\\n        address tokenSwappedFrom,\\n        address poolAddress\\n    )\\n        internal\\n        view\\n        returns (bool swapToken0to1)\\n    {\\n        address poolToken0 = IUniswapV3Pool(poolAddress).token0();\\n        bool swapToken0to1 = (tokenSwappedFrom == poolToken0);\\n        return swapToken0to1;\\n    }\\n\\n    function sqrt256(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x00674841391db093b9af74bee6660a7ae603bc254b6b3706071b38bbbc5361c2\",\"license\":\"MIT\"},\"sentinellist/SentinelList.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\naddress constant SENTINEL = address(0x1);\\naddress constant ZERO_ADDRESS = address(0x0);\\n\\nlibrary SentinelListLib {\\n    struct SentinelList {\\n        mapping(address => address) entries;\\n    }\\n\\n    error LinkedList_AlreadyInitialized();\\n    error LinkedList_InvalidPage();\\n    error LinkedList_InvalidEntry(address entry);\\n    error LinkedList_EntryAlreadyInList(address entry);\\n\\n    function init(SentinelList storage self) internal {\\n        if (alreadyInitialized(self)) revert LinkedList_AlreadyInitialized();\\n        self.entries[SENTINEL] = SENTINEL;\\n    }\\n\\n    function alreadyInitialized(SentinelList storage self) internal view returns (bool) {\\n        return self.entries[SENTINEL] != ZERO_ADDRESS;\\n    }\\n\\n    function getNext(SentinelList storage self, address entry) internal view returns (address) {\\n        if (entry == ZERO_ADDRESS) {\\n            revert LinkedList_InvalidEntry(entry);\\n        }\\n        return self.entries[entry];\\n    }\\n\\n    function push(SentinelList storage self, address newEntry) internal {\\n        if (newEntry == ZERO_ADDRESS || newEntry == SENTINEL) {\\n            revert LinkedList_InvalidEntry(newEntry);\\n        }\\n        if (self.entries[newEntry] != ZERO_ADDRESS) revert LinkedList_EntryAlreadyInList(newEntry);\\n        self.entries[newEntry] = self.entries[SENTINEL];\\n        self.entries[SENTINEL] = newEntry;\\n    }\\n\\n    function pop(SentinelList storage self, address prevEntry, address popEntry) internal {\\n        if (popEntry == ZERO_ADDRESS || popEntry == SENTINEL) {\\n            revert LinkedList_InvalidEntry(prevEntry);\\n        }\\n        if (self.entries[prevEntry] != popEntry) revert LinkedList_InvalidEntry(popEntry);\\n        self.entries[prevEntry] = self.entries[popEntry];\\n        self.entries[popEntry] = ZERO_ADDRESS;\\n    }\\n\\n    function popAll(SentinelList storage self) internal {\\n        address next = self.entries[SENTINEL];\\n        while (next != ZERO_ADDRESS) {\\n            address current = next;\\n            next = self.entries[next];\\n            self.entries[current] = ZERO_ADDRESS;\\n        }\\n        self.entries[SENTINEL] = ZERO_ADDRESS;\\n    }\\n\\n    function contains(SentinelList storage self, address entry) internal view returns (bool) {\\n        return SENTINEL != entry && self.entries[entry] != ZERO_ADDRESS;\\n    }\\n\\n    function getEntriesPaginated(\\n        SentinelList storage self,\\n        address start,\\n        uint256 pageSize\\n    )\\n        internal\\n        view\\n        returns (address[] memory array, address next)\\n    {\\n        if (start != SENTINEL && !contains(self, start)) revert LinkedList_InvalidEntry(start);\\n        if (pageSize == 0) revert LinkedList_InvalidPage();\\n        // Init array with max page size\\n        array = new address[](pageSize);\\n\\n        // Populate return array\\n        uint256 entryCount = 0;\\n        next = self.entries[start];\\n        while (next != ZERO_ADDRESS && next != SENTINEL && entryCount < pageSize) {\\n            array[entryCount] = next;\\n            next = self.entries[next];\\n            entryCount++;\\n        }\\n\\n        /**\\n         * Because of the argument validation, we can assume that the loop will always iterate over\\n         * the valid entry list values\\n         *       and the `next` variable will either be an enabled entry or a sentinel address\\n         * (signalling the end).\\n         *\\n         *       If we haven't reached the end inside the loop, we need to set the next pointer to\\n         * the last element of the entry array\\n         *       because the `next` variable (which is a entry by itself) acting as a pointer to the\\n         * start of the next page is neither\\n         *       incSENTINELrent page, nor will it be included in the next one if you pass it as a\\n         * start.\\n         */\\n        if (next != SENTINEL && entryCount > 0) {\\n            next = array[entryCount - 1];\\n        }\\n        // Set correct size of returned array\\n        // solhint-disable-next-line no-inline-assembly\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(array, entryCount)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0fdb07d60acf6c8272517b2cf9a7ce36cef7dabd3acfc61e7424662818044da2\",\"license\":\"MIT\"},\"solady/utils/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Gas optimized ECDSA wrapper.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\\n///\\n/// @dev Note:\\n/// - The recovery functions use the ecrecover precompile (0x1).\\n/// - As of Solady version 0.0.68, the `recover` variants will revert upon recovery failure.\\n///   This is for more safety by default.\\n///   Use the `tryRecover` variants if you need to get the zero address back\\n///   upon recovery failure instead.\\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\\n///   See: https://eips.ethereum.org/EIPS/eip-2098\\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\\n///\\n/// WARNING! Do NOT use signatures as unique identifiers:\\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\\n///   EIP-712 also enables readable signing of typed data for better user safety.\\n/// This implementation does NOT check if a signature is non-malleable.\\nlibrary ECDSA {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The signature is invalid.\\n    error InvalidSignature();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                    RECOVERY OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\n    function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            for {} 1 {} {\\n                mstore(0x00, hash)\\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n                if eq(mload(signature), 64) {\\n                    let vs := mload(add(signature, 0x40))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    break\\n                }\\n                if eq(mload(signature), 65) {\\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\\n                    break\\n                }\\n                result := 0\\n                break\\n            }\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        result, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\n    function recoverCalldata(bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            for {} 1 {} {\\n                if eq(signature.length, 64) {\\n                    let vs := calldataload(add(signature.offset, 0x20))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    break\\n                }\\n                if eq(signature.length, 65) {\\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\\n                    break\\n                }\\n                result := 0\\n                break\\n            }\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        result, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n            mstore(0x40, r)\\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the signature defined by `v`, `r`, `s`.\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, and(v, 0xff))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   TRY-RECOVER OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // WARNING!\\n    // These functions will NOT revert upon recovery failure.\\n    // Instead, they will return the zero address upon recovery failure.\\n    // It is critical that the returned address is NEVER compared against\\n    // a zero address (e.g. an uninitialized address variable).\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\n    function tryRecover(bytes32 hash, bytes memory signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            for {} 1 {} {\\n                mstore(0x00, hash)\\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n                if eq(mload(signature), 64) {\\n                    let vs := mload(add(signature, 0x40))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    break\\n                }\\n                if eq(mload(signature), 65) {\\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\\n                    break\\n                }\\n                result := 0\\n                break\\n            }\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    result, // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\n    function tryRecoverCalldata(bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            for {} 1 {} {\\n                if eq(signature.length, 64) {\\n                    let vs := calldataload(add(signature.offset, 0x20))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    break\\n                }\\n                if eq(signature.length, 65) {\\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\\n                    break\\n                }\\n                result := 0\\n                break\\n            }\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    result, // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n            mstore(0x40, r)\\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    1, // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the signature defined by `v`, `r`, `s`.\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, and(v, 0xff))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    1, // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     HASHING OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, hash) // Store into scratch space for keccak256.\\n            mstore(0x00, \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n32\\\") // 28 bytes.\\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\\n        }\\n    }\\n\\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    /// Note: Supports lengths of `s` up to 999999 bytes.\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let sLength := mload(s)\\n            let o := 0x20\\n            mstore(o, \\\"\\\\x19Ethereum Signed Message:\\\\n\\\") // 26 bytes, zero-right-padded.\\n            mstore(0x00, 0x00)\\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\\n            for { let temp := sLength } 1 {} {\\n                o := sub(o, 1)\\n                mstore8(o, add(48, mod(temp, 10)))\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\\n            mstore(s, sLength) // Restore the length.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   EMPTY CALLDATA HELPERS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns an empty calldata bytes.\\n    function emptySignature() internal pure returns (bytes calldata signature) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            signature.length := 0\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x317f8208d1f03356e8f709eec8e2c579d6be227099a26f777cc9ec8a06814ae4\",\"license\":\"MIT\"},\"solady/utils/LibClone.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Minimal proxy library.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\\n/// @author Minimal proxy by 0age (https://github.com/0age)\\n/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie\\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\\n/// @author Minimal ERC1967 proxy by jtriley-eth (https://github.com/jtriley-eth/minimum-viable-proxy)\\n///\\n/// @dev Minimal proxy:\\n/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,\\n/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,\\n/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.\\n///\\n/// @dev Minimal proxy (PUSH0 variant):\\n/// This is a new minimal proxy that uses the PUSH0 opcode introduced during Shanghai.\\n/// It is optimized first for minimal runtime gas, then for minimal bytecode.\\n/// The PUSH0 clone functions are intentionally postfixed with a jarring \\\"_PUSH0\\\" as\\n/// many EVM chains may not support the PUSH0 opcode in the early months after Shanghai.\\n/// Please use with caution.\\n///\\n/// @dev Clones with immutable args (CWIA):\\n/// The implementation of CWIA here implements a `receive()` method that emits the\\n/// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,\\n/// enabling us to accept hard gas-capped `sends` & `transfers` for maximum backwards\\n/// composability. The minimal proxy implementation does not offer this feature.\\n///\\n/// @dev Minimal ERC1967 proxy:\\n/// An minimal ERC1967 proxy, intended to be upgraded with UUPS.\\n/// This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\\n/// This proxy is automatically verified on Etherscan.\\n///\\n/// @dev ERC1967I proxy:\\n/// An variant of the minimal ERC1967 proxy, with a special code path that activates\\n/// if `calldatasize() == 1`. This code path skips the delegatecall and directly returns the\\n/// `implementation` address. The returned implementation is guaranteed to be valid if the\\n/// keccak256 of the proxy's code is equal to `ERC1967I_CODE_HASH`.\\nlibrary LibClone {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The keccak256 of the deployed code for the ERC1967 proxy.\\n    bytes32 internal constant ERC1967_CODE_HASH =\\n        0xaaa52c8cc8a0e3fd27ce756cc6b4e70c51423e9b597b11f32d3e49f8b1fc890d;\\n\\n    /// @dev The keccak256 of the deployed code for the ERC1967I proxy.\\n    bytes32 internal constant ERC1967I_CODE_HASH =\\n        0xce700223c0d4cea4583409accfc45adac4a093b3519998a9cbbe1504dadba6f7;\\n\\n    /// @dev The keccak256 of the deployed code for the ERC1967 beacon proxy.\\n    bytes32 internal constant ERC1967_BEACON_PROXY_CODE_HASH =\\n        0x14044459af17bc4f0f5aa2f658cb692add77d1302c29fe2aebab005eea9d1162;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Unable to deploy the clone.\\n    error DeploymentFailed();\\n\\n    /// @dev The salt must start with either the zero address or `by`.\\n    error SaltDoesNotStartWith();\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                  MINIMAL PROXY OPERATIONS                  */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Deploys a clone of `implementation`.\\n    function clone(address implementation) internal returns (address instance) {\\n        instance = clone(0, implementation);\\n    }\\n\\n    /// @dev Deploys a clone of `implementation`.\\n    /// Deposits `value` ETH during deployment.\\n    function clone(uint256 value, address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * --------------------------------------------------------------------------+\\n             * CREATION (9 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\\n             * --------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize     | r         |                              |\\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\\n             * 81         | DUP2              | r 0 r     |                              |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\\n             * --------------------------------------------------------------------------|\\n             * RUNTIME (44 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\\n             * --------------------------------------------------------------------------|\\n             *                                                                           |\\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | 0                      |                       |\\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\\n             *                                                                           |\\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\\n             *                                                                           |\\n             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * fd      | REVERT         |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\\n             * f3      | RETURN         |                        | [0..rds): returndata  |\\n             * --------------------------------------------------------------------------+\\n             */\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            instance := create(value, 0x0c, 0x35)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\\n    function cloneDeterministic(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = cloneDeterministic(0, implementation, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    function cloneDeterministic(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            instance := create2(value, 0x0c, 0x35, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code of the clone of `implementation`.\\n    function initCode(address implementation) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(add(result, 0x40), 0x5af43d3d93803e602a57fd5bf30000000000000000000000)\\n            mstore(add(result, 0x28), implementation)\\n            mstore(add(result, 0x14), 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            mstore(result, 0x35) // Store the length.\\n            mstore(0x40, add(result, 0x60)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            hash := keccak256(0x0c, 0x35)\\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic clone of `implementation`,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)\\n        internal\\n        pure\\n        returns (address predicted)\\n    {\\n        bytes32 hash = initCodeHash(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*          MINIMAL PROXY OPERATIONS (PUSH0 VARIANT)          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Deploys a PUSH0 clone of `implementation`.\\n    function clone_PUSH0(address implementation) internal returns (address instance) {\\n        instance = clone_PUSH0(0, implementation);\\n    }\\n\\n    /// @dev Deploys a PUSH0 clone of `implementation`.\\n    /// Deposits `value` ETH during deployment.\\n    function clone_PUSH0(uint256 value, address implementation)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * --------------------------------------------------------------------------+\\n             * CREATION (9 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\\n             * --------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize     | r         |                              |\\n             * 5f         | PUSH0             | 0 r       |                              |\\n             * 81         | DUP2              | r 0 r     |                              |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\\n             * 5f         | PUSH0             | 0 o r 0 r |                              |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\\n             * --------------------------------------------------------------------------|\\n             * RUNTIME (45 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\\n             * --------------------------------------------------------------------------|\\n             *                                                                           |\\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5f      | PUSH0          | 0                      |                       |\\n             * 5f      | PUSH0          | 0 0                    |                       |\\n             *                                                                           |\\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0                |                       |\\n             * 5f      | PUSH0          | 0 cds 0 0              |                       |\\n             * 5f      | PUSH0          | 0 0 cds 0 0            |                       |\\n             * 37      | CALLDATACOPY   | 0 0                    | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0                | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 cds 0 0              | [0..cds): calldata    |\\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0         | [0..cds): calldata    |\\n             * 5a      | GAS            | gas addr 0 cds 0 0     | [0..cds): calldata    |\\n             * f4      | DELEGATECALL   | success                | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds success            | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 rds success          | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 0 rds success        | [0..cds): calldata    |\\n             * 3e      | RETURNDATACOPY | success                | [0..rds): returndata  |\\n             *                                                                           |\\n             * 60 0x29 | PUSH1 0x29     | 0x29 success           | [0..rds): returndata  |\\n             * 57      | JUMPI          |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\\n             * fd      | REVERT         |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b      | JUMPDEST       |                        | [0..rds): returndata  |\\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\\n             * f3      | RETURN         |                        | [0..rds): returndata  |\\n             * --------------------------------------------------------------------------+\\n             */\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            instance := create(value, 0x0e, 0x36)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\\n    function cloneDeterministic_PUSH0(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = cloneDeterministic_PUSH0(0, implementation, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    function cloneDeterministic_PUSH0(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            instance := create2(value, 0x0e, 0x36, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code of the PUSH0 clone of `implementation`.\\n    function initCode_PUSH0(address implementation) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(add(result, 0x40), 0x5af43d5f5f3e6029573d5ffd5b3d5ff300000000000000000000) // 16\\n            mstore(add(result, 0x26), implementation) // 20\\n            mstore(add(result, 0x12), 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            mstore(result, 0x36) // Store the length.\\n            mstore(0x40, add(result, 0x60)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the PUSH0 clone of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash_PUSH0(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            hash := keccak256(0x0e, 0x36)\\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic PUSH0 clone of `implementation`,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress_PUSH0(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHash_PUSH0(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*           CLONES WITH IMMUTABLE ARGS OPERATIONS            */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: This implementation of CWIA differs from the original implementation.\\n    // If the calldata is empty, it will emit a `ReceiveETH(uint256)` event and skip the `DELEGATECALL`.\\n\\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.\\n    function clone(address implementation, bytes memory data) internal returns (address instance) {\\n        instance = clone(0, implementation, data);\\n    }\\n\\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.\\n    /// Deposits `value` ETH during deployment.\\n    function clone(uint256 value, address implementation, bytes memory data)\\n        internal\\n        returns (address instance)\\n    {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n            // The `creationSize` is `extraLength + 108`\\n            // The `runSize` is `creationSize - 10`.\\n\\n            /**\\n             * ---------------------------------------------------------------------------------------------------+\\n             * CREATION (10 bytes)                                                                                |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                                                |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * 61 runSize | PUSH2 runSize     | r         |                                                       |\\n             * 3d         | RETURNDATASIZE    | 0 r       |                                                       |\\n             * 81         | DUP2              | r 0 r     |                                                       |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                                                       |\\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                                                       |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code                            |\\n             * f3         | RETURN            |           | [0..runSize): runtime code                            |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * RUNTIME (98 bytes + extraLength)                                                                   |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * Opcode   | Mnemonic       | Stack                    | Memory                                      |\\n             * ---------------------------------------------------------------------------------------------------|\\n             *                                                                                                    |\\n             * ::: if no calldata, emit event & return w/o `DELEGATECALL` ::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds                      |                                             |\\n             * 60 0x2c  | PUSH1 0x2c     | 0x2c cds                 |                                             |\\n             * 57       | JUMPI          |                          |                                             |\\n             * 34       | CALLVALUE      | cv                       |                                             |\\n             * 3d       | RETURNDATASIZE | 0 cv                     |                                             |\\n             * 52       | MSTORE         |                          | [0..0x20): callvalue                        |\\n             * 7f sig   | PUSH32 0x9e..  | sig                      | [0..0x20): callvalue                        |\\n             * 59       | MSIZE          | 0x20 sig                 | [0..0x20): callvalue                        |\\n             * 3d       | RETURNDATASIZE | 0 0x20 sig               | [0..0x20): callvalue                        |\\n             * a1       | LOG1           |                          | [0..0x20): callvalue                        |\\n             * 00       | STOP           |                          | [0..0x20): callvalue                        |\\n             * 5b       | JUMPDEST       |                          |                                             |\\n             *                                                                                                    |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds                      |                                             |\\n             * 3d       | RETURNDATASIZE | 0 cds                    |                                             |\\n             * 3d       | RETURNDATASIZE | 0 0 cds                  |                                             |\\n             * 37       | CALLDATACOPY   |                          | [0..cds): calldata                          |\\n             *                                                                                                    |\\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d       | RETURNDATASIZE | 0                        | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0                      | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0 0                    | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0 0 0                  | [0..cds): calldata                          |\\n             * 61 extra | PUSH2 extra    | e 0 0 0 0                | [0..cds): calldata                          |\\n             *                                                                                                    |\\n             * ::: copy extra data to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 80       | DUP1           | e e 0 0 0 0              | [0..cds): calldata                          |\\n             * 60 0x62  | PUSH1 0x62     | 0x62 e e 0 0 0 0         | [0..cds): calldata                          |\\n             * 36       | CALLDATASIZE   | cds 0x62 e e 0 0 0 0     | [0..cds): calldata                          |\\n             * 39       | CODECOPY       | e 0 0 0 0                | [0..cds): calldata, [cds..cds+e): extraData |\\n             *                                                                                                    |\\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 01       | ADD            | cds+e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3d       | RETURNDATASIZE | 0 cds+e 0 0 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 73 addr  | PUSH20 addr    | addr 0 cds+e 0 0 0 0     | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 5a       | GAS            | gas addr 0 cds+e 0 0 0 0 | [0..cds): calldata, [cds..cds+e): extraData |\\n             * f4       | DELEGATECALL   | success 0 0              | [0..cds): calldata, [cds..cds+e): extraData |\\n             *                                                                                                    |\\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d       | RETURNDATASIZE | rds success 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3d       | RETURNDATASIZE | rds rds success 0 0      | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 93       | SWAP4          | 0 rds success 0 rds      | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 80       | DUP1           | 0 0 rds success 0 rds    | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3e       | RETURNDATACOPY | success 0 rds            | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * 60 0x60  | PUSH1 0x60     | 0x60 success 0 rds       | [0..rds): returndata                        |\\n             * 57       | JUMPI          | 0 rds                    | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * fd       | REVERT         |                          | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b       | JUMPDEST       | 0 rds                    | [0..rds): returndata                        |\\n             * f3       | RETURN         |                          | [0..rds): returndata                        |\\n             * ---------------------------------------------------------------------------------------------------+\\n             */\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\\n                // The actual EVM limit may be smaller and may change over time.\\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            instance := create(value, sub(data, 0x4c), add(extraLength, 0x6c))\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation`\\n    /// with immutable arguments encoded in `data` and `salt`.\\n    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = cloneDeterministic(0, implementation, data, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation`\\n    /// with immutable arguments encoded in `data` and `salt`.\\n    function cloneDeterministic(\\n        uint256 value,\\n        address implementation,\\n        bytes memory data,\\n        bytes32 salt\\n    ) internal returns (address instance) {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\\n                // The actual EVM limit may be smaller and may change over time.\\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            instance := create2(value, sub(data, 0x4c), add(extraLength, 0x6c), salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`\\n    /// using immutable arguments encoded in `data`.\\n    function initCode(address implementation, bytes memory data)\\n        internal\\n        pure\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let dataLength := mload(data)\\n\\n            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.\\n            // The actual EVM limit may be smaller and may change over time.\\n            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))\\n\\n            let o := add(result, 0x8c)\\n            let end := add(o, dataLength)\\n\\n            // Copy the `data` into `result`.\\n            for { let d := sub(add(data, 0x20), o) } 1 {} {\\n                mstore(o, mload(add(o, d)))\\n                o := add(o, 0x20)\\n                if iszero(lt(o, end)) { break }\\n            }\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            mstore(add(result, 0x6c), 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\\n            mstore(add(result, 0x5f), implementation) // Write the address of the implementation.\\n            // Write the rest of the bytecode.\\n            mstore(\\n                add(result, 0x4b),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                add(result, 0x32),\\n                0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                add(result, 0x12),\\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(end, shl(0xf0, extraLength))\\n            mstore(add(end, 0x02), 0) // Zeroize the slot after the result.\\n            mstore(result, add(extraLength, 0x6c)) // Store the length.\\n            mstore(0x40, add(0x22, end)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`\\n    /// using immutable arguments encoded in `data`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash(address implementation, bytes memory data)\\n        internal\\n        pure\\n        returns (bytes32 hash)\\n    {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.\\n            // The actual EVM limit may be smaller and may change over time.\\n            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                sub(data, 0x5a),\\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic clone of\\n    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes memory data,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHash(implementation, data);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*              MINIMAL ERC1967 PROXY OPERATIONS              */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: The ERC1967 proxy here is intended to be upgraded with UUPS.\\n    // This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\\n\\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\\n    function deployERC1967(address implementation) internal returns (address instance) {\\n        instance = deployERC1967(0, implementation);\\n    }\\n\\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\\n    /// Deposits `value` ETH during deployment.\\n    function deployERC1967(uint256 value, address implementation)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * ---------------------------------------------------------------------------------+\\n             * CREATION (34 bytes)                                                              |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\\n             * 81         | DUP2           | r 0 r            |                                 |\\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\\n             * ---------------------------------------------------------------------------------|\\n             * RUNTIME (61 bytes)                                                               |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             *                                                                                  |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36         | CALLDATASIZE   | cds              |                                 |\\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | 0                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 60 0x38    | PUSH1 0x38     | dest succ        | [0..returndatasize): returndata |\\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\\n             * ---------------------------------------------------------------------------------+\\n             */\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\\n            mstore(0x20, 0x6009)\\n            mstore(0x1e, implementation)\\n            mstore(0x0a, 0x603d3d8160223d3973)\\n            instance := create(value, 0x21, 0x5f)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\\n    function deployDeterministicERC1967(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = deployDeterministicERC1967(0, implementation, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    function deployDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\\n            mstore(0x20, 0x6009)\\n            mstore(0x1e, implementation)\\n            mstore(0x0a, 0x603d3d8160223d3973)\\n            instance := create2(value, 0x21, 0x5f, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967(address implementation, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        return createDeterministicERC1967(0, implementation, salt);\\n    }\\n\\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\\n            mstore(0x20, 0x6009)\\n            mstore(0x1e, implementation)\\n            mstore(0x0a, 0x603d3d8160223d3973)\\n            // Compute and store the bytecode hash.\\n            mstore(add(m, 0x35), keccak256(0x21, 0x5f))\\n            mstore(m, shl(88, address()))\\n            mstore8(m, 0xff) // Write the prefix.\\n            mstore(add(m, 0x15), salt)\\n            instance := keccak256(m, 0x55)\\n            for {} 1 {} {\\n                if iszero(extcodesize(instance)) {\\n                    instance := create2(value, 0x21, 0x5f, salt)\\n                    if iszero(instance) {\\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    break\\n                }\\n                alreadyDeployed := 1\\n                if iszero(value) { break }\\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                break\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation`.\\n    function initCodeERC1967(address implementation) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(\\n                add(result, 0x60),\\n                0x3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f300\\n            )\\n            mstore(\\n                add(result, 0x40),\\n                0x55f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076cc\\n            )\\n            mstore(add(result, 0x20), or(shl(24, implementation), 0x600951))\\n            mstore(add(result, 0x09), 0x603d3d8160223d3973)\\n            mstore(result, 0x5f) // Store the length.\\n            mstore(0x40, add(result, 0x80)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHashERC1967(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\\n            mstore(0x20, 0x6009)\\n            mstore(0x1e, implementation)\\n            mstore(0x0a, 0x603d3d8160223d3973)\\n            hash := keccak256(0x21, 0x5f)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic ERC1967 proxy of `implementation`,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddressERC1967(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHashERC1967(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                 ERC1967I PROXY OPERATIONS                  */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: This proxy has a special code path that activates if `calldatasize() == 1`.\\n    // This code path skips the delegatecall and directly returns the `implementation` address.\\n    // The returned implementation is guaranteed to be valid if the keccak256 of the\\n    // proxy's code is equal to `ERC1967I_CODE_HASH`.\\n\\n    /// @dev Deploys a minimal ERC1967I proxy with `implementation`.\\n    function deployERC1967I(address implementation) internal returns (address instance) {\\n        instance = deployERC1967I(0, implementation);\\n    }\\n\\n    /// @dev Deploys a ERC1967I proxy with `implementation`.\\n    /// Deposits `value` ETH during deployment.\\n    function deployERC1967I(uint256 value, address implementation)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * ---------------------------------------------------------------------------------+\\n             * CREATION (34 bytes)                                                              |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\\n             * 81         | DUP2           | r 0 r            |                                 |\\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\\n             * ---------------------------------------------------------------------------------|\\n             * RUNTIME (82 bytes)                                                               |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             *                                                                                  |\\n             * ::: check calldatasize ::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36         | CALLDATASIZE   | cds              |                                 |\\n             * 58         | PC             | 1 cds            |                                 |\\n             * 14         | EQ             | eqs              |                                 |\\n             * 60 0x43    | PUSH1 0x43     | dest eqs         |                                 |\\n             * 57         | JUMPI          |                  |                                 |\\n             *                                                                                  |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36         | CALLDATASIZE   | cds              |                                 |\\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | 0                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 60 0x3E    | PUSH1 0x3E     | dest succ        | [0..returndatasize): returndata |\\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: implementation , return :::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b         | JUMPDEST       |                  |                                 |\\n             * 60 0x20    | PUSH1 0x20     | 32               |                                 |\\n             * 60 0x0F    | PUSH1 0x0F     | o 32             |                                 |\\n             * 3d         | RETURNDATASIZE | 0 o 32           |                                 |\\n             * 39         | CODECOPY       |                  | [0..32): implementation slot    |\\n             * 3d         | RETURNDATASIZE | 0                | [0..32): implementation slot    |\\n             * 51         | MLOAD          | slot             | [0..32): implementation slot    |\\n             * 54         | SLOAD          | impl             | [0..32): implementation slot    |\\n             * 3d         | RETURNDATASIZE | 0 impl           | [0..32): implementation slot    |\\n             * 52         | MSTORE         |                  | [0..32): implementation address |\\n             * 59         | MSIZE          | 32               | [0..32): implementation address |\\n             * 3d         | RETURNDATASIZE | 0 32             | [0..32): implementation address |\\n             * f3         | RETURN         |                  | [0..32): implementation address |\\n             * ---------------------------------------------------------------------------------+\\n             */\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\\n            instance := create(value, 0x0c, 0x74)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.\\n    function deployDeterministicERC1967I(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = deployDeterministicERC1967I(0, implementation, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    function deployDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\\n            instance := create2(value, 0x0c, 0x74, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967I(address implementation, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        return createDeterministicERC1967I(0, implementation, salt);\\n    }\\n\\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\\n            // Compute and store the bytecode hash.\\n            mstore(add(m, 0x35), keccak256(0x0c, 0x74))\\n            mstore(m, shl(88, address()))\\n            mstore8(m, 0xff) // Write the prefix.\\n            mstore(add(m, 0x15), salt)\\n            instance := keccak256(m, 0x55)\\n            for {} 1 {} {\\n                if iszero(extcodesize(instance)) {\\n                    instance := create2(value, 0x0c, 0x74, salt)\\n                    if iszero(instance) {\\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    break\\n                }\\n                alreadyDeployed := 1\\n                if iszero(value) { break }\\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                break\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation`.\\n    function initCodeERC1967I(address implementation) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(\\n                add(result, 0x74),\\n                0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3\\n            )\\n            mstore(\\n                add(result, 0x54),\\n                0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4\\n            )\\n            mstore(add(result, 0x34), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\\n            mstore(add(result, 0x1d), implementation)\\n            mstore(add(result, 0x09), 0x60523d8160223d3973)\\n            mstore(add(result, 0x94), 0)\\n            mstore(result, 0x74) // Store the length.\\n            mstore(0x40, add(result, 0xa0)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHashERC1967I(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\\n            hash := keccak256(0x0c, 0x74)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic ERC1967I proxy of `implementation`,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddressERC1967I(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHashERC1967I(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*            CONSTANT ERC1967 BOOTSTRAP OPERATIONS           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: This enables an ERC1967 proxy to be deployed at a deterministic address\\n    // independent of the implementation:\\n    // ```\\n    //     address bootstrap = LibClone.constantERC1967Bootstrap();\\n    //     address instance = LibClone.deployDeterministicERC1967(0, bootstrap, salt);\\n    //     LibClone.bootstrapConstantERC1967(bootstrap, implementation);\\n    // ```\\n\\n    /// @dev Deploys the constant ERC1967 bootstrap if it has not been deployed.\\n    function constantERC1967Bootstrap() internal returns (address bootstrap) {\\n        bootstrap = constantERC1967BootstrapAddress();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(extcodesize(bootstrap)) {\\n                mstore(0x20, 0x0894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc55)\\n                mstore(0x00, 0x60258060093d393df358357f36)\\n                if iszero(create2(0, 0x13, 0x2e, 0)) {\\n                    mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the implementation address of the ERC1967 bootstrap for this contract.\\n    function constantERC1967BootstrapAddress() internal view returns (address bootstrap) {\\n        bytes32 hash = 0xfe1a42b9c571a6a8c083c94ac67b9cfd74e2582923426aa3b762e3431d717cd1;\\n        bootstrap = predictDeterministicAddress(hash, bytes32(0), address(this));\\n    }\\n\\n    /// @dev Replaces the implementation at `instance`.\\n    function bootstrapERC1967(address instance, address implementation) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, shr(96, shl(96, implementation)))\\n            if iszero(call(gas(), instance, 0, 0x00, 0x20, codesize(), 0x00)) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*          MINIMAL ERC1967 BEACON PROXY OPERATIONS           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: If you use this proxy, you MUST make sure that the beacon is a\\n    // valid ERC1967 beacon. This means that the beacon must always return a valid\\n    // address upon a staticcall to `implementation()`, given sufficient gas.\\n    // For performance, the deployment operations and the proxy assumes that the\\n    // beacon is always valid and will NOT validate it.\\n\\n    /// @dev Deploys a minimal ERC1967 beacon proxy.\\n    function deployERC1967BeaconProxy(address beacon) internal returns (address instance) {\\n        instance = deployERC1967BeaconProxy(0, beacon);\\n    }\\n\\n    /// @dev Deploys a minimal ERC1967 beacon proxy.\\n    /// Deposits `value` ETH during deployment.\\n    function deployERC1967BeaconProxy(uint256 value, address beacon)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * ---------------------------------------------------------------------------------+\\n             * CREATION (34 bytes)                                                              |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\\n             * 81         | DUP2           | r 0 r            |                                 |\\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\\n             * 73 beac    | PUSH20 beac    | beac 0 r         | [0..runSize): runtime code      |\\n             * 60 slotPos | PUSH1 slotPos  | slotPos beac 0 r | [0..runSize): runtime code      |\\n             * 51         | MLOAD          | slot beac 0 r    | [0..runSize): runtime code      |\\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\\n             * ---------------------------------------------------------------------------------|\\n             * RUNTIME (82 bytes)                                                               |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             *                                                                                  |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36         | CALLDATASIZE   | cds              |                                 |\\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | 0                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ~~~~~~~ beacon staticcall sub procedure ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\\n             * 60 0x20       | PUSH1 0x20       | 32                          |                 |\\n             * 36            | CALLDATASIZE     | cds 32                      |                 |\\n             * 60 0x04       | PUSH1 0x04       | 4 cds 32                    |                 |\\n             * 36            | CALLDATASIZE     | cds 4 cds 32                |                 |\\n             * 63 0x5c60da1b | PUSH4 0x5c60da1b | 0x5c60da1b cds 4 cds 32     |                 |\\n             * 60 0xe0       | PUSH1 0xe0       | 224 0x5c60da1b cds 4 cds 32 |                 |\\n             * 1b            | SHL              | sel cds 4 cds 32            |                 |\\n             * 36            | CALLDATASIZE     | cds sel cds 4 cds 32        |                 |\\n             * 52            | MSTORE           | cds 4 cds 32                | sel             |\\n             * 7f slot       | PUSH32 slot      | s cds 4 cds 32              | sel             |\\n             * 54            | SLOAD            | beac cds 4 cds 32           | sel             |\\n             * 5a            | GAS              | g beac cds 4 cds 32         | sel             |\\n             * fa            | STATICCALL       | succ                        | impl            |\\n             * 50            | POP              |                             | impl            |\\n             * 36            | CALLDATASIZE     | cds                         | impl            |\\n             * 51            | MLOAD            | impl                        | impl            |\\n             * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\\n             * 5a         | GAS            | g impl 0 cds 0 0 | [0..calldatasize): calldata     |\\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 60 0x4d    | PUSH1 0x4d     | dest succ        | [0..returndatasize): returndata |\\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\\n             * ---------------------------------------------------------------------------------+\\n             */\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\\n            instance := create(value, 0x0c, 0x74)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic minimal ERC1967 beacon proxy with `salt`.\\n    function deployDeterministicERC1967BeaconProxy(address beacon, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = deployDeterministicERC1967BeaconProxy(0, beacon, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic minimal ERC1967 beacon proxy with `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    function deployDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\\n            instance := create2(value, 0x0c, 0x74, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Creates a deterministic minimal ERC1967 beacon proxy with `salt`.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967BeaconProxy(address beacon, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        return createDeterministicERC1967BeaconProxy(0, beacon, salt);\\n    }\\n\\n    /// @dev Creates a deterministic minimal ERC1967 beacon proxy with `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\\n            // Compute and store the bytecode hash.\\n            mstore(add(m, 0x35), keccak256(0x0c, 0x74))\\n            mstore(m, shl(88, address()))\\n            mstore8(m, 0xff) // Write the prefix.\\n            mstore(add(m, 0x15), salt)\\n            instance := keccak256(m, 0x55)\\n            for {} 1 {} {\\n                if iszero(extcodesize(instance)) {\\n                    instance := create2(value, 0x0c, 0x74, salt)\\n                    if iszero(instance) {\\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    break\\n                }\\n                alreadyDeployed := 1\\n                if iszero(value) { break }\\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                break\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code of the minimal ERC1967 beacon proxy.\\n    function initCodeERC1967BeaconProxy(address beacon)\\n        internal\\n        pure\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(\\n                add(result, 0x74),\\n                0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3\\n            )\\n            mstore(\\n                add(result, 0x54),\\n                0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c\\n            )\\n            mstore(add(result, 0x34), 0x60195155f3363d3d373d3d363d602036600436635c60da)\\n            mstore(add(result, 0x1d), beacon)\\n            mstore(add(result, 0x09), 0x60523d8160223d3973)\\n            mstore(add(result, 0x94), 0)\\n            mstore(result, 0x74) // Store the length.\\n            mstore(0x40, add(result, 0xa0)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the minimal ERC1967 beacon proxy.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHashERC1967BeaconProxy(address beacon) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\\n            hash := keccak256(0x0c, 0x74)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic ERC1967 beacon proxy,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddressERC1967BeaconProxy(\\n        address beacon,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHashERC1967BeaconProxy(beacon);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      OTHER OPERATIONS                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the address when a contract with initialization code hash,\\n    /// `hash`, is deployed with `salt`, by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\\n        internal\\n        pure\\n        returns (address predicted)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and store the bytecode hash.\\n            mstore8(0x00, 0xff) // Write the prefix.\\n            mstore(0x35, hash)\\n            mstore(0x01, shl(96, deployer))\\n            mstore(0x15, salt)\\n            predicted := keccak256(0x00, 0x55)\\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Requires that `salt` starts with either the zero address or `by`.\\n    function checkStartsWith(bytes32 salt, address by) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the salt does not start with the zero address or `by`.\\n            if iszero(or(iszero(shr(96, salt)), eq(shr(96, shl(96, by)), shr(96, salt)))) {\\n                mstore(0x00, 0x0c4549ef) // `SaltDoesNotStartWith()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xeef85d149b91730bbcf9a657bcd716de80ad0919b9e085beb9c018eb451c0aa1\",\"license\":\"MIT\"},\"solady/utils/SignatureCheckerLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Signature verification helper that supports both ECDSA signatures from EOAs\\n/// and ERC1271 signatures from smart contract wallets like Argent and Gnosis safe.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SignatureCheckerLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/SignatureChecker.sol)\\n///\\n/// @dev Note:\\n/// - The signature checking functions use the ecrecover precompile (0x1).\\n/// - The `bytes memory signature` variants use the identity precompile (0x4)\\n///   to copy memory internally.\\n/// - Unlike ECDSA signatures, contract signatures are revocable.\\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\\n///   See: https://eips.ethereum.org/EIPS/eip-2098\\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\\n///\\n/// WARNING! Do NOT use signatures as unique identifiers:\\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\\n///   EIP-712 also enables readable signing of typed data for better user safety.\\n/// This implementation does NOT check if a signature is non-malleable.\\nlibrary SignatureCheckerLib {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*               SIGNATURE CHECKING OPERATIONS                */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits of `signer` in case they are dirty.\\n            for { signer := shr(96, shl(96, signer)) } signer {} {\\n                let m := mload(0x40)\\n                mstore(0x00, hash)\\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n                if eq(mload(signature), 64) {\\n                    let vs := mload(add(signature, 0x40))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    let t :=\\n                        staticcall(\\n                            gas(), // Amount of gas left for the transaction.\\n                            1, // Address of `ecrecover`.\\n                            0x00, // Start of input.\\n                            0x80, // Size of input.\\n                            0x01, // Start of output.\\n                            0x20 // Size of output.\\n                        )\\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                        isValid := 1\\n                        mstore(0x60, 0) // Restore the zero slot.\\n                        mstore(0x40, m) // Restore the free memory pointer.\\n                        break\\n                    }\\n                }\\n                if eq(mload(signature), 65) {\\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\\n                    let t :=\\n                        staticcall(\\n                            gas(), // Amount of gas left for the transaction.\\n                            1, // Address of `ecrecover`.\\n                            0x00, // Start of input.\\n                            0x80, // Size of input.\\n                            0x01, // Start of output.\\n                            0x20 // Size of output.\\n                        )\\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                        isValid := 1\\n                        mstore(0x60, 0) // Restore the zero slot.\\n                        mstore(0x40, m) // Restore the free memory pointer.\\n                        break\\n                    }\\n                }\\n                mstore(0x60, 0) // Restore the zero slot.\\n                mstore(0x40, m) // Restore the free memory pointer.\\n\\n                let f := shl(224, 0x1626ba7e)\\n                mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m, 0x04), hash)\\n                let d := add(m, 0x24)\\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n                // Copy the `signature` over.\\n                let n := add(0x20, mload(signature))\\n                pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\\n                // forgefmt: disable-next-item\\n                isValid := and(\\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                    eq(mload(d), f),\\n                    // Whether the staticcall does not revert.\\n                    // This must be placed at the end of the `and` clause,\\n                    // as the arguments are evaluated from right to left.\\n                    staticcall(\\n                        gas(), // Remaining gas.\\n                        signer, // The `signer` address.\\n                        m, // Offset of calldata in memory.\\n                        add(returndatasize(), 0x44), // Length of calldata in memory.\\n                        d, // Offset of returndata.\\n                        0x20 // Length of returndata to write.\\n                    )\\n                )\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\\n    function isValidSignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits of `signer` in case they are dirty.\\n            for { signer := shr(96, shl(96, signer)) } signer {} {\\n                let m := mload(0x40)\\n                mstore(0x00, hash)\\n                if eq(signature.length, 64) {\\n                    let vs := calldataload(add(signature.offset, 0x20))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    let t :=\\n                        staticcall(\\n                            gas(), // Amount of gas left for the transaction.\\n                            1, // Address of `ecrecover`.\\n                            0x00, // Start of input.\\n                            0x80, // Size of input.\\n                            0x01, // Start of output.\\n                            0x20 // Size of output.\\n                        )\\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                        isValid := 1\\n                        mstore(0x60, 0) // Restore the zero slot.\\n                        mstore(0x40, m) // Restore the free memory pointer.\\n                        break\\n                    }\\n                }\\n                if eq(signature.length, 65) {\\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\n                    calldatacopy(0x40, signature.offset, 0x40) // `r`, `s`.\\n                    let t :=\\n                        staticcall(\\n                            gas(), // Amount of gas left for the transaction.\\n                            1, // Address of `ecrecover`.\\n                            0x00, // Start of input.\\n                            0x80, // Size of input.\\n                            0x01, // Start of output.\\n                            0x20 // Size of output.\\n                        )\\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                        isValid := 1\\n                        mstore(0x60, 0) // Restore the zero slot.\\n                        mstore(0x40, m) // Restore the free memory pointer.\\n                        break\\n                    }\\n                }\\n                mstore(0x60, 0) // Restore the zero slot.\\n                mstore(0x40, m) // Restore the free memory pointer.\\n\\n                let f := shl(224, 0x1626ba7e)\\n                mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m, 0x04), hash)\\n                let d := add(m, 0x24)\\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n                mstore(add(m, 0x44), signature.length)\\n                // Copy the `signature` over.\\n                calldatacopy(add(m, 0x64), signature.offset, signature.length)\\n                // forgefmt: disable-next-item\\n                isValid := and(\\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                    eq(mload(d), f),\\n                    // Whether the staticcall does not revert.\\n                    // This must be placed at the end of the `and` clause,\\n                    // as the arguments are evaluated from right to left.\\n                    staticcall(\\n                        gas(), // Remaining gas.\\n                        signer, // The `signer` address.\\n                        m, // Offset of calldata in memory.\\n                        add(signature.length, 0x64), // Length of calldata in memory.\\n                        d, // Offset of returndata.\\n                        0x20 // Length of returndata to write.\\n                    )\\n                )\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `signer` and `hash`.\\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits of `signer` in case they are dirty.\\n            for { signer := shr(96, shl(96, signer)) } signer {} {\\n                let m := mload(0x40)\\n                mstore(0x00, hash)\\n                mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                mstore(0x40, r) // `r`.\\n                mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                let t :=\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                    isValid := 1\\n                    mstore(0x60, 0) // Restore the zero slot.\\n                    mstore(0x40, m) // Restore the free memory pointer.\\n                    break\\n                }\\n\\n                let f := shl(224, 0x1626ba7e)\\n                mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m, 0x04), hash)\\n                let d := add(m, 0x24)\\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n                mstore(add(m, 0x44), 65) // Length of the signature.\\n                mstore(add(m, 0x64), r) // `r`.\\n                mstore(add(m, 0x84), mload(0x60)) // `s`.\\n                mstore8(add(m, 0xa4), mload(0x20)) // `v`.\\n                // forgefmt: disable-next-item\\n                isValid := and(\\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                    eq(mload(d), f),\\n                    // Whether the staticcall does not revert.\\n                    // This must be placed at the end of the `and` clause,\\n                    // as the arguments are evaluated from right to left.\\n                    staticcall(\\n                        gas(), // Remaining gas.\\n                        signer, // The `signer` address.\\n                        m, // Offset of calldata in memory.\\n                        0xa5, // Length of calldata in memory.\\n                        d, // Offset of returndata.\\n                        0x20 // Length of returndata to write.\\n                    )\\n                )\\n                mstore(0x60, 0) // Restore the zero slot.\\n                mstore(0x40, m) // Restore the free memory pointer.\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `signer` and `hash`.\\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\\n    function isValidSignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits of `signer` in case they are dirty.\\n            for { signer := shr(96, shl(96, signer)) } signer {} {\\n                let m := mload(0x40)\\n                mstore(0x00, hash)\\n                mstore(0x20, and(v, 0xff)) // `v`.\\n                mstore(0x40, r) // `r`.\\n                mstore(0x60, s) // `s`.\\n                let t :=\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                    isValid := 1\\n                    mstore(0x60, 0) // Restore the zero slot.\\n                    mstore(0x40, m) // Restore the free memory pointer.\\n                    break\\n                }\\n\\n                let f := shl(224, 0x1626ba7e)\\n                mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m, 0x04), hash)\\n                let d := add(m, 0x24)\\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n                mstore(add(m, 0x44), 65) // Length of the signature.\\n                mstore(add(m, 0x64), r) // `r`.\\n                mstore(add(m, 0x84), s) // `s`.\\n                mstore8(add(m, 0xa4), v) // `v`.\\n                // forgefmt: disable-next-item\\n                isValid := and(\\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                    eq(mload(d), f),\\n                    // Whether the staticcall does not revert.\\n                    // This must be placed at the end of the `and` clause,\\n                    // as the arguments are evaluated from right to left.\\n                    staticcall(\\n                        gas(), // Remaining gas.\\n                        signer, // The `signer` address.\\n                        m, // Offset of calldata in memory.\\n                        0xa5, // Length of calldata in memory.\\n                        d, // Offset of returndata.\\n                        0x20 // Length of returndata to write.\\n                    )\\n                )\\n                mstore(0x60, 0) // Restore the zero slot.\\n                mstore(0x40, m) // Restore the free memory pointer.\\n                break\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     ERC1271 OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: These ERC1271 operations do NOT have an ECDSA fallback.\\n    // These functions are intended to be used with the regular `isValidSignatureNow` functions\\n    // or other signature verification functions (e.g. P256).\\n\\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes memory signature)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            let f := shl(224, 0x1626ba7e)\\n            mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n            mstore(add(m, 0x04), hash)\\n            let d := add(m, 0x24)\\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n            // Copy the `signature` over.\\n            let n := add(0x20, mload(signature))\\n            pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\\n            // forgefmt: disable-next-item\\n            isValid := and(\\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                eq(mload(d), f),\\n                // Whether the staticcall does not revert.\\n                // This must be placed at the end of the `and` clause,\\n                // as the arguments are evaluated from right to left.\\n                staticcall(\\n                    gas(), // Remaining gas.\\n                    signer, // The `signer` address.\\n                    m, // Offset of calldata in memory.\\n                    add(returndatasize(), 0x44), // Length of calldata in memory.\\n                    d, // Offset of returndata.\\n                    0x20 // Length of returndata to write.\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\\n    function isValidERC1271SignatureNowCalldata(\\n        address signer,\\n        bytes32 hash,\\n        bytes calldata signature\\n    ) internal view returns (bool isValid) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            let f := shl(224, 0x1626ba7e)\\n            mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n            mstore(add(m, 0x04), hash)\\n            let d := add(m, 0x24)\\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n            mstore(add(m, 0x44), signature.length)\\n            // Copy the `signature` over.\\n            calldatacopy(add(m, 0x64), signature.offset, signature.length)\\n            // forgefmt: disable-next-item\\n            isValid := and(\\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                eq(mload(d), f),\\n                // Whether the staticcall does not revert.\\n                // This must be placed at the end of the `and` clause,\\n                // as the arguments are evaluated from right to left.\\n                staticcall(\\n                    gas(), // Remaining gas.\\n                    signer, // The `signer` address.\\n                    m, // Offset of calldata in memory.\\n                    add(signature.length, 0x64), // Length of calldata in memory.\\n                    d, // Offset of returndata.\\n                    0x20 // Length of returndata to write.\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `hash`\\n    /// for an ERC1271 `signer` contract.\\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            let f := shl(224, 0x1626ba7e)\\n            mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n            mstore(add(m, 0x04), hash)\\n            let d := add(m, 0x24)\\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n            mstore(add(m, 0x44), 65) // Length of the signature.\\n            mstore(add(m, 0x64), r) // `r`.\\n            mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.\\n            mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.\\n            // forgefmt: disable-next-item\\n            isValid := and(\\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                eq(mload(d), f),\\n                // Whether the staticcall does not revert.\\n                // This must be placed at the end of the `and` clause,\\n                // as the arguments are evaluated from right to left.\\n                staticcall(\\n                    gas(), // Remaining gas.\\n                    signer, // The `signer` address.\\n                    m, // Offset of calldata in memory.\\n                    0xa5, // Length of calldata in memory.\\n                    d, // Offset of returndata.\\n                    0x20 // Length of returndata to write.\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `hash`\\n    /// for an ERC1271 `signer` contract.\\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            let f := shl(224, 0x1626ba7e)\\n            mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n            mstore(add(m, 0x04), hash)\\n            let d := add(m, 0x24)\\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n            mstore(add(m, 0x44), 65) // Length of the signature.\\n            mstore(add(m, 0x64), r) // `r`.\\n            mstore(add(m, 0x84), s) // `s`.\\n            mstore8(add(m, 0xa4), v) // `v`.\\n            // forgefmt: disable-next-item\\n            isValid := and(\\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                eq(mload(d), f),\\n                // Whether the staticcall does not revert.\\n                // This must be placed at the end of the `and` clause,\\n                // as the arguments are evaluated from right to left.\\n                staticcall(\\n                    gas(), // Remaining gas.\\n                    signer, // The `signer` address.\\n                    m, // Offset of calldata in memory.\\n                    0xa5, // Length of calldata in memory.\\n                    d, // Offset of returndata.\\n                    0x20 // Length of returndata to write.\\n                )\\n            )\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     ERC6492 OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: These ERC6492 operations do NOT have an ECDSA fallback.\\n    // These functions are intended to be used with the regular `isValidSignatureNow` functions\\n    // or other signature verification functions (e.g. P256).\\n    // The calldata variants are excluded for brevity.\\n\\n    /// @dev Returns whether `signature` is valid for `hash`.\\n    /// If the signature is postfixed with the ERC6492 magic number, it will attempt to\\n    /// deploy / prepare the `signer` smart account before doing a regular ERC1271 check.\\n    /// Note: This function is NOT reentrancy safe.\\n    function isValidERC6492SignatureNowAllowSideEffects(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal returns (bool isValid) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function callIsValidSignature(signer_, hash_, signature_) -> _isValid {\\n                let m_ := mload(0x40)\\n                let f_ := shl(224, 0x1626ba7e)\\n                mstore(m_, f_) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m_, 0x04), hash_)\\n                let d_ := add(m_, 0x24)\\n                mstore(d_, 0x40) // The offset of the `signature` in the calldata.\\n                let n_ := add(0x20, mload(signature_))\\n                pop(staticcall(gas(), 4, signature_, n_, add(m_, 0x44), n_))\\n                _isValid :=\\n                    and(\\n                        eq(mload(d_), f_),\\n                        staticcall(gas(), signer_, m_, add(returndatasize(), 0x44), d_, 0x20)\\n                    )\\n            }\\n            for { let n := mload(signature) } 1 {} {\\n                if iszero(eq(mload(add(signature, n)), mul(0x6492, div(not(isValid), 0xffff)))) {\\n                    isValid := callIsValidSignature(signer, hash, signature)\\n                    break\\n                }\\n                let o := add(signature, 0x20) // Signature bytes.\\n                let d := add(o, mload(add(o, 0x20))) // Factory calldata.\\n                if iszero(extcodesize(signer)) {\\n                    if iszero(call(gas(), mload(o), 0, add(d, 0x20), mload(d), codesize(), 0x00)) {\\n                        break\\n                    }\\n                }\\n                let s := add(o, mload(add(o, 0x40))) // Inner signature.\\n                isValid := callIsValidSignature(signer, hash, s)\\n                if iszero(isValid) {\\n                    if call(gas(), mload(o), 0, add(d, 0x20), mload(d), codesize(), 0x00) {\\n                        isValid := callIsValidSignature(signer, hash, s)\\n                    }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns whether `signature` is valid for `hash`.\\n    /// If the signature is postfixed with the ERC6492 magic number, it will attempt\\n    /// to use a reverting verifier to deploy / prepare the `signer` smart account\\n    /// and do a `isValidSignature` check via the reverting verifier.\\n    /// Note: This function is reentrancy safe.\\n    /// The reverting verifier must be be deployed.\\n    /// Otherwise, the function will return false if `signer` is not yet deployed / prepared.\\n    /// See: https://gist.github.com/Vectorized/846a474c855eee9e441506676800a9ad\\n    function isValidERC6492SignatureNow(address signer, bytes32 hash, bytes memory signature)\\n        internal\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function callIsValidSignature(signer_, hash_, signature_) -> _isValid {\\n                let m_ := mload(0x40)\\n                let f_ := shl(224, 0x1626ba7e)\\n                mstore(m_, f_) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m_, 0x04), hash_)\\n                let d_ := add(m_, 0x24)\\n                mstore(d_, 0x40) // The offset of the `signature` in the calldata.\\n                let n_ := add(0x20, mload(signature_))\\n                pop(staticcall(gas(), 4, signature_, n_, add(m_, 0x44), n_))\\n                _isValid :=\\n                    and(\\n                        eq(mload(d_), f_),\\n                        staticcall(gas(), signer_, m_, add(returndatasize(), 0x44), d_, 0x20)\\n                    )\\n            }\\n            for { let n := mload(signature) } 1 {} {\\n                if iszero(eq(mload(add(signature, n)), mul(0x6492, div(not(isValid), 0xffff)))) {\\n                    isValid := callIsValidSignature(signer, hash, signature)\\n                    break\\n                }\\n                if extcodesize(signer) {\\n                    let o := add(signature, 0x20) // Signature bytes.\\n                    isValid := callIsValidSignature(signer, hash, add(o, mload(add(o, 0x40))))\\n                    if isValid { break }\\n                }\\n                let m := mload(0x40)\\n                mstore(m, signer)\\n                mstore(add(m, 0x20), hash)\\n                let willBeZeroIfRevertingVerifierExists :=\\n                    call(\\n                        gas(), // Remaining gas.\\n                        0x00007bd799e4A591FeA53f8A8a3E9f931626Ba7e, // Reverting verifier.\\n                        0, // Send zero ETH.\\n                        m, // Start of memory.\\n                        add(returndatasize(), 0x40), // Length of calldata in memory.\\n                        staticcall(gas(), 4, add(signature, 0x20), n, add(m, 0x40), n), // 1.\\n                        0x00 // Length of returndata to write.\\n                    )\\n                isValid := gt(returndatasize(), willBeZeroIfRevertingVerifierExists)\\n                break\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     HASHING OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, hash) // Store into scratch space for keccak256.\\n            mstore(0x00, \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n32\\\") // 28 bytes.\\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\\n        }\\n    }\\n\\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    /// Note: Supports lengths of `s` up to 999999 bytes.\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let sLength := mload(s)\\n            let o := 0x20\\n            mstore(o, \\\"\\\\x19Ethereum Signed Message:\\\\n\\\") // 26 bytes, zero-right-padded.\\n            mstore(0x00, 0x00)\\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\\n            for { let temp := sLength } 1 {} {\\n                o := sub(o, 1)\\n                mstore8(o, add(48, mod(temp, 10)))\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\\n            mstore(s, sLength) // Restore the length.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   EMPTY CALLDATA HELPERS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns an empty calldata bytes.\\n    function emptySignature() internal pure returns (bytes calldata signature) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            signature.length := 0\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x43e24246cc3e120f2d8e979f58bf28e2a84e3cac47d9653845a2b2af16a00d99\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60808060405234601557611632908161001b8239f35b600080fdfe6080806040526004908136101561001557600080fd5b60003560e01c90816306fdde0314610d6a575080632b20be6614610ca15780634fe05a511461090157806354fd4d501461089f57806358799d6f146105c65780636d61fe70146105c15780638a91b0e3146105c15780639700320314610368578063c7305b1714610314578063ced2023214610158578063d60b347f14610133578063ecd05961146100fb5763f551e2ee146100b057600080fd5b346100f65760603660031901126100f6576100c9610e0e565b506044359067ffffffffffffffff82116100f6576100e991369101610e6c565b5050602060405160008152f35b600080fd5b50346100f65760203660031901126100f6576020903560018114908115610128575b506040519015158152f35b60029150143861011d565b346100f65760203660031901126100f65761014c610e0e565b50602060405160008152f35b50346100f6576020806003193601126100f6576001600160a01b038061017c610e0e565b1660005260019060018352604060002093845461019881610ff6565b916101a66040519384610f21565b81835260009687528587208684019791885b8484106102785750505050506040519380850191818652518092526040850195926000905b8382106101ea5786880387f35b8451805182168952838101518216848a01526040808201518316908a01526060808201518316908a015260808082015165ffffffffffff908116918b019190915260a0808301518216908b015260c080830151908b015260e080830151908b0152610100808301518216908b01526101209182015116908901526101409097019693820193908501906101dd565b96600789829b9960409b98999b5161028f81610ecc565b8c87541681528c8588015416838201528c600288015416604082015260038701548d8116606083015265ffffffffffff9060a0908281831c16608085015260d01c908301528688015460c0830152600588015460e0830152600688015481811661010084015260301c16610120820152815201930193019291989698979594976101b8565b346100f65760403660031901126100f65761032d610e0e565b602435906001600160a01b03809116600052600060205260406000209182548110156100f65760209260005282600020015416604051908152f35b50346100f6576003196040368201126100f657813567ffffffffffffffff81116100f6576101208184019282360301126100f6576024906103ac6064820184611067565b939094846064116100f6576063198501806014116100f6576034116100f65760971985016010116100f65760a86104449601356bffffffffffffffffffffffff199081811696601460a7198201106105a9575b505050606094851c8061044b602098899560243587527b19457468657265756d205369676e6564204d6573736167653a0a3332600052610104603c8720980190611067565b3691610f92565b9560009785880192610488575b5050505050505050156000146104815760015b65ffffffffffff60a01b60ff6040519216178152f35b600061046b565b909192939495969750604051928760005251604052604088511461055b575b6041885114610511575b60009052816040527f1626ba7e000000000000000000000000000000000000000000000000000000009586835284830152810195869360408552815186019081604493848601925afa503d01915afa915114163880838180808080610458565b8088015160001a8652604088015181526001868160806000825afa5185183d15171561053d57506104b1565b94509650509350506000915092526040523880838180808080610458565b7f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6040890151601b8160ff1c0188521681526001868160806000825afa5185183d15171561053d57506104a7565b60140360a80160031b82901b161694503880806103ff565b610f43565b50346100f6576101603660031901126100f6576105e1610e0e565b6101403660231901126100f6576040516105fa81610ecc565b6024356001600160a01b03811681036100f6578152610617610e24565b60208201526064356001600160a01b03811681036100f65760408201526084356001600160a01b038116036100f65760a43565ffffffffffff811681036100f657608082015260c43565ffffffffffff811681036100f65760a082015260e43560c08201526101043560e08201526101243565ffffffffffff811681036100f6576101008201526101443565ffffffffffff811681036100f6576101208201523360608201526001600160a01b038216600052600160205260406000208054906801000000000000000082101561088a57906106f891600182018155610e3a565b610876576006906001600160a01b038351167fffffffffffffffffffffffff00000000000000000000000000000000000000009081835416178255600182016001600160a01b036020860151168282541617905560028201906001600160a01b03604086015116908254161790556001600160a01b0360608401511665ffffffffffff60a01b608085015160a01b167fffffffffffff000000000000000000000000000000000000000000000000000060a086015160d01b16911717600382015560c08301518582015560e08301516005820155019065ffffffffffff610100820151166bffffffffffff000000000000610120845493015160301b16916bffffffffffffffffffffffff1916171790556001600160a01b0360405191338282167f18181a00afae36a38027e087bdecba0ee3dd48839669ffb2b1484450c703267b600080a3166000526001602052604060002054600019810190811161086157602092508152f35b601183634e487b7160e01b6000525260246000fd5b600084634e487b7160e01b82525260246000fd5b604185634e487b7160e01b6000525260246000fd5b346100f65760003660031901126100f6576108fd6040516108bf81610ee9565b600581527f302e302e310000000000000000000000000000000000000000000000000000006020820152604051918291602083526020830190610de9565b0390f35b50346100f65760a03660031901126100f65761091b610e0e565b9060243590610928610e24565b9167ffffffffffffffff906064356084358381116100f65761094d9036908601610e6c565b909180159687600014610c9857965b15610c8f575061097691610971913691610f92565b61109a565b945b610984858383896110b0565b15610c6657906001600160a01b036109a9921660005260016020526040600020610e3a565b50936001600160a01b036003860154166001600160a01b03600187015416936109d14661128a565b946109da61102f565b966109f9856001600160a01b038951166001600160a01b0384166111ca565b610a028a610fc9565b52610a0c89610fd9565b5262ffffff60206001600160a01b038951169801511692610a2b61100e565b5060405196876101008101109061010089011117610c515750918593916001600160a01b03610b59989694610100610b5e9b9901604052168552602085015260408401526060830152608082019042825260a0830190815260c08301906000825260e0840192600084526001600160a01b036060604051967f414bf38900000000000000000000000000000000000000000000000000000000602089015282815116602489015282602082015116604489015262ffffff604082015116606489015201511660848601525160a48501525160c48401525160e4830152516001600160a01b036101049116818301528152610b2481610ecc565b60405191610b3183610e9a565b8252600060208301526040820152610b4882610fe6565b52610b5281610fe6565b503361137f565b610fe6565b51906020828051810103126100f6576020610c0492015190610b7e61102f565b916001600160a01b0360038160018501541693610ba3848460028401541680976111ca565b610bac88610fc9565b52610bb687610fd9565b52015416610bc261100e565b50604051917f6e553f650000000000000000000000000000000000000000000000000000000060208401526024830152604482015260448152610b2481610f05565b50604051602081526060518060208301528160005b828110610c3a57508160006040809484010152601f80199101168101030190f35b608081015184820160400152839150602001610c19565b604190634e487b7160e01b6000525260246000fd5b836040517facfdb444000000000000000000000000000000000000000000000000000000008152fd5b91505094610978565b5060009661095c565b50346100f65760403660031901126100f657610cbb610e0e565b602435916001600160a01b038092166000526001602052604060002080548410156100f65761014093610ced91610e3a565b509180835416928160018201541691806002830154169060038301549065ffffffffffff958401549260066005860154950154956040519889526020890152604088015281166060870152848160a01c16608087015260d01c60a086015260c085015260e084015281811661010084015260301c16610120820152f35b346100f65760003660031901126100f65780610d886108fd92610ee9565b601481527f4175746f44434153657373696f6e4d6f64756c650000000000000000000000006020820152604051918291602083526020830190610de9565b60005b838110610dd95750506000910152565b8181015183820152602001610dc9565b90602091610e0281518092818552858086019101610dc6565b601f01601f1916010190565b600435906001600160a01b03821682036100f657565b604435906001600160a01b03821682036100f657565b8054821015610e56576000526007602060002091020190600090565b634e487b7160e01b600052603260045260246000fd5b9181601f840112156100f65782359167ffffffffffffffff83116100f657602083818601950101116100f657565b6060810190811067ffffffffffffffff821117610eb657604052565b634e487b7160e01b600052604160045260246000fd5b610140810190811067ffffffffffffffff821117610eb657604052565b6040810190811067ffffffffffffffff821117610eb657604052565b6080810190811067ffffffffffffffff821117610eb657604052565b90601f8019910116810190811067ffffffffffffffff821117610eb657604052565b346100f65760203660031901126100f65760043567ffffffffffffffff81116100f657610f74903690600401610e6c565b005b67ffffffffffffffff8111610eb657601f01601f191660200190565b929192610f9e82610f76565b91610fac6040519384610f21565b8294818452818301116100f6578281602093846000960137010152565b805160011015610e565760400190565b805115610e565760200190565b805160021015610e565760600190565b67ffffffffffffffff8111610eb65760051b60200190565b6040519061101b82610e9a565b606060408360008152600060208201520152565b6040519061103c82610f05565b600382528160005b60608110611050575050565b60209061105b61100e565b82828501015201611044565b903590601e19813603018212156100f6570180359067ffffffffffffffff82116100f6576020019181360383136100f657565b60448151106110aa576044015190565b50600090565b926110d26001600160a01b039384600094168452600160205260408420610e3a565b509280845416911603611148576006820180549265ffffffffffff91828560301c1694600483015493600584019660038854950154828160a01c1642109081156111bd575b506111b1578015908115611185575b501561115857505050840193841090811561114e575b50611148575055600190565b91505090565b905083113861113c565b9491968094919693501161117c57505542169065ffffffffffff1916179055600190565b94505050505090565b90508183160181811161119d57814291161138611126565b602487634e487b7160e01b81526011600452fd5b50505050505091505090565b905060d01c421138611117565b9291906111d561100e565b506111de61100e565b506001600160a01b03809416916040908151957f095ea7b300000000000000000000000000000000000000000000000000000000938460208901521695866024820152600060448201526044815261123581610f05565b82519061124182610e9a565b8582526000602083015283820152958251936020850152602484015260448301526044825261126f82610f05565b80519261127b84610e9a565b83526000602084015282015290565b6000602060405161129a81610ee9565b8281520152600181036112d657506040516112b481610ee9565b73e592427a0aece92de3edee1f18e0157c058615648152610bb8602082015290565b608981036112eb57506040516112b481610ee9565b61a4b103611321576040516112ff81610ee9565b73e592427a0aece92de3edee1f18e0157c0586156481526101f4602082015290565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f556e737570706f72746564206e6574776f726b000000000000000000000000006044820152fd5b91909160409081516020918282017f0100000000000000000000000000000000000000000000000000000000000000815260009283602182015283602282015283602682015283602a8201528481526113d781610ee9565b519051908481106115eb575b506001600160a01b0385519786890186808b0152815180915260609060608b01918860608d8460051b010194019288915b8383106115a2575050505050918480949261143e8b61147e9a9b9c9603601f198101875286610f21565b89518099819682957fd691c96400000000000000000000000000000000000000000000000000000000845260048401528c60248401526044830190610de9565b0393165af1938415611598578194611498575b5050505090565b90919293503d8083863e6114ac8186610f21565b8401838582031261159457845167ffffffffffffffff9586821161159057019281601f8501121561158d578351926114e384610ff6565b966114f082519889610f21565b848852868089019560051b8701019584871161158957878101955b8787106115245750505050505050505038808080611491565b865183811161158557820186603f82011215611585578981015161154781610f76565b9161155487519384610f21565b8183528887838301011161158157916115768c94928594898685019101610dc6565b81520196019561150b565b8780fd5b8580fd5b8380fd5b80fd5b8480fd5b8280fd5b51903d90823e3d90fd5b90919293948a808f8e8560019581838e8e6115dc97605f19908603018d525190815116845287810151888501520151938201520190610de9565b97019301930191939290611414565b60001990850360031b1b16386113e356fea2646970667358221220945e30d3d9102d6dca25bfb255e19bf28568de9f0ef3a06cb41d1cab25810b1464736f6c63430008190033",
  "deployedBytecode": "0x6080806040526004908136101561001557600080fd5b60003560e01c90816306fdde0314610d6a575080632b20be6614610ca15780634fe05a511461090157806354fd4d501461089f57806358799d6f146105c65780636d61fe70146105c15780638a91b0e3146105c15780639700320314610368578063c7305b1714610314578063ced2023214610158578063d60b347f14610133578063ecd05961146100fb5763f551e2ee146100b057600080fd5b346100f65760603660031901126100f6576100c9610e0e565b506044359067ffffffffffffffff82116100f6576100e991369101610e6c565b5050602060405160008152f35b600080fd5b50346100f65760203660031901126100f6576020903560018114908115610128575b506040519015158152f35b60029150143861011d565b346100f65760203660031901126100f65761014c610e0e565b50602060405160008152f35b50346100f6576020806003193601126100f6576001600160a01b038061017c610e0e565b1660005260019060018352604060002093845461019881610ff6565b916101a66040519384610f21565b81835260009687528587208684019791885b8484106102785750505050506040519380850191818652518092526040850195926000905b8382106101ea5786880387f35b8451805182168952838101518216848a01526040808201518316908a01526060808201518316908a015260808082015165ffffffffffff908116918b019190915260a0808301518216908b015260c080830151908b015260e080830151908b0152610100808301518216908b01526101209182015116908901526101409097019693820193908501906101dd565b96600789829b9960409b98999b5161028f81610ecc565b8c87541681528c8588015416838201528c600288015416604082015260038701548d8116606083015265ffffffffffff9060a0908281831c16608085015260d01c908301528688015460c0830152600588015460e0830152600688015481811661010084015260301c16610120820152815201930193019291989698979594976101b8565b346100f65760403660031901126100f65761032d610e0e565b602435906001600160a01b03809116600052600060205260406000209182548110156100f65760209260005282600020015416604051908152f35b50346100f6576003196040368201126100f657813567ffffffffffffffff81116100f6576101208184019282360301126100f6576024906103ac6064820184611067565b939094846064116100f6576063198501806014116100f6576034116100f65760971985016010116100f65760a86104449601356bffffffffffffffffffffffff199081811696601460a7198201106105a9575b505050606094851c8061044b602098899560243587527b19457468657265756d205369676e6564204d6573736167653a0a3332600052610104603c8720980190611067565b3691610f92565b9560009785880192610488575b5050505050505050156000146104815760015b65ffffffffffff60a01b60ff6040519216178152f35b600061046b565b909192939495969750604051928760005251604052604088511461055b575b6041885114610511575b60009052816040527f1626ba7e000000000000000000000000000000000000000000000000000000009586835284830152810195869360408552815186019081604493848601925afa503d01915afa915114163880838180808080610458565b8088015160001a8652604088015181526001868160806000825afa5185183d15171561053d57506104b1565b94509650509350506000915092526040523880838180808080610458565b7f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6040890151601b8160ff1c0188521681526001868160806000825afa5185183d15171561053d57506104a7565b60140360a80160031b82901b161694503880806103ff565b610f43565b50346100f6576101603660031901126100f6576105e1610e0e565b6101403660231901126100f6576040516105fa81610ecc565b6024356001600160a01b03811681036100f6578152610617610e24565b60208201526064356001600160a01b03811681036100f65760408201526084356001600160a01b038116036100f65760a43565ffffffffffff811681036100f657608082015260c43565ffffffffffff811681036100f65760a082015260e43560c08201526101043560e08201526101243565ffffffffffff811681036100f6576101008201526101443565ffffffffffff811681036100f6576101208201523360608201526001600160a01b038216600052600160205260406000208054906801000000000000000082101561088a57906106f891600182018155610e3a565b610876576006906001600160a01b038351167fffffffffffffffffffffffff00000000000000000000000000000000000000009081835416178255600182016001600160a01b036020860151168282541617905560028201906001600160a01b03604086015116908254161790556001600160a01b0360608401511665ffffffffffff60a01b608085015160a01b167fffffffffffff000000000000000000000000000000000000000000000000000060a086015160d01b16911717600382015560c08301518582015560e08301516005820155019065ffffffffffff610100820151166bffffffffffff000000000000610120845493015160301b16916bffffffffffffffffffffffff1916171790556001600160a01b0360405191338282167f18181a00afae36a38027e087bdecba0ee3dd48839669ffb2b1484450c703267b600080a3166000526001602052604060002054600019810190811161086157602092508152f35b601183634e487b7160e01b6000525260246000fd5b600084634e487b7160e01b82525260246000fd5b604185634e487b7160e01b6000525260246000fd5b346100f65760003660031901126100f6576108fd6040516108bf81610ee9565b600581527f302e302e310000000000000000000000000000000000000000000000000000006020820152604051918291602083526020830190610de9565b0390f35b50346100f65760a03660031901126100f65761091b610e0e565b9060243590610928610e24565b9167ffffffffffffffff906064356084358381116100f65761094d9036908601610e6c565b909180159687600014610c9857965b15610c8f575061097691610971913691610f92565b61109a565b945b610984858383896110b0565b15610c6657906001600160a01b036109a9921660005260016020526040600020610e3a565b50936001600160a01b036003860154166001600160a01b03600187015416936109d14661128a565b946109da61102f565b966109f9856001600160a01b038951166001600160a01b0384166111ca565b610a028a610fc9565b52610a0c89610fd9565b5262ffffff60206001600160a01b038951169801511692610a2b61100e565b5060405196876101008101109061010089011117610c515750918593916001600160a01b03610b59989694610100610b5e9b9901604052168552602085015260408401526060830152608082019042825260a0830190815260c08301906000825260e0840192600084526001600160a01b036060604051967f414bf38900000000000000000000000000000000000000000000000000000000602089015282815116602489015282602082015116604489015262ffffff604082015116606489015201511660848601525160a48501525160c48401525160e4830152516001600160a01b036101049116818301528152610b2481610ecc565b60405191610b3183610e9a565b8252600060208301526040820152610b4882610fe6565b52610b5281610fe6565b503361137f565b610fe6565b51906020828051810103126100f6576020610c0492015190610b7e61102f565b916001600160a01b0360038160018501541693610ba3848460028401541680976111ca565b610bac88610fc9565b52610bb687610fd9565b52015416610bc261100e565b50604051917f6e553f650000000000000000000000000000000000000000000000000000000060208401526024830152604482015260448152610b2481610f05565b50604051602081526060518060208301528160005b828110610c3a57508160006040809484010152601f80199101168101030190f35b608081015184820160400152839150602001610c19565b604190634e487b7160e01b6000525260246000fd5b836040517facfdb444000000000000000000000000000000000000000000000000000000008152fd5b91505094610978565b5060009661095c565b50346100f65760403660031901126100f657610cbb610e0e565b602435916001600160a01b038092166000526001602052604060002080548410156100f65761014093610ced91610e3a565b509180835416928160018201541691806002830154169060038301549065ffffffffffff958401549260066005860154950154956040519889526020890152604088015281166060870152848160a01c16608087015260d01c60a086015260c085015260e084015281811661010084015260301c16610120820152f35b346100f65760003660031901126100f65780610d886108fd92610ee9565b601481527f4175746f44434153657373696f6e4d6f64756c650000000000000000000000006020820152604051918291602083526020830190610de9565b60005b838110610dd95750506000910152565b8181015183820152602001610dc9565b90602091610e0281518092818552858086019101610dc6565b601f01601f1916010190565b600435906001600160a01b03821682036100f657565b604435906001600160a01b03821682036100f657565b8054821015610e56576000526007602060002091020190600090565b634e487b7160e01b600052603260045260246000fd5b9181601f840112156100f65782359167ffffffffffffffff83116100f657602083818601950101116100f657565b6060810190811067ffffffffffffffff821117610eb657604052565b634e487b7160e01b600052604160045260246000fd5b610140810190811067ffffffffffffffff821117610eb657604052565b6040810190811067ffffffffffffffff821117610eb657604052565b6080810190811067ffffffffffffffff821117610eb657604052565b90601f8019910116810190811067ffffffffffffffff821117610eb657604052565b346100f65760203660031901126100f65760043567ffffffffffffffff81116100f657610f74903690600401610e6c565b005b67ffffffffffffffff8111610eb657601f01601f191660200190565b929192610f9e82610f76565b91610fac6040519384610f21565b8294818452818301116100f6578281602093846000960137010152565b805160011015610e565760400190565b805115610e565760200190565b805160021015610e565760600190565b67ffffffffffffffff8111610eb65760051b60200190565b6040519061101b82610e9a565b606060408360008152600060208201520152565b6040519061103c82610f05565b600382528160005b60608110611050575050565b60209061105b61100e565b82828501015201611044565b903590601e19813603018212156100f6570180359067ffffffffffffffff82116100f6576020019181360383136100f657565b60448151106110aa576044015190565b50600090565b926110d26001600160a01b039384600094168452600160205260408420610e3a565b509280845416911603611148576006820180549265ffffffffffff91828560301c1694600483015493600584019660038854950154828160a01c1642109081156111bd575b506111b1578015908115611185575b501561115857505050840193841090811561114e575b50611148575055600190565b91505090565b905083113861113c565b9491968094919693501161117c57505542169065ffffffffffff1916179055600190565b94505050505090565b90508183160181811161119d57814291161138611126565b602487634e487b7160e01b81526011600452fd5b50505050505091505090565b905060d01c421138611117565b9291906111d561100e565b506111de61100e565b506001600160a01b03809416916040908151957f095ea7b300000000000000000000000000000000000000000000000000000000938460208901521695866024820152600060448201526044815261123581610f05565b82519061124182610e9a565b8582526000602083015283820152958251936020850152602484015260448301526044825261126f82610f05565b80519261127b84610e9a565b83526000602084015282015290565b6000602060405161129a81610ee9565b8281520152600181036112d657506040516112b481610ee9565b73e592427a0aece92de3edee1f18e0157c058615648152610bb8602082015290565b608981036112eb57506040516112b481610ee9565b61a4b103611321576040516112ff81610ee9565b73e592427a0aece92de3edee1f18e0157c0586156481526101f4602082015290565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f556e737570706f72746564206e6574776f726b000000000000000000000000006044820152fd5b91909160409081516020918282017f0100000000000000000000000000000000000000000000000000000000000000815260009283602182015283602282015283602682015283602a8201528481526113d781610ee9565b519051908481106115eb575b506001600160a01b0385519786890186808b0152815180915260609060608b01918860608d8460051b010194019288915b8383106115a2575050505050918480949261143e8b61147e9a9b9c9603601f198101875286610f21565b89518099819682957fd691c96400000000000000000000000000000000000000000000000000000000845260048401528c60248401526044830190610de9565b0393165af1938415611598578194611498575b5050505090565b90919293503d8083863e6114ac8186610f21565b8401838582031261159457845167ffffffffffffffff9586821161159057019281601f8501121561158d578351926114e384610ff6565b966114f082519889610f21565b848852868089019560051b8701019584871161158957878101955b8787106115245750505050505050505038808080611491565b865183811161158557820186603f82011215611585578981015161154781610f76565b9161155487519384610f21565b8183528887838301011161158157916115768c94928594898685019101610dc6565b81520196019561150b565b8780fd5b8580fd5b8380fd5b80fd5b8480fd5b8280fd5b51903d90823e3d90fd5b90919293948a808f8e8560019581838e8e6115dc97605f19908603018d525190815116845287810151888501520151938201520190610de9565b97019301930191939290611414565b60001990850360031b1b16386113e356fea2646970667358221220945e30d3d9102d6dca25bfb255e19bf28568de9f0ef3a06cb41d1cab25810b1464736f6c63430008190033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "addSessionKey(address,(address,address,address,address,uint48,uint48,uint256,uint256,uint48,uint48))": {
        "details": "Adds a session key to the mapping."
      },
      "execute(address,uint256,address,uint256,bytes)": {
        "details": "Executes a transaction on behalf of a session.",
        "params": {
          "data": "The data to include with the transaction.",
          "sessionKey": "The session key associated with the transaction.",
          "to": "The address to which the transaction is being sent.",
          "value": "The amount of ether to send with the transaction."
        },
        "returns": {
          "_0": "The result of the transaction execution."
        }
      },
      "isInitialized(address)": {
        "details": "Returns if the module was already initialized for a provided smartaccount"
      },
      "onInstall(bytes)": {
        "details": "This function is called by the smart account during installation of the module",
        "params": {
          "data": "arbitrary data that may be required on the module during `onInstall` initialization MUST revert on error (i.e. if module is already enabled)"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 619,
        "contract": "contracts/AutoDCA/AutoDCASessionModule.sol:AutoDCASessionModule",
        "label": "sessionKeyList",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_array(t_address)dyn_storage)"
      },
      {
        "astId": 625,
        "contract": "contracts/AutoDCA/AutoDCASessionModule.sol:AutoDCASessionModule",
        "label": "sessionKeyData",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_array(t_struct(SessionData)646_storage)dyn_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_array(t_struct(SessionData)646_storage)dyn_storage": {
        "base": "t_struct(SessionData)646_storage",
        "encoding": "dynamic_array",
        "label": "struct AutoDCASessionModule.SessionData[]",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_array(t_address)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => address[])",
        "numberOfBytes": "32",
        "value": "t_array(t_address)dyn_storage"
      },
      "t_mapping(t_address,t_array(t_struct(SessionData)646_storage)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct AutoDCASessionModule.SessionData[])",
        "numberOfBytes": "32",
        "value": "t_array(t_struct(SessionData)646_storage)dyn_storage"
      },
      "t_struct(SessionData)646_storage": {
        "encoding": "inplace",
        "label": "struct AutoDCASessionModule.SessionData",
        "members": [
          {
            "astId": 627,
            "contract": "contracts/AutoDCA/AutoDCASessionModule.sol:AutoDCASessionModule",
            "label": "token",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 629,
            "contract": "contracts/AutoDCA/AutoDCASessionModule.sol:AutoDCASessionModule",
            "label": "targetToken",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 631,
            "contract": "contracts/AutoDCA/AutoDCASessionModule.sol:AutoDCASessionModule",
            "label": "vault",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          },
          {
            "astId": 633,
            "contract": "contracts/AutoDCA/AutoDCASessionModule.sol:AutoDCASessionModule",
            "label": "account",
            "offset": 0,
            "slot": "3",
            "type": "t_address"
          },
          {
            "astId": 635,
            "contract": "contracts/AutoDCA/AutoDCASessionModule.sol:AutoDCASessionModule",
            "label": "validAfter",
            "offset": 20,
            "slot": "3",
            "type": "t_uint48"
          },
          {
            "astId": 637,
            "contract": "contracts/AutoDCA/AutoDCASessionModule.sol:AutoDCASessionModule",
            "label": "validUntil",
            "offset": 26,
            "slot": "3",
            "type": "t_uint48"
          },
          {
            "astId": 639,
            "contract": "contracts/AutoDCA/AutoDCASessionModule.sol:AutoDCASessionModule",
            "label": "limitAmount",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 641,
            "contract": "contracts/AutoDCA/AutoDCASessionModule.sol:AutoDCASessionModule",
            "label": "limitUsed",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 643,
            "contract": "contracts/AutoDCA/AutoDCASessionModule.sol:AutoDCASessionModule",
            "label": "lastUsed",
            "offset": 0,
            "slot": "6",
            "type": "t_uint48"
          },
          {
            "astId": 645,
            "contract": "contracts/AutoDCA/AutoDCASessionModule.sol:AutoDCASessionModule",
            "label": "refreshInterval",
            "offset": 6,
            "slot": "6",
            "type": "t_uint48"
          }
        ],
        "numberOfBytes": "224"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint48": {
        "encoding": "inplace",
        "label": "uint48",
        "numberOfBytes": "6"
      }
    }
  }
}