{
  "address": "0xBFA149449A48E974E429fc27272b8EE8Cab4014F",
  "abi": [
    {
      "inputs": [],
      "name": "AccountAccessUnauthorized",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "AccountInitializationFailed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ExecutionFailed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "msgSig",
          "type": "bytes4"
        }
      ],
      "name": "FallbackInstalled",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "currentHook",
          "type": "address"
        }
      ],
      "name": "HookAlreadyInstalled",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "HookPostCheckFailed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InitializerError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "msgSig",
          "type": "bytes4"
        }
      ],
      "name": "InvalidFallbackHandler",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidHookType",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "safe",
          "type": "address"
        }
      ],
      "name": "InvalidInitData",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidInput",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "module",
          "type": "address"
        }
      ],
      "name": "InvalidModule",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LinkedListError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LinkedList_AlreadyInitialized",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LinkedList_AlreadyInitialized",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "entry",
          "type": "address"
        }
      ],
      "name": "LinkedList_EntryAlreadyInList",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "entry",
          "type": "address"
        }
      ],
      "name": "LinkedList_EntryAlreadyInList",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "entry",
          "type": "address"
        }
      ],
      "name": "LinkedList_InvalidEntry",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "entry",
          "type": "address"
        }
      ],
      "name": "LinkedList_InvalidEntry",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LinkedList_InvalidPage",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LinkedList_InvalidPage",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "msgSig",
          "type": "bytes4"
        }
      ],
      "name": "NoFallbackHandler",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "CallType",
          "name": "callType",
          "type": "bytes1"
        }
      ],
      "name": "UnsupportedCallType",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "ExecType",
          "name": "execType",
          "type": "bytes1"
        }
      ],
      "name": "UnsupportedExecType",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "moduleTypeId",
          "type": "uint256"
        }
      ],
      "name": "UnsupportedModuleType",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ValidatorStorageHelperError",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "smartAccount",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "contract IERC7484",
          "name": "registry",
          "type": "address"
        }
      ],
      "name": "ERC7484RegistryConfigured",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "moduleTypeId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "module",
          "type": "address"
        }
      ],
      "name": "ModuleInstalled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "moduleTypeId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "module",
          "type": "address"
        }
      ],
      "name": "ModuleUninstalled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "safe",
          "type": "address"
        }
      ],
      "name": "Safe7579Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "contract ISafe",
          "name": "safe",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "numberInBatch",
          "type": "uint256"
        }
      ],
      "name": "TryExecutionFailed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "contract ISafe",
          "name": "safe",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool[]",
          "name": "success",
          "type": "bool[]"
        }
      ],
      "name": "TryExecutionsFailed",
      "type": "event"
    },
    {
      "stateMutability": "payable",
      "type": "fallback"
    },
    {
      "inputs": [],
      "name": "accountId",
      "outputs": [
        {
          "internalType": "string",
          "name": "accountImplementationId",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "domainSeparator",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "entryPoint",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "ModeCode",
          "name": "mode",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "executionCalldata",
          "type": "bytes"
        }
      ],
      "name": "execute",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "ModeCode",
          "name": "mode",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "executionCalldata",
          "type": "bytes"
        }
      ],
      "name": "executeFromExecutor",
      "outputs": [
        {
          "internalType": "bytes[]",
          "name": "returnDatas",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getActiveHook",
      "outputs": [
        {
          "internalType": "address",
          "name": "hook",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "selector",
          "type": "bytes4"
        }
      ],
      "name": "getActiveHook",
      "outputs": [
        {
          "internalType": "address",
          "name": "hook",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "cursor",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "size",
          "type": "uint256"
        }
      ],
      "name": "getExecutorsPaginated",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "array",
          "type": "address[]"
        },
        {
          "internalType": "address",
          "name": "next",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "safe",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "validator",
          "type": "address"
        }
      ],
      "name": "getNonce",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "start",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "pageSize",
          "type": "uint256"
        }
      ],
      "name": "getValidatorPaginated",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "array",
          "type": "address[]"
        },
        {
          "internalType": "address",
          "name": "next",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "module",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "initData",
              "type": "bytes"
            }
          ],
          "internalType": "struct ModuleInit[]",
          "name": "validators",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "module",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "initData",
              "type": "bytes"
            }
          ],
          "internalType": "struct ModuleInit[]",
          "name": "executors",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "module",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "initData",
              "type": "bytes"
            }
          ],
          "internalType": "struct ModuleInit[]",
          "name": "fallbacks",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "module",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "initData",
              "type": "bytes"
            }
          ],
          "internalType": "struct ModuleInit[]",
          "name": "hooks",
          "type": "tuple[]"
        },
        {
          "components": [
            {
              "internalType": "contract IERC7484",
              "name": "registry",
              "type": "address"
            },
            {
              "internalType": "address[]",
              "name": "attesters",
              "type": "address[]"
            },
            {
              "internalType": "uint8",
              "name": "threshold",
              "type": "uint8"
            }
          ],
          "internalType": "struct RegistryInit",
          "name": "registryInit",
          "type": "tuple"
        }
      ],
      "name": "initializeAccount",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "moduleType",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "module",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "initData",
          "type": "bytes"
        }
      ],
      "name": "installModule",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "moduleType",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "module",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "additionalContext",
          "type": "bytes"
        }
      ],
      "name": "isModuleInstalled",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "hash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "isValidSignature",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "magicValue",
          "type": "bytes4"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "module",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "initData",
              "type": "bytes"
            }
          ],
          "internalType": "struct ModuleInit[]",
          "name": "validators",
          "type": "tuple[]"
        }
      ],
      "name": "launchpadValidators",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC7484",
          "name": "registry",
          "type": "address"
        },
        {
          "internalType": "address[]",
          "name": "attesters",
          "type": "address[]"
        },
        {
          "internalType": "uint8",
          "name": "threshold",
          "type": "uint8"
        }
      ],
      "name": "setRegistry",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "ModeCode",
          "name": "encodedMode",
          "type": "bytes32"
        }
      ],
      "name": "supportsExecutionMode",
      "outputs": [
        {
          "internalType": "bool",
          "name": "supported",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "moduleTypeId",
          "type": "uint256"
        }
      ],
      "name": "supportsModule",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "moduleType",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "module",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "deInitData",
          "type": "bytes"
        }
      ],
      "name": "uninstallModule",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "initCode",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callData",
              "type": "bytes"
            },
            {
              "internalType": "bytes32",
              "name": "accountGasLimits",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "preVerificationGas",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "gasFees",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "paymasterAndData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct PackedUserOperation",
          "name": "userOp",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "userOpHash",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "missingAccountFunds",
          "type": "uint256"
        }
      ],
      "name": "validateUserOp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "validSignature",
          "type": "uint256"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "193763c9aacc161dc5429461fa80bbab",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"AccountAccessUnauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AccountInitializationFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExecutionFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"msgSig\",\"type\":\"bytes4\"}],\"name\":\"FallbackInstalled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"currentHook\",\"type\":\"address\"}],\"name\":\"HookAlreadyInstalled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HookPostCheckFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InitializerError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"msgSig\",\"type\":\"bytes4\"}],\"name\":\"InvalidFallbackHandler\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidHookType\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"safe\",\"type\":\"address\"}],\"name\":\"InvalidInitData\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInput\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"InvalidModule\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LinkedListError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LinkedList_AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LinkedList_AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"entry\",\"type\":\"address\"}],\"name\":\"LinkedList_EntryAlreadyInList\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"entry\",\"type\":\"address\"}],\"name\":\"LinkedList_EntryAlreadyInList\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"entry\",\"type\":\"address\"}],\"name\":\"LinkedList_InvalidEntry\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"entry\",\"type\":\"address\"}],\"name\":\"LinkedList_InvalidEntry\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LinkedList_InvalidPage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LinkedList_InvalidPage\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"msgSig\",\"type\":\"bytes4\"}],\"name\":\"NoFallbackHandler\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"CallType\",\"name\":\"callType\",\"type\":\"bytes1\"}],\"name\":\"UnsupportedCallType\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"ExecType\",\"name\":\"execType\",\"type\":\"bytes1\"}],\"name\":\"UnsupportedExecType\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleTypeId\",\"type\":\"uint256\"}],\"name\":\"UnsupportedModuleType\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ValidatorStorageHelperError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"smartAccount\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC7484\",\"name\":\"registry\",\"type\":\"address\"}],\"name\":\"ERC7484RegistryConfigured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"moduleTypeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"ModuleInstalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"moduleTypeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"ModuleUninstalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"safe\",\"type\":\"address\"}],\"name\":\"Safe7579Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ISafe\",\"name\":\"safe\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numberInBatch\",\"type\":\"uint256\"}],\"name\":\"TryExecutionFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract ISafe\",\"name\":\"safe\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool[]\",\"name\":\"success\",\"type\":\"bool[]\"}],\"name\":\"TryExecutionsFailed\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"accountId\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"accountImplementationId\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entryPoint\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"ModeCode\",\"name\":\"mode\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"executionCalldata\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"ModeCode\",\"name\":\"mode\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"executionCalldata\",\"type\":\"bytes\"}],\"name\":\"executeFromExecutor\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"returnDatas\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActiveHook\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"hook\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"getActiveHook\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"hook\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cursor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getExecutorsPaginated\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"array\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"next\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"safe\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"start\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pageSize\",\"type\":\"uint256\"}],\"name\":\"getValidatorPaginated\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"array\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"next\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"initData\",\"type\":\"bytes\"}],\"internalType\":\"struct ModuleInit[]\",\"name\":\"validators\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"initData\",\"type\":\"bytes\"}],\"internalType\":\"struct ModuleInit[]\",\"name\":\"executors\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"initData\",\"type\":\"bytes\"}],\"internalType\":\"struct ModuleInit[]\",\"name\":\"fallbacks\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"initData\",\"type\":\"bytes\"}],\"internalType\":\"struct ModuleInit[]\",\"name\":\"hooks\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"contract IERC7484\",\"name\":\"registry\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"attesters\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"threshold\",\"type\":\"uint8\"}],\"internalType\":\"struct RegistryInit\",\"name\":\"registryInit\",\"type\":\"tuple\"}],\"name\":\"initializeAccount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"initData\",\"type\":\"bytes\"}],\"name\":\"installModule\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"additionalContext\",\"type\":\"bytes\"}],\"name\":\"isModuleInstalled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"magicValue\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"initData\",\"type\":\"bytes\"}],\"internalType\":\"struct ModuleInit[]\",\"name\":\"validators\",\"type\":\"tuple[]\"}],\"name\":\"launchpadValidators\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC7484\",\"name\":\"registry\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"attesters\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"threshold\",\"type\":\"uint8\"}],\"name\":\"setRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"ModeCode\",\"name\":\"encodedMode\",\"type\":\"bytes32\"}],\"name\":\"supportsExecutionMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"supported\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleTypeId\",\"type\":\"uint256\"}],\"name\":\"supportsModule\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"deInitData\",\"type\":\"bytes\"}],\"name\":\"uninstallModule\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"accountGasLimits\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"gasFees\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct PackedUserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"userOpHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"missingAccountFunds\",\"type\":\"uint256\"}],\"name\":\"validateUserOp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"validSignature\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"author\":\"rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\",\"details\":\"This contract is a Safe account implementation that supports ERC7579 operations.    In order to facilitate full ERC7579 compliance, the contract implements the IERC7579Account    interface. This contract is an implementation of a Safe account supporting ERC7579 operations and complying with the IERC7579Account interface. It serves as a Safe FallbackHandler and module for Safe accounts, incorporating complex hacks to ensure ERC7579 compliance and requiring interactions and event emissions to be done via the SafeProxy as msg.sender using Safe's \\\"executeTransactionFromModule\\\" features.\",\"kind\":\"dev\",\"methods\":{\"accountId()\":{\"details\":\"Returns the account id of the smart account\",\"returns\":{\"accountImplementationId\":\"the account id of the smart account the accountId should be structured like so:        \\\"vendorname.accountname.semver\\\"\"}},\"execute(bytes32,bytes)\":{\"details\":\"Executes a transaction on behalf of the Safe account.         This function is intended to be called by ERC-4337 EntryPoint.solIf a global hook and/or selector hook is set, it will be calledAccessControl: only Self of Entrypoint can install modules Safe7579 supports the following feature set:    CallTypes:             - CALLTYPE_SINGLE             - CALLTYPE_BATCH             - CALLTYPE_DELEGATECALL    ExecTypes:             - EXECTYPE_DEFAULT (revert if not successful)             - EXECTYPE_TRY    If a different mode is selected, this function will revert\",\"params\":{\"executionCalldata\":\"The encoded execution call data\",\"mode\":\"The encoded execution mode of the transaction. See ModeLib.sol for details\"}},\"executeFromExecutor(bytes32,bytes)\":{\"details\":\"Executes a transaction on behalf of the Safe account.         This function is intended to be called by executor modulesIf a global hook and/or selector hook is set, it will be calledAccessControl: only enabled executor modules Safe7579 supports the following feature set:    CallTypes:             - CALLTYPE_SINGLE             - CALLTYPE_BATCH             - CALLTYPE_DELEGATECALL    ExecTypes:             - EXECTYPE_DEFAULT (revert if not successful)             - EXECTYPE_TRY    If a different mode is selected, this function will revert\",\"params\":{\"executionCalldata\":\"The encoded execution call data\",\"mode\":\"The encoded execution mode of the transaction. See ModeLib.sol for details\"}},\"getNonce(address,address)\":{\"params\":{\"safe\":\"address of safe account\",\"validator\":\"ERC7579 validator to encode\"}},\"initializeAccount((address,bytes)[],(address,bytes)[],(address,bytes)[],(address,bytes)[],(address,address[],uint8))\":{\"params\":{\"executors\":\"executor modules and initData\",\"fallbacks\":\"fallback modules and initData\",\"hooks\":\"hook module and initData\",\"registryInit\":\"(OPTIONAL) registry, attesters and threshold for IERC7484 Registry                    If not provided, the registry will be set to the zero address, and no                    registry checks will be performed\",\"validators\":\"validator modules and initData\"}},\"installModule(uint256,address,bytes)\":{\"details\":\"The module has to be initialized from msg.sender == SafeProxy, we thus use a    delegatecall to DCUtil, which calls the onInstall/onUninstall function on the ERC7579    module and emits the ModuleInstall/ModuleUnintall eventsAccessControl: only Self of Entrypoint can install modulesIf the safe set a registry, ERC7484 registry will be queried before installingIf a global hook and/or selector hook is set, it will be called\",\"params\":{\"initData\":\"arbitrary data that may be required on the module during `onInstall` initialization.\",\"module\":\"the module address\",\"moduleType\":\"the module type ID according the ERC-7579 spec                   Note: MULTITYPE_MODULE (uint(0)) is a special type to install a module with                         multiple types\"}},\"isModuleInstalled(uint256,address,bytes)\":{\"params\":{\"additionalContext\":\"additional context data that the smart account may interpret to                          identifiy conditions under which the module is installed.                          usually this is not necessary, but for some special hooks that                          are stored in mappings, this param might be needed\",\"module\":\"the module address\",\"moduleType\":\"the module type ID according the ERC-7579 spec      Note: keep in mind that some contracts can be multiple module types at the same time. It            thus may be necessary to query multiple module types\"}},\"isValidSignature(bytes32,bytes)\":{\"params\":{\"data\":\"abi.encodePacked(address validationModule, bytes signatures)\",\"hash\":\"message hash of ERC1271 request\"}},\"launchpadValidators((address,bytes)[])\":{\"details\":\"it will initialize the SentinelList4337 list for validators, and sstore all validatorsSince this function has to be 4337 compliant (storage access), only validator storage is  acccessNote: this function DOES NOT call onInstall() on the validator modules or emit ModuleInstalled events. this has to be done by the launchpad\"},\"supportsExecutionMode(bytes32)\":{\"params\":{\"encodedMode\":\"the encoded mode\"}},\"supportsModule(uint256)\":{\"params\":{\"moduleTypeId\":\"the module type ID according the ERC-7579 spec\"}},\"uninstallModule(uint256,address,bytes)\":{\"details\":\"The module has to be initialized from msg.sender == SafeProxy, we thus use a    delegatecall to DCUtil, which calls the onInstall/onUninstall function on the ERC7579    module and emits the ModuleInstall/ModuleUnintall eventsAccessControl: only Self of Entrypoint can install modulesIf a global hook and/or selector hook is set, it will be called\",\"params\":{\"deInitData\":\"arbitrary data that may be required on the module during `onUninstall` de-initialization.\",\"module\":\"the module address\",\"moduleType\":\"the module type ID according the ERC-7579 spec\"}},\"validateUserOp((address,uint256,bytes,bytes,bytes32,uint256,bytes32,bytes,bytes),bytes32,uint256)\":{\"details\":\"expects that a ERC7579 validator module is encoded within the UserOp nonce.         if no validator module is provided, it will fallback to validate the transaction with         Safe's signers\"}},\"title\":\"ERC7579 Adapter for Safe accounts. creates full ERC7579 compliance to Safe accounts\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"domainSeparator()\":{\"notice\":\"Domain Separator for EIP-712.\"},\"getNonce(address,address)\":{\"notice\":\"Safe7579 is using validator selection encoding in the userop nonce. to make it easier for SDKs / devs to integrate, this function can be called to get the next nonce for a specific validator\"},\"getValidatorPaginated(address,uint256)\":{\"notice\":\"Get paginated list of installed validators\"},\"initializeAccount((address,bytes)[],(address,bytes)[],(address,bytes)[],(address,bytes)[],(address,address[],uint8))\":{\"notice\":\"This function can be called by the Launchpad.initSafe7579() or by already existing Safes that want to use Safe7579 if this is called by the Launchpad, it is expected that launchpadValidators() was called previously, and the param validators is empty\"},\"installModule(uint256,address,bytes)\":{\"notice\":\"Installs a 7579 Module of a certain type on the smart account\"},\"isModuleInstalled(uint256,address,bytes)\":{\"notice\":\"Function to check if the account has a certain module installed\"},\"isValidSignature(bytes32,bytes)\":{\"notice\":\"Will use Safe's signed messages or checkSignatures features or ERC7579 validation modules if no signature is provided, it makes use of Safe's signedMessages if address(0) or a non-installed validator module is provided, it will use Safe's checkSignatures if a valid validator module is provided, it will use the module's validateUserOp function\"},\"launchpadValidators((address,bytes)[])\":{\"notice\":\"This function is intended to be called by Launchpad.validateUserOp()\"},\"setRegistry(address,address[],uint8)\":{\"notice\":\"TODO:\"},\"supportsExecutionMode(bytes32)\":{\"notice\":\"Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\"},\"supportsModule(uint256)\":{\"notice\":\"Function to check if the account supports installation of a certain module type Id\"},\"uninstallModule(uint256,address,bytes)\":{\"notice\":\"Uninstalls a Module of a certain type on the smart account.\"},\"validateUserOp((address,uint256,bytes,bytes,bytes32,uint256,bytes32,bytes,bytes),bytes32,uint256)\":{\"notice\":\"ERC4337 v0.7 validation function\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/safe7579/Safe7579.sol\":\"Safe7579\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@account-abstraction/contracts/core/Helpers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable no-inline-assembly */\\n\\n\\n /*\\n  * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\\n  * must return this value in case of signature failure, instead of revert.\\n  */\\nuint256 constant SIG_VALIDATION_FAILED = 1;\\n\\n\\n/*\\n * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\\n * return this value on success.\\n */\\nuint256 constant SIG_VALIDATION_SUCCESS = 0;\\n\\n\\n/**\\n * Returned data from validateUserOp.\\n * validateUserOp returns a uint256, which is created by `_packedValidationData` and\\n * parsed by `_parseValidationData`.\\n * @param aggregator  - address(0) - The account validated the signature by itself.\\n *                      address(1) - The account failed to validate the signature.\\n *                      otherwise - This is an address of a signature aggregator that must\\n *                                  be used to validate the signature.\\n * @param validAfter  - This UserOp is valid only after this timestamp.\\n * @param validaUntil - This UserOp is valid only up to this timestamp.\\n */\\nstruct ValidationData {\\n    address aggregator;\\n    uint48 validAfter;\\n    uint48 validUntil;\\n}\\n\\n/**\\n * Extract sigFailed, validAfter, validUntil.\\n * Also convert zero validUntil to type(uint48).max.\\n * @param validationData - The packed validation data.\\n */\\nfunction _parseValidationData(\\n    uint256 validationData\\n) pure returns (ValidationData memory data) {\\n    address aggregator = address(uint160(validationData));\\n    uint48 validUntil = uint48(validationData >> 160);\\n    if (validUntil == 0) {\\n        validUntil = type(uint48).max;\\n    }\\n    uint48 validAfter = uint48(validationData >> (48 + 160));\\n    return ValidationData(aggregator, validAfter, validUntil);\\n}\\n\\n/**\\n * Helper to pack the return value for validateUserOp.\\n * @param data - The ValidationData to pack.\\n */\\nfunction _packValidationData(\\n    ValidationData memory data\\n) pure returns (uint256) {\\n    return\\n        uint160(data.aggregator) |\\n        (uint256(data.validUntil) << 160) |\\n        (uint256(data.validAfter) << (160 + 48));\\n}\\n\\n/**\\n * Helper to pack the return value for validateUserOp, when not using an aggregator.\\n * @param sigFailed  - True for signature failure, false for success.\\n * @param validUntil - Last timestamp this UserOperation is valid (or zero for infinite).\\n * @param validAfter - First timestamp this UserOperation is valid.\\n */\\nfunction _packValidationData(\\n    bool sigFailed,\\n    uint48 validUntil,\\n    uint48 validAfter\\n) pure returns (uint256) {\\n    return\\n        (sigFailed ? 1 : 0) |\\n        (uint256(validUntil) << 160) |\\n        (uint256(validAfter) << (160 + 48));\\n}\\n\\n/**\\n * keccak function over calldata.\\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\\n */\\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\\n        assembly (\\\"memory-safe\\\") {\\n            let mem := mload(0x40)\\n            let len := data.length\\n            calldatacopy(mem, data.offset, len)\\n            ret := keccak256(mem, len)\\n        }\\n    }\\n\\n\\n/**\\n * The minimum of two numbers.\\n * @param a - First number.\\n * @param b - Second number.\\n */\\n    function min(uint256 a, uint256 b) pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\",\"keccak256\":\"0x6247e011a6cb0b263b3aa098822977181674d91b62e5bdfe04c6e66f72da25d6\",\"license\":\"GPL-3.0\"},\"@account-abstraction/contracts/core/UserOperationLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable no-inline-assembly */\\n\\nimport \\\"../interfaces/PackedUserOperation.sol\\\";\\nimport {calldataKeccak, min} from \\\"./Helpers.sol\\\";\\n\\n/**\\n * Utility functions helpful when working with UserOperation structs.\\n */\\nlibrary UserOperationLib {\\n\\n    uint256 public constant PAYMASTER_VALIDATION_GAS_OFFSET = 20;\\n    uint256 public constant PAYMASTER_POSTOP_GAS_OFFSET = 36;\\n    uint256 public constant PAYMASTER_DATA_OFFSET = 52;\\n    /**\\n     * Get sender from user operation data.\\n     * @param userOp - The user operation data.\\n     */\\n    function getSender(\\n        PackedUserOperation calldata userOp\\n    ) internal pure returns (address) {\\n        address data;\\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\\n        assembly {\\n            data := calldataload(userOp)\\n        }\\n        return address(uint160(data));\\n    }\\n\\n    /**\\n     * Relayer/block builder might submit the TX with higher priorityFee,\\n     * but the user should not pay above what he signed for.\\n     * @param userOp - The user operation data.\\n     */\\n    function gasPrice(\\n        PackedUserOperation calldata userOp\\n    ) internal view returns (uint256) {\\n        unchecked {\\n            (uint256 maxPriorityFeePerGas, uint256 maxFeePerGas) = unpackUints(userOp.gasFees);\\n            if (maxFeePerGas == maxPriorityFeePerGas) {\\n                //legacy mode (for networks that don't support basefee opcode)\\n                return maxFeePerGas;\\n            }\\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\\n        }\\n    }\\n\\n    /**\\n     * Pack the user operation data into bytes for hashing.\\n     * @param userOp - The user operation data.\\n     */\\n    function encode(\\n        PackedUserOperation calldata userOp\\n    ) internal pure returns (bytes memory ret) {\\n        address sender = getSender(userOp);\\n        uint256 nonce = userOp.nonce;\\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\\n        bytes32 accountGasLimits = userOp.accountGasLimits;\\n        uint256 preVerificationGas = userOp.preVerificationGas;\\n        bytes32 gasFees = userOp.gasFees;\\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\\n\\n        return abi.encode(\\n            sender, nonce,\\n            hashInitCode, hashCallData,\\n            accountGasLimits, preVerificationGas, gasFees,\\n            hashPaymasterAndData\\n        );\\n    }\\n\\n    function unpackUints(\\n        bytes32 packed\\n    ) internal pure returns (uint256 high128, uint256 low128) {\\n        return (uint128(bytes16(packed)), uint128(uint256(packed)));\\n    }\\n\\n    //unpack just the high 128-bits from a packed value\\n    function unpackHigh128(bytes32 packed) internal pure returns (uint256) {\\n        return uint256(packed) >> 128;\\n    }\\n\\n    // unpack just the low 128-bits from a packed value\\n    function unpackLow128(bytes32 packed) internal pure returns (uint256) {\\n        return uint128(uint256(packed));\\n    }\\n\\n    function unpackMaxPriorityFeePerGas(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackHigh128(userOp.gasFees);\\n    }\\n\\n    function unpackMaxFeePerGas(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackLow128(userOp.gasFees);\\n    }\\n\\n    function unpackVerificationGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackHigh128(userOp.accountGasLimits);\\n    }\\n\\n    function unpackCallGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackLow128(userOp.accountGasLimits);\\n    }\\n\\n    function unpackPaymasterVerificationGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET]));\\n    }\\n\\n    function unpackPostOpGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]));\\n    }\\n\\n    function unpackPaymasterStaticFields(\\n        bytes calldata paymasterAndData\\n    ) internal pure returns (address paymaster, uint256 validationGasLimit, uint256 postOpGasLimit) {\\n        return (\\n            address(bytes20(paymasterAndData[: PAYMASTER_VALIDATION_GAS_OFFSET])),\\n            uint128(bytes16(paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET])),\\n            uint128(bytes16(paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]))\\n        );\\n    }\\n\\n    /**\\n     * Hash the user operation data.\\n     * @param userOp - The user operation data.\\n     */\\n    function hash(\\n        PackedUserOperation calldata userOp\\n    ) internal pure returns (bytes32) {\\n        return keccak256(encode(userOp));\\n    }\\n}\\n\",\"keccak256\":\"0x9d50ece985d35f82e33e5da417595c86fac10449e3d10895d08363d33aad454b\",\"license\":\"GPL-3.0\"},\"@account-abstraction/contracts/interfaces/IAggregator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.7.5;\\n\\nimport \\\"./PackedUserOperation.sol\\\";\\n\\n/**\\n * Aggregated Signatures validator.\\n */\\ninterface IAggregator {\\n    /**\\n     * Validate aggregated signature.\\n     * Revert if the aggregated signature does not match the given list of operations.\\n     * @param userOps   - Array of UserOperations to validate the signature for.\\n     * @param signature - The aggregated signature.\\n     */\\n    function validateSignatures(\\n        PackedUserOperation[] calldata userOps,\\n        bytes calldata signature\\n    ) external view;\\n\\n    /**\\n     * Validate signature of a single userOp.\\n     * This method should be called by bundler after EntryPointSimulation.simulateValidation() returns\\n     * the aggregator this account uses.\\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\\n     * @param userOp        - The userOperation received from the user.\\n     * @return sigForUserOp - The value to put into the signature field of the userOp when calling handleOps.\\n     *                        (usually empty, unless account and aggregator support some kind of \\\"multisig\\\".\\n     */\\n    function validateUserOpSignature(\\n        PackedUserOperation calldata userOp\\n    ) external view returns (bytes memory sigForUserOp);\\n\\n    /**\\n     * Aggregate multiple signatures into a single value.\\n     * This method is called off-chain to calculate the signature to pass with handleOps()\\n     * bundler MAY use optimized custom code perform this aggregation.\\n     * @param userOps              - Array of UserOperations to collect the signatures from.\\n     * @return aggregatedSignature - The aggregated signature.\\n     */\\n    function aggregateSignatures(\\n        PackedUserOperation[] calldata userOps\\n    ) external view returns (bytes memory aggregatedSignature);\\n}\\n\",\"keccak256\":\"0xf100d6fcc0c3b450b13e979b6a42c628c292a1bc340eccc2e7796b80e3975588\",\"license\":\"GPL-3.0\"},\"@account-abstraction/contracts/interfaces/IEntryPoint.sol\":{\"content\":\"/**\\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\\n ** Only one instance required on each chain.\\n **/\\n// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.7.5;\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable no-inline-assembly */\\n/* solhint-disable reason-string */\\n\\nimport \\\"./PackedUserOperation.sol\\\";\\nimport \\\"./IStakeManager.sol\\\";\\nimport \\\"./IAggregator.sol\\\";\\nimport \\\"./INonceManager.sol\\\";\\n\\ninterface IEntryPoint is IStakeManager, INonceManager {\\n    /***\\n     * An event emitted after each successful request.\\n     * @param userOpHash    - Unique identifier for the request (hash its entire content, except signature).\\n     * @param sender        - The account that generates this request.\\n     * @param paymaster     - If non-null, the paymaster that pays for this request.\\n     * @param nonce         - The nonce value from the request.\\n     * @param success       - True if the sender transaction succeeded, false if reverted.\\n     * @param actualGasCost - Actual amount paid (by account or paymaster) for this UserOperation.\\n     * @param actualGasUsed - Total gas used by this UserOperation (including preVerification, creation,\\n     *                        validation and execution).\\n     */\\n    event UserOperationEvent(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        address indexed paymaster,\\n        uint256 nonce,\\n        bool success,\\n        uint256 actualGasCost,\\n        uint256 actualGasUsed\\n    );\\n\\n    /**\\n     * Account \\\"sender\\\" was deployed.\\n     * @param userOpHash - The userOp that deployed this account. UserOperationEvent will follow.\\n     * @param sender     - The account that is deployed\\n     * @param factory    - The factory used to deploy this account (in the initCode)\\n     * @param paymaster  - The paymaster used by this UserOp\\n     */\\n    event AccountDeployed(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        address factory,\\n        address paymaster\\n    );\\n\\n    /**\\n     * An event emitted if the UserOperation \\\"callData\\\" reverted with non-zero length.\\n     * @param userOpHash   - The request unique identifier.\\n     * @param sender       - The sender of this request.\\n     * @param nonce        - The nonce used in the request.\\n     * @param revertReason - The return bytes from the (reverted) call to \\\"callData\\\".\\n     */\\n    event UserOperationRevertReason(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        uint256 nonce,\\n        bytes revertReason\\n    );\\n\\n    /**\\n     * An event emitted if the UserOperation Paymaster's \\\"postOp\\\" call reverted with non-zero length.\\n     * @param userOpHash   - The request unique identifier.\\n     * @param sender       - The sender of this request.\\n     * @param nonce        - The nonce used in the request.\\n     * @param revertReason - The return bytes from the (reverted) call to \\\"callData\\\".\\n     */\\n    event PostOpRevertReason(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        uint256 nonce,\\n        bytes revertReason\\n    );\\n\\n    /**\\n     * UserOp consumed more than prefund. The UserOperation is reverted, and no refund is made.\\n     * @param userOpHash   - The request unique identifier.\\n     * @param sender       - The sender of this request.\\n     * @param nonce        - The nonce used in the request.\\n     */\\n    event UserOperationPrefundTooLow(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        uint256 nonce\\n    );\\n\\n    /**\\n     * An event emitted by handleOps(), before starting the execution loop.\\n     * Any event emitted before this event, is part of the validation.\\n     */\\n    event BeforeExecution();\\n\\n    /**\\n     * Signature aggregator used by the following UserOperationEvents within this bundle.\\n     * @param aggregator - The aggregator used for the following UserOperationEvents.\\n     */\\n    event SignatureAggregatorChanged(address indexed aggregator);\\n\\n    /**\\n     * A custom revert error of handleOps, to identify the offending op.\\n     * Should be caught in off-chain handleOps simulation and not happen on-chain.\\n     * Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\\n     * NOTE: If simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\\n     * @param reason  - Revert reason. The string starts with a unique code \\\"AAmn\\\",\\n     *                  where \\\"m\\\" is \\\"1\\\" for factory, \\\"2\\\" for account and \\\"3\\\" for paymaster issues,\\n     *                  so a failure can be attributed to the correct entity.\\n     */\\n    error FailedOp(uint256 opIndex, string reason);\\n\\n    /**\\n     * A custom revert error of handleOps, to report a revert by account or paymaster.\\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\\n     * @param reason  - Revert reason. see FailedOp(uint256,string), above\\n     * @param inner   - data from inner cought revert reason\\n     * @dev note that inner is truncated to 2048 bytes\\n     */\\n    error FailedOpWithRevert(uint256 opIndex, string reason, bytes inner);\\n\\n    error PostOpReverted(bytes returnData);\\n\\n    /**\\n     * Error case when a signature aggregator fails to verify the aggregated signature it had created.\\n     * @param aggregator The aggregator that failed to verify the signature\\n     */\\n    error SignatureValidationFailed(address aggregator);\\n\\n    // Return value of getSenderAddress.\\n    error SenderAddressResult(address sender);\\n\\n    // UserOps handled, per aggregator.\\n    struct UserOpsPerAggregator {\\n        PackedUserOperation[] userOps;\\n        // Aggregator address\\n        IAggregator aggregator;\\n        // Aggregated signature\\n        bytes signature;\\n    }\\n\\n    /**\\n     * Execute a batch of UserOperations.\\n     * No signature aggregator is used.\\n     * If any account requires an aggregator (that is, it returned an aggregator when\\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\\n     * @param ops         - The operations to execute.\\n     * @param beneficiary - The address to receive the fees.\\n     */\\n    function handleOps(\\n        PackedUserOperation[] calldata ops,\\n        address payable beneficiary\\n    ) external;\\n\\n    /**\\n     * Execute a batch of UserOperation with Aggregators\\n     * @param opsPerAggregator - The operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts).\\n     * @param beneficiary      - The address to receive the fees.\\n     */\\n    function handleAggregatedOps(\\n        UserOpsPerAggregator[] calldata opsPerAggregator,\\n        address payable beneficiary\\n    ) external;\\n\\n    /**\\n     * Generate a request Id - unique identifier for this request.\\n     * The request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\\n     * @param userOp - The user operation to generate the request ID for.\\n     * @return hash the hash of this UserOperation\\n     */\\n    function getUserOpHash(\\n        PackedUserOperation calldata userOp\\n    ) external view returns (bytes32);\\n\\n    /**\\n     * Gas and return values during simulation.\\n     * @param preOpGas         - The gas used for validation (including preValidationGas)\\n     * @param prefund          - The required prefund for this operation\\n     * @param accountValidationData   - returned validationData from account.\\n     * @param paymasterValidationData - return validationData from paymaster.\\n     * @param paymasterContext - Returned by validatePaymasterUserOp (to be passed into postOp)\\n     */\\n    struct ReturnInfo {\\n        uint256 preOpGas;\\n        uint256 prefund;\\n        uint256 accountValidationData;\\n        uint256 paymasterValidationData;\\n        bytes paymasterContext;\\n    }\\n\\n    /**\\n     * Returned aggregated signature info:\\n     * The aggregator returned by the account, and its current stake.\\n     */\\n    struct AggregatorStakeInfo {\\n        address aggregator;\\n        StakeInfo stakeInfo;\\n    }\\n\\n    /**\\n     * Get counterfactual sender address.\\n     * Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\\n     * This method always revert, and returns the address in SenderAddressResult error\\n     * @param initCode - The constructor code to be passed into the UserOperation.\\n     */\\n    function getSenderAddress(bytes memory initCode) external;\\n\\n    error DelegateAndRevert(bool success, bytes ret);\\n\\n    /**\\n     * Helper method for dry-run testing.\\n     * @dev calling this method, the EntryPoint will make a delegatecall to the given data, and report (via revert) the result.\\n     *  The method always revert, so is only useful off-chain for dry run calls, in cases where state-override to replace\\n     *  actual EntryPoint code is less convenient.\\n     * @param target a target contract to make a delegatecall from entrypoint\\n     * @param data data to pass to target in a delegatecall\\n     */\\n    function delegateAndRevert(address target, bytes calldata data) external;\\n}\\n\",\"keccak256\":\"0x1972a5fcb3a808b58c85af5741949ef6af11ab0debd3ae8c708171ae1ae0d0c4\",\"license\":\"GPL-3.0\"},\"@account-abstraction/contracts/interfaces/INonceManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface INonceManager {\\n\\n    /**\\n     * Return the next nonce for this sender.\\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\\n     * But UserOp with different keys can come with arbitrary order.\\n     *\\n     * @param sender the account address\\n     * @param key the high 192 bit of the nonce\\n     * @return nonce a full nonce to pass for next UserOp with this sender.\\n     */\\n    function getNonce(address sender, uint192 key)\\n    external view returns (uint256 nonce);\\n\\n    /**\\n     * Manually increment the nonce of the sender.\\n     * This method is exposed just for completeness..\\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\\n     * as the EntryPoint will update the nonce regardless.\\n     * Possible use-case is call it with various keys to \\\"initialize\\\" their nonces to one, so that future\\n     * UserOperations will not pay extra for the first transaction with a given key.\\n     */\\n    function incrementNonce(uint192 key) external;\\n}\\n\",\"keccak256\":\"0xd575af0f6ebbd5f0b2933307d44cd7b4e03a69f4b817a67db5409bd3c89aeecb\",\"license\":\"GPL-3.0\"},\"@account-abstraction/contracts/interfaces/IStakeManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity >=0.7.5;\\n\\n/**\\n * Manage deposits and stakes.\\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\\n * Stake is value locked for at least \\\"unstakeDelay\\\" by the staked entity.\\n */\\ninterface IStakeManager {\\n    event Deposited(address indexed account, uint256 totalDeposit);\\n\\n    event Withdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    // Emitted when stake or unstake delay are modified.\\n    event StakeLocked(\\n        address indexed account,\\n        uint256 totalStaked,\\n        uint256 unstakeDelaySec\\n    );\\n\\n    // Emitted once a stake is scheduled for withdrawal.\\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\\n\\n    event StakeWithdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @param deposit         - The entity's deposit.\\n     * @param staked          - True if this entity is staked.\\n     * @param stake           - Actual amount of ether staked for this entity.\\n     * @param unstakeDelaySec - Minimum delay to withdraw the stake.\\n     * @param withdrawTime    - First block timestamp where 'withdrawStake' will be callable, or zero if already locked.\\n     * @dev Sizes were chosen so that deposit fits into one cell (used during handleOp)\\n     *      and the rest fit into a 2nd cell (used during stake/unstake)\\n     *      - 112 bit allows for 10^15 eth\\n     *      - 48 bit for full timestamp\\n     *      - 32 bit allows 150 years for unstake delay\\n     */\\n    struct DepositInfo {\\n        uint256 deposit;\\n        bool staked;\\n        uint112 stake;\\n        uint32 unstakeDelaySec;\\n        uint48 withdrawTime;\\n    }\\n\\n    // API struct used by getStakeInfo and simulateValidation.\\n    struct StakeInfo {\\n        uint256 stake;\\n        uint256 unstakeDelaySec;\\n    }\\n\\n    /**\\n     * Get deposit info.\\n     * @param account - The account to query.\\n     * @return info   - Full deposit information of given account.\\n     */\\n    function getDepositInfo(\\n        address account\\n    ) external view returns (DepositInfo memory info);\\n\\n    /**\\n     * Get account balance.\\n     * @param account - The account to query.\\n     * @return        - The deposit (for gas payment) of the account.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * Add to the deposit of the given account.\\n     * @param account - The account to add to.\\n     */\\n    function depositTo(address account) external payable;\\n\\n    /**\\n     * Add to the account's stake - amount and delay\\n     * any pending unstake is first cancelled.\\n     * @param _unstakeDelaySec - The new lock duration before the deposit can be withdrawn.\\n     */\\n    function addStake(uint32 _unstakeDelaySec) external payable;\\n\\n    /**\\n     * Attempt to unlock the stake.\\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\\n     */\\n    function unlockStake() external;\\n\\n    /**\\n     * Withdraw from the (unlocked) stake.\\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\\n     * @param withdrawAddress - The address to send withdrawn value.\\n     */\\n    function withdrawStake(address payable withdrawAddress) external;\\n\\n    /**\\n     * Withdraw from the deposit.\\n     * @param withdrawAddress - The address to send withdrawn value.\\n     * @param withdrawAmount  - The amount to withdraw.\\n     */\\n    function withdrawTo(\\n        address payable withdrawAddress,\\n        uint256 withdrawAmount\\n    ) external;\\n}\\n\",\"keccak256\":\"0xbe5ca9e7f254d031687419e7b96ef48c9c63e9398bbe992dc72ffc6dc14e0a04\",\"license\":\"GPL-3.0-only\"},\"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.7.5;\\n\\n/**\\n * User Operation struct\\n * @param sender                - The sender account of this request.\\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\\n * @param initCode              - If set, the account contract will be created by this constructor/\\n * @param callData              - The method call to execute on this account.\\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\\n *                                Covers batch overhead.\\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\\n *                                The paymaster will pay for the transaction instead of the sender.\\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n */\\nstruct PackedUserOperation {\\n    address sender;\\n    uint256 nonce;\\n    bytes initCode;\\n    bytes callData;\\n    bytes32 accountGasLimits;\\n    uint256 preVerificationGas;\\n    bytes32 gasFees;\\n    bytes paymasterAndData;\\n    bytes signature;\\n}\\n\",\"keccak256\":\"0x1129b46381db68eddbc5cb49e50664667b66b03c480453858e7b25eabe444359\",\"license\":\"GPL-3.0\"},\"@safe-global/safe-contracts/contracts/handler/HandlerContext.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/**\\n * @title Handler Context - Allows the fallback handler to extract addition context from the calldata\\n * @dev The fallback manager appends the following context to the calldata:\\n *      1. Fallback manager caller address (non-padded)\\n * based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/f8cc8b844a9f92f63dc55aa581f7d643a1bc5ac1/contracts/metatx/ERC2771Context.sol\\n * @author Richard Meissner - @rmeissner\\n */\\nabstract contract HandlerContext {\\n    /**\\n     * @notice Allows fetching the original caller address.\\n     * @dev This is only reliable in combination with a FallbackManager that supports this (e.g. Safe contract >=1.3.0).\\n     *      When using this functionality make sure that the linked _manager (aka msg.sender) supports this.\\n     *      This function does not rely on a trusted forwarder. Use the returned value only to\\n     *      check information against the calling manager.\\n     * @return sender Original caller address.\\n     */\\n    function _msgSender() internal pure returns (address sender) {\\n        // The assembly code is more direct than the Solidity version using `abi.decode`.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the FallbackManager address\\n     * @return Fallback manager address\\n     */\\n    function _manager() internal view returns (address) {\\n        return msg.sender;\\n    }\\n}\\n\",\"keccak256\":\"0xce6da4c47f8691a4fcf07d20266b1a23ea757e49eedbfcf929f535f3f6e8072d\",\"license\":\"LGPL-3.0-only\"},\"account-abstraction/interfaces/PackedUserOperation.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.7.5;\\n\\n/**\\n * User Operation struct\\n * @param sender                - The sender account of this request.\\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\\n * @param initCode              - If set, the account contract will be created by this constructor/\\n * @param callData              - The method call to execute on this account.\\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\\n *                                Covers batch overhead.\\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\\n *                                The paymaster will pay for the transaction instead of the sender.\\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n */\\nstruct PackedUserOperation {\\n    address sender;\\n    uint256 nonce;\\n    bytes initCode;\\n    bytes callData;\\n    bytes32 accountGasLimits;\\n    uint256 preVerificationGas;\\n    bytes32 gasFees;\\n    bytes paymasterAndData;\\n    bytes signature;\\n}\\n\",\"keccak256\":\"0x1129b46381db68eddbc5cb49e50664667b66b03c480453858e7b25eabe444359\",\"license\":\"GPL-3.0\"},\"contracts/safe7579/DataTypes.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.23;\\n\\nimport { IERC7484 } from \\\"./interfaces/IERC7484.sol\\\";\\nimport { CallType } from \\\"./lib/ModeLib.sol\\\";\\n\\nstruct FallbackHandler {\\n    address handler;\\n    CallType calltype;\\n}\\n\\nenum HookType {\\n    GLOBAL,\\n    SIG\\n}\\n\\nstruct ModuleInit {\\n    address module;\\n    bytes initData;\\n}\\n\\nstruct RegistryInit {\\n    IERC7484 registry;\\n    address[] attesters;\\n    uint8 threshold;\\n}\\n\",\"keccak256\":\"0x26103aa6183fc45f12d994931c2b1cac29ec20a09bcb466fc85bf835e8004719\",\"license\":\"GPL-3.0\"},\"contracts/safe7579/ISafe7579.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport \\\"./DataTypes.sol\\\";\\nimport { IERC7579Account } from \\\"./interfaces/IERC7579Account.sol\\\";\\n\\nimport { CallType, ExecType, ModeCode } from \\\"./lib/ModeLib.sol\\\";\\nimport { PackedUserOperation } from\\n    \\\"@account-abstraction/contracts/core/UserOperationLib.sol\\\";\\n\\n/**\\n * @title ERC7579 Adapter for Safe accounts.\\n * creates full ERC7579 compliance to Safe accounts\\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\\n */\\ninterface ISafe7579 is IERC7579Account {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         Validation                         */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /**\\n     * ERC4337 v0.7 validation function\\n     * @dev expects that a ERC7579 validator module is encoded within the UserOp nonce.\\n     *         if no validator module is provided, it will fallback to validate the transaction with\\n     *         Safe's signers\\n     */\\n    function validateUserOp(\\n        PackedUserOperation memory userOp,\\n        bytes32 userOpHash,\\n        uint256 missingAccountFunds\\n    )\\n        external\\n        payable\\n        returns (uint256 packedValidSig);\\n\\n    /**\\n     * Will use Safe's signed messages or checkSignatures features or ERC7579 validation modules\\n     * if no signature is provided, it makes use of Safe's signedMessages\\n     * if address(0) or a non-installed validator module is provided, it will use Safe's\\n     * checkSignatures\\n     * if a valid validator module is provided, it will use the module's validateUserOp function\\n     *    @param hash message hash of ERC1271 request\\n     *    @param data abi.encodePacked(address validationModule, bytes signatures)\\n     */\\n    function isValidSignature(\\n        bytes32 hash,\\n        bytes memory data\\n    )\\n        external\\n        view\\n        returns (bytes4 magicValue);\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         Executions                         */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /**\\n     * @dev Executes a transaction on behalf of the Safe account.\\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\\n     * @dev If a global hook and/or selector hook is set, it will be called\\n     * @dev AccessControl: only Self of Entrypoint can install modules\\n     * Safe7579 supports the following feature set:\\n     *    CallTypes:\\n     *             - CALLTYPE_SINGLE\\n     *             - CALLTYPE_BATCH\\n     *             - CALLTYPE_DELEGATECALL\\n     *    ExecTypes:\\n     *             - EXECTYPE_DEFAULT (revert if not successful)\\n     *             - EXECTYPE_TRY\\n     *    If a different mode is selected, this function will revert\\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\\n     * @param executionCalldata The encoded execution call data\\n     */\\n    function execute(ModeCode mode, bytes memory executionCalldata) external payable;\\n\\n    /**\\n     * @dev Executes a transaction on behalf of the Safe account.\\n     *         This function is intended to be called by executor modules\\n     * @dev If a global hook and/or selector hook is set, it will be called\\n     * @dev AccessControl: only enabled executor modules\\n     * Safe7579 supports the following feature set:\\n     *    CallTypes:\\n     *             - CALLTYPE_SINGLE\\n     *             - CALLTYPE_BATCH\\n     *             - CALLTYPE_DELEGATECALL\\n     *    ExecTypes:\\n     *             - EXECTYPE_DEFAULT (revert if not successful)\\n     *             - EXECTYPE_TRY\\n     *    If a different mode is selected, this function will revert\\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\\n     * @param executionCalldata The encoded execution call data\\n     */\\n    function executeFromExecutor(\\n        ModeCode mode,\\n        bytes memory executionCalldata\\n    )\\n        external\\n        payable\\n        returns (bytes[] memory returnDatas);\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      Manage Modules                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /**\\n     * Installs a 7579 Module of a certain type on the smart account\\n     * @dev The module has to be initialized from msg.sender == SafeProxy, we thus use a\\n     *    delegatecall to DCUtil, which calls the onInstall/onUninstall function on the ERC7579\\n     *    module and emits the ModuleInstall/ModuleUnintall events\\n     * @dev AccessControl: only Self of Entrypoint can install modules\\n     * @dev If the safe set a registry, ERC7484 registry will be queried before installing\\n     * @dev If a global hook and/or selector hook is set, it will be called\\n     * @param moduleType the module type ID according the ERC-7579 spec\\n     *                   Note: MULTITYPE_MODULE (uint(0)) is a special type to install a module with\\n     *                         multiple types\\n     * @param module the module address\\n     * @param initData arbitrary data that may be required on the module during `onInstall`\\n     * initialization.\\n     */\\n    function installModule(\\n        uint256 moduleType,\\n        address module,\\n        bytes memory initData\\n    )\\n        external\\n        payable;\\n\\n    /**\\n     * Uninstalls a Module of a certain type on the smart account.\\n     * @dev The module has to be initialized from msg.sender == SafeProxy, we thus use a\\n     *    delegatecall to DCUtil, which calls the onInstall/onUninstall function on the ERC7579\\n     *    module and emits the ModuleInstall/ModuleUnintall events\\n     * @dev AccessControl: only Self of Entrypoint can install modules\\n     * @dev If a global hook and/or selector hook is set, it will be called\\n     * @param moduleType the module type ID according the ERC-7579 spec\\n     * @param module the module address\\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\\n     * de-initialization.\\n     */\\n    function uninstallModule(\\n        uint256 moduleType,\\n        address module,\\n        bytes memory deInitData\\n    )\\n        external\\n        payable;\\n\\n    /**\\n     * Function to check if the account has a certain module installed\\n     * @param moduleType the module type ID according the ERC-7579 spec\\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\\n     *            thus may be necessary to query multiple module types\\n     * @param module the module address\\n     * @param additionalContext additional context data that the smart account may interpret to\\n     *                          identifiy conditions under which the module is installed.\\n     *                          usually this is not necessary, but for some special hooks that\\n     *                          are stored in mappings, this param might be needed\\n     */\\n    function isModuleInstalled(\\n        uint256 moduleType,\\n        address module,\\n        bytes memory additionalContext\\n    )\\n        external\\n        view\\n        returns (bool);\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   Initialize Safe7579                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /**\\n     * This function can be called by the Launchpad.initSafe7579() or by already existing Safes that\\n     * want to use Safe7579\\n     * if this is called by the Launchpad, it is expected that launchpadValidators() was called\\n     * previously, and the param validators is empty\\n     * @param validators validator modules and initData\\n     * @param executors executor modules and initData\\n     * @param executors executor modules and initData\\n     * @param fallbacks fallback modules and initData\\n     * @param hooks hook module and initData\\n     * @param registryInit (OPTIONAL) registry, attesters and threshold for IERC7484 Registry\\n     *                    If not provided, the registry will be set to the zero address, and no\\n     *                    registry checks will be performed\\n     */\\n    function initializeAccount(\\n        ModuleInit[] memory validators,\\n        ModuleInit[] memory executors,\\n        ModuleInit[] memory fallbacks,\\n        ModuleInit[] memory hooks,\\n        RegistryInit memory registryInit\\n    )\\n        external\\n        payable;\\n\\n    /**\\n     * This function is intended to be called by Launchpad.validateUserOp()\\n     * @dev it will initialize the SentinelList4337 list for validators, and sstore all\\n     * validators\\n     * @dev Since this function has to be 4337 compliant (storage access), only validator storage is  acccess\\n     * @dev Note: this function DOES NOT call onInstall() on the validator modules or emit\\n     * ModuleInstalled events. this has to be done by the launchpad\\n     */\\n    function launchpadValidators(ModuleInit[] memory validators) external payable;\\n\\n    /**\\n     * TODO:\\n     */\\n    function setRegistry(IERC7484 registry, address[] memory attesters, uint8 threshold) external;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   Query Account Details                    */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n    function getValidatorPaginated(\\n        address start,\\n        uint256 pageSize\\n    )\\n        external\\n        view\\n        returns (address[] memory array, address next);\\n\\n    function getActiveHook() external view returns (address hook);\\n    function getActiveHook(bytes4 selector) external view returns (address hook);\\n    function getExecutorsPaginated(\\n        address cursor,\\n        uint256 size\\n    )\\n        external\\n        view\\n        returns (address[] memory array, address next);\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                        Query Misc                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n    function supportsExecutionMode(ModeCode encodedMode) external pure returns (bool supported);\\n    function supportsModule(uint256 moduleTypeId) external pure returns (bool);\\n    function accountId() external view returns (string memory accountImplementationId);\\n\\n    /**\\n     * Domain Separator for EIP-712.\\n     */\\n    function domainSeparator() external view returns (bytes32);\\n    /**\\n     * Safe7579 is using validator selection encoding in the userop nonce.\\n     * to make it easier for SDKs / devs to integrate, this function can be\\n     * called to get the next nonce for a specific validator\\n     * @param safe address of safe account\\n     * @param validator ERC7579 validator to encode\\n     */\\n    function getNonce(address safe, address validator) external view returns (uint256 nonce);\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       Custom Errors                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n    error InvalidModule(address module);\\n    error LinkedListError();\\n    error InitializerError();\\n    error ValidatorStorageHelperError();\\n\\n    // fallback handlers\\n    error InvalidInput();\\n    error NoFallbackHandler(bytes4 msgSig);\\n    error InvalidFallbackHandler(bytes4 msgSig);\\n    error FallbackInstalled(bytes4 msgSig);\\n\\n    // Hooks\\n    error HookPostCheckFailed();\\n    error HookAlreadyInstalled(address currentHook);\\n    error InvalidHookType();\\n\\n    // Registry Adapter\\n    event ERC7484RegistryConfigured(address indexed smartAccount, IERC7484 indexed registry);\\n}\\n\",\"keccak256\":\"0x6aa8cbc5d5cf2be4dcd6021690bff33287a79a58175065b46149e68441b7cdc7\",\"license\":\"MIT\"},\"contracts/safe7579/Safe7579.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.21;\\n\\nimport { IERC7579Account, Execution } from \\\"./interfaces/IERC7579Account.sol\\\";\\nimport {\\n    CallType,\\n    ExecType,\\n    ModeCode,\\n    ModeLib,\\n    EXECTYPE_DEFAULT,\\n    EXECTYPE_TRY,\\n    CALLTYPE_SINGLE,\\n    CALLTYPE_BATCH,\\n    CALLTYPE_DELEGATECALL\\n} from \\\"./lib/ModeLib.sol\\\";\\nimport { ExecutionLib } from \\\"./lib/ExecutionLib.sol\\\";\\nimport {\\n    IValidator,\\n    MODULE_TYPE_VALIDATOR,\\n    MODULE_TYPE_HOOK,\\n    MODULE_TYPE_EXECUTOR,\\n    MODULE_TYPE_FALLBACK\\n} from \\\"./interfaces/IERC7579Module.sol\\\";\\nimport { ModuleInstallUtil } from \\\"./utils/DCUtil.sol\\\";\\nimport { AccessControl } from \\\"./core/AccessControl.sol\\\";\\nimport { Initializer } from \\\"./core/Initializer.sol\\\";\\nimport { ISafeOp, SAFE_OP_TYPEHASH } from \\\"./interfaces/ISafeOp.sol\\\";\\nimport { ISafe } from \\\"./interfaces/ISafe.sol\\\";\\nimport { ISafe7579 } from \\\"./ISafe7579.sol\\\";\\nimport {\\n    PackedUserOperation,\\n    UserOperationLib\\n} from \\\"@account-abstraction/contracts/core/UserOperationLib.sol\\\";\\nimport { _packValidationData } from \\\"@account-abstraction/contracts/core/Helpers.sol\\\";\\nimport { IEntryPoint } from \\\"@account-abstraction/contracts/interfaces/IEntryPoint.sol\\\";\\nimport { IERC1271 } from \\\"./interfaces/IERC1271.sol\\\";\\n\\nuint256 constant MULTITYPE_MODULE = 0;\\n\\n/**\\n * @title ERC7579 Adapter for Safe accounts.\\n * creates full ERC7579 compliance to Safe accounts\\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\\n * @dev This contract is a Safe account implementation that supports ERC7579 operations.\\n *    In order to facilitate full ERC7579 compliance, the contract implements the IERC7579Account\\n *    interface.\\n * This contract is an implementation of a Safe account supporting ERC7579 operations and complying\\n * with the IERC7579Account interface. It serves as a Safe FallbackHandler and module for Safe\\n * accounts, incorporating complex hacks to ensure ERC7579 compliance and requiring interactions and\\n * event emissions to be done via the SafeProxy as msg.sender using Safe's\\n * \\\"executeTransactionFromModule\\\" features.\\n */\\ncontract Safe7579 is ISafe7579, ISafeOp, AccessControl, Initializer {\\n    using UserOperationLib for PackedUserOperation;\\n    using ModeLib for ModeCode;\\n    using ExecutionLib for bytes;\\n\\n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH =\\n        0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\\n\\n    // keccak256(\\\"SafeMessage(bytes message)\\\");\\n    bytes32 private constant SAFE_MSG_TYPEHASH =\\n        0x60b3cbf8b4a223d68d641b3b6ddf9a298e7f33710cf3d3a9d1146b5a6150fbca;\\n    // keccak256(\\\"safeSignature(bytes32,bytes32,bytes,bytes)\\\");\\n    bytes4 private constant SAFE_SIGNATURE_MAGIC_VALUE = 0x5fd7e97d;\\n\\n    /**\\n     * @inheritdoc ISafe7579\\n     */\\n    function execute(\\n        ModeCode mode,\\n        bytes calldata executionCalldata\\n    )\\n        external\\n        payable\\n        withHook(IERC7579Account.execute.selector)\\n        onlyEntryPointOrSelf\\n    {\\n        CallType callType;\\n        ExecType execType;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            callType := mode\\n            execType := shl(8, mode)\\n        }\\n        /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n        /*                   REVERT ON FAILED EXEC                    */\\n        /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n        ISafe safe = ISafe(msg.sender);\\n        if (execType == EXECTYPE_DEFAULT) {\\n            // DEFAULT EXEC & SINGLE CALL\\n            if (callType == CALLTYPE_BATCH) {\\n                Execution[] calldata executions = executionCalldata.decodeBatch();\\n                _exec(safe, executions);\\n            }\\n            // DEFAULT EXEC & BATCH CALL\\n            else if (callType == CALLTYPE_SINGLE) {\\n                (address target, uint256 value, bytes calldata callData) =\\n                    executionCalldata.decodeSingle();\\n                _exec(safe, target, value, callData);\\n            }\\n            // DEFAULT EXEC & DELEGATECALL\\n            else if (callType == CALLTYPE_DELEGATECALL) {\\n                address target = address(bytes20(executionCalldata[:20]));\\n                bytes calldata callData = executionCalldata[20:];\\n                _delegatecall(safe, target, callData);\\n            }\\n            // handle unsupported calltype\\n            else {\\n                revert UnsupportedCallType(callType);\\n            }\\n        }\\n        /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n        /*                           TRY EXEC                         */\\n        /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n        else if (execType == EXECTYPE_TRY) {\\n            // TRY EXEC & BATCH CALL\\n            if (callType == CALLTYPE_BATCH) {\\n                Execution[] calldata executions = executionCalldata.decodeBatch();\\n                _tryExec(safe, executions);\\n            }\\n            // TRY EXEC & SINGLE CALL\\n            else if (callType == CALLTYPE_SINGLE) {\\n                (address target, uint256 value, bytes calldata callData) =\\n                    executionCalldata.decodeSingle();\\n                _tryExec(safe, target, value, callData);\\n            }\\n            // TRY EXEC & DELEGATECALL\\n            else if (callType == CALLTYPE_DELEGATECALL) {\\n                address target = address(bytes20(executionCalldata[:20]));\\n                bytes calldata callData = executionCalldata[20:];\\n                _tryDelegatecall(safe, target, callData);\\n            }\\n            // handle unsupported calltype\\n            else {\\n                revert UnsupportedCallType(callType);\\n            }\\n        }\\n        /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n        /*               HANDLE UNSUPPORTED EXEC TYPE                 */\\n        /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n        else {\\n            revert UnsupportedExecType(execType);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc ISafe7579\\n     */\\n    function executeFromExecutor(\\n        ModeCode mode,\\n        bytes calldata executionCalldata\\n    )\\n        external\\n        payable\\n        override\\n        onlyExecutorModule\\n        withHook(IERC7579Account.executeFromExecutor.selector)\\n        withRegistry(msg.sender, MODULE_TYPE_EXECUTOR)\\n        returns (bytes[] memory returnDatas)\\n    {\\n        CallType callType;\\n        ExecType execType;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            callType := mode\\n            execType := shl(8, mode)\\n        }\\n        // using JUMPI to avoid stack too deep\\n        return _executeReturn(execType, callType, executionCalldata);\\n    }\\n\\n    /**\\n     * Internal function that will be solely called by executeFromExecutor. Not super uniform code,\\n     * but we need need the JUMPI to avoid stack too deep, due to the modifiers in the\\n     * executeFromExecutor function\\n     */\\n    function _executeReturn(\\n        ExecType execType,\\n        CallType callType,\\n        bytes calldata executionCalldata\\n    )\\n        private\\n        returns (bytes[] memory returnDatas)\\n    {\\n        /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n        /*                   REVERT ON FAILED EXEC                    */\\n        /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n        if (execType == EXECTYPE_DEFAULT) {\\n            // DEFAULT EXEC & SINGLE CALL\\n            if (callType == CALLTYPE_BATCH) {\\n                Execution[] calldata executions = executionCalldata.decodeBatch();\\n                returnDatas = _execReturn(ISafe(msg.sender), executions);\\n            }\\n            // DEFAULT EXEC & BATCH CALL\\n            else if (callType == CALLTYPE_SINGLE) {\\n                (address target, uint256 value, bytes calldata callData) =\\n                    executionCalldata.decodeSingle();\\n                returnDatas = new bytes[](1);\\n                returnDatas[0] = _execReturn(ISafe(msg.sender), target, value, callData);\\n            }\\n            // DEFAULT EXEC & DELEGATECALL\\n            else if (callType == CALLTYPE_DELEGATECALL) {\\n                address target = address(bytes20(executionCalldata[:20]));\\n                bytes calldata callData = executionCalldata[20:];\\n                returnDatas = new bytes[](1);\\n                returnDatas[0] = _delegatecallReturn(ISafe(msg.sender), target, callData);\\n            }\\n            // handle unsupported calltype\\n            else {\\n                revert UnsupportedCallType(callType);\\n            }\\n        }\\n        /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n        /*                           TRY EXEC                         */\\n        /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n        else if (execType == EXECTYPE_TRY) {\\n            // TRY EXEC & SINGLE CALL\\n            if (callType == CALLTYPE_BATCH) {\\n                Execution[] calldata executions = executionCalldata.decodeBatch();\\n                (, returnDatas) = _tryExecReturn(ISafe(msg.sender), executions);\\n            }\\n            // TRY EXEC & BATCH CALL\\n            else if (callType == CALLTYPE_SINGLE) {\\n                (address target, uint256 value, bytes calldata callData) =\\n                    executionCalldata.decodeSingle();\\n                returnDatas = new bytes[](1);\\n                returnDatas[0] = _tryExecReturn(ISafe(msg.sender), target, value, callData);\\n            }\\n            // TRY EXEC & DELEGATECALL\\n            else if (callType == CALLTYPE_DELEGATECALL) {\\n                address target = address(bytes20(executionCalldata[:20]));\\n                bytes calldata callData = executionCalldata[20:];\\n                returnDatas = new bytes[](1);\\n                returnDatas[0] = _tryDelegatecallReturn(ISafe(msg.sender), target, callData);\\n            }\\n            // handle unsupported calltype\\n            else {\\n                revert UnsupportedCallType(callType);\\n            }\\n        }\\n        /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n        /*               HANDLE UNSUPPORTED EXEC TYPE                 */\\n        /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n        else {\\n            revert UnsupportedExecType(execType);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc ISafe7579\\n     */\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 missingAccountFunds\\n    )\\n        external\\n        payable\\n        onlyEntryPoint\\n        returns (uint256 validSignature)\\n    {\\n        address validator;\\n        uint256 nonce = userOp.nonce;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            validator := shr(96, nonce)\\n        }\\n\\n        // check if validator is enabled. If not, use Safe's checkSignatures()\\n        if (validator == address(0) || !_isValidatorInstalled(validator)) {\\n            validSignature = _validateSignatures(userOp);\\n        } else {\\n            // bubble up the return value of the validator module\\n            bytes memory retData = _execReturn({\\n                safe: ISafe(msg.sender),\\n                target: validator,\\n                value: 0,\\n                callData: abi.encodeCall(IValidator.validateUserOp, (userOp, userOpHash))\\n            });\\n            validSignature = abi.decode(retData, (uint256));\\n        }\\n\\n        // pay prefund\\n        if (missingAccountFunds != 0) {\\n            _exec({\\n                safe: ISafe(msg.sender),\\n                target: entryPoint(),\\n                value: missingAccountFunds,\\n                callData: \\\"\\\"\\n            });\\n        }\\n    }\\n\\n    /**\\n     * Function used as signature check fallback, if no valid validation module was selected.\\n     * will use safe's ECDSA multisig. This code was copied of Safe's ERC4337 module\\n     */\\n    function _validateSignatures(PackedUserOperation calldata userOp)\\n        internal\\n        view\\n        returns (uint256 validationData)\\n    {\\n        (\\n            bytes memory operationData,\\n            uint48 validAfter,\\n            uint48 validUntil,\\n            bytes calldata signatures\\n        ) = _getSafeOp(userOp);\\n        try ISafe(payable(msg.sender)).checkSignatures(\\n            keccak256(operationData), operationData, signatures\\n        ) {\\n            // The timestamps are validated by the entry point,\\n            // therefore we will not check them again\\n            validationData = _packValidationData(false, validUntil, validAfter);\\n        } catch {\\n            validationData = _packValidationData(true, validUntil, validAfter);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc ISafe7579\\n     */\\n    function isValidSignature(\\n        bytes32 hash,\\n        bytes calldata data\\n    )\\n        external\\n        view\\n        returns (bytes4 magicValue)\\n    {\\n        ISafe safe = ISafe(msg.sender);\\n\\n        // check for safe's approved hashes\\n        if (data.length == 0 && safe.signedMessages(hash) != 0) {\\n            // return magic value\\n            return IERC1271.isValidSignature.selector;\\n        }\\n        address validationModule = address(bytes20(data[:20]));\\n\\n        // If validation module with address(0) or no valid validator was provided,\\n        // The signature validation mechanism falls back to Safe's checkSignatures() function\\n        if (validationModule == address(0) || !_isValidatorInstalled(validationModule)) {\\n            bytes memory messageData = EIP712.encodeMessageData(\\n                safe.domainSeparator(), SAFE_MSG_TYPEHASH, abi.encode(keccak256(abi.encode(hash)))\\n            );\\n\\n            bytes32 messageHash = keccak256(messageData);\\n\\n            safe.checkSignatures(messageHash, messageData, data[20:]);\\n            return IERC1271.isValidSignature.selector;\\n        }\\n\\n        // if a installed validator module was selected, use 7579 validation module\\n        bytes memory ret = _staticcallReturn({\\n            safe: ISafe(msg.sender),\\n            target: validationModule,\\n            callData: abi.encodeCall(\\n                IValidator.isValidSignatureWithSender, (_msgSender(), hash, data[20:])\\n            )\\n        });\\n        magicValue = abi.decode(ret, (bytes4));\\n    }\\n\\n    /**\\n     * @inheritdoc ISafe7579\\n     */\\n    function installModule(\\n        uint256 moduleType,\\n        address module,\\n        bytes calldata initData\\n    )\\n        external\\n        payable\\n        override\\n        withHook(IERC7579Account.installModule.selector)\\n        onlyEntryPointOrSelf\\n    {\\n        // internal install functions will decode the initData param, and return sanitzied\\n        // moduleInitData. This is the initData that will be passed to Module.onInstall()\\n        bytes memory moduleInitData;\\n        if (moduleType == MODULE_TYPE_VALIDATOR) {\\n            moduleInitData = _installValidator(module, initData);\\n        } else if (moduleType == MODULE_TYPE_EXECUTOR) {\\n            moduleInitData = _installExecutor(module, initData);\\n        } else if (moduleType == MODULE_TYPE_FALLBACK) {\\n            moduleInitData = _installFallbackHandler(module, initData);\\n        } else if (moduleType == MODULE_TYPE_HOOK) {\\n            moduleInitData = _installHook(module, initData);\\n        } else if (moduleType == MULTITYPE_MODULE) {\\n            moduleInitData = _multiTypeInstall(module, initData);\\n        } else {\\n            revert UnsupportedModuleType(moduleType);\\n        }\\n\\n        // Initialize Module via Safe\\n        _delegatecall({\\n            safe: ISafe(msg.sender),\\n            target: UTIL,\\n            callData: abi.encodeCall(\\n                ModuleInstallUtil.installModule, (moduleType, module, moduleInitData)\\n            )\\n        });\\n    }\\n\\n    /**\\n     * @inheritdoc ISafe7579\\n     */\\n    function uninstallModule(\\n        uint256 moduleType,\\n        address module,\\n        bytes calldata deInitData\\n    )\\n        external\\n        payable\\n        override\\n        withHook(IERC7579Account.uninstallModule.selector)\\n        onlyEntryPointOrSelf\\n    {\\n        // internal uninstall functions will decode the deInitData param, and return sanitzied\\n        // moduleDeInitData. This is the initData that will be passed to Module.onUninstall()\\n        bytes memory moduleDeInitData;\\n        if (moduleType == MODULE_TYPE_VALIDATOR) {\\n            moduleDeInitData = _uninstallValidator(module, deInitData);\\n        } else if (moduleType == MODULE_TYPE_EXECUTOR) {\\n            moduleDeInitData = _uninstallExecutor(module, deInitData);\\n        } else if (moduleType == MODULE_TYPE_FALLBACK) {\\n            moduleDeInitData = _uninstallFallbackHandler(module, deInitData);\\n        } else if (moduleType == MODULE_TYPE_HOOK) {\\n            moduleDeInitData = _uninstallHook(module, deInitData);\\n        } else {\\n            revert UnsupportedModuleType(moduleType);\\n        }\\n\\n        // Deinitialize Module via Safe.\\n        // We are using \\\"try\\\" here, to avoid DoS. A module could revert in 'onUninstall' and prevent\\n        // the account from removing the module\\n        _tryDelegatecall({\\n            safe: ISafe(msg.sender),\\n            target: UTIL,\\n            callData: abi.encodeCall(\\n                ModuleInstallUtil.unInstallModule, (moduleType, module, moduleDeInitData)\\n            )\\n        });\\n    }\\n\\n    /**\\n     * @inheritdoc ISafe7579\\n     */\\n    function supportsExecutionMode(ModeCode encodedMode)\\n        external\\n        pure\\n        override\\n        returns (bool supported)\\n    {\\n        CallType callType;\\n        ExecType execType;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            callType := encodedMode\\n            execType := shl(8, encodedMode)\\n        }\\n        if (callType == CALLTYPE_BATCH) supported = true;\\n        else if (callType == CALLTYPE_SINGLE) supported = true;\\n        else if (callType == CALLTYPE_DELEGATECALL) supported = true;\\n        else return false;\\n\\n        if (supported && execType == EXECTYPE_DEFAULT) return supported;\\n        else if (supported && execType == EXECTYPE_TRY) return supported;\\n        else return false;\\n    }\\n\\n    /**\\n     * @inheritdoc ISafe7579\\n     */\\n    function supportsModule(uint256 moduleTypeId) external pure override returns (bool) {\\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) return true;\\n        else if (moduleTypeId == MODULE_TYPE_EXECUTOR) return true;\\n        else if (moduleTypeId == MODULE_TYPE_FALLBACK) return true;\\n        else if (moduleTypeId == MODULE_TYPE_HOOK) return true;\\n        else return false;\\n    }\\n\\n    /**\\n     * @inheritdoc ISafe7579\\n     */\\n    function isModuleInstalled(\\n        uint256 moduleType,\\n        address module,\\n        bytes calldata additionalContext\\n    )\\n        external\\n        view\\n        returns (bool)\\n    {\\n        if (moduleType == MODULE_TYPE_VALIDATOR) {\\n            return _isValidatorInstalled(module);\\n        } else if (moduleType == MODULE_TYPE_EXECUTOR) {\\n            return _isExecutorInstalled(module);\\n        } else if (moduleType == MODULE_TYPE_FALLBACK) {\\n            return _isFallbackHandlerInstalled(module, additionalContext);\\n        } else if (moduleType == MODULE_TYPE_HOOK) {\\n            return _isHookInstalled(module, additionalContext);\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc ISafe7579\\n     */\\n    function accountId() external view returns (string memory accountImplementationId) {\\n        string memory safeVersion = ISafe(msg.sender).VERSION();\\n        return string(abi.encodePacked(\\\"safe-\\\", safeVersion, \\\".erc7579.v0.0.1\\\"));\\n    }\\n\\n    /**\\n     * @dev Decodes an ERC-4337 user operation into a Safe operation.\\n     * @param userOp The ERC-4337 user operation.\\n     * @return operationData Encoded EIP-712 Safe operation data bytes used for signature\\n     * verification.\\n     * @return validAfter The timestamp the user operation is valid from.\\n     * @return validUntil The timestamp the user operation is valid until.\\n     * @return signatures The Safe owner signatures extracted from the user operation.\\n     */\\n    function _getSafeOp(PackedUserOperation calldata userOp)\\n        internal\\n        view\\n        returns (\\n            bytes memory operationData,\\n            uint48 validAfter,\\n            uint48 validUntil,\\n            bytes calldata signatures\\n        )\\n    {\\n        // Extract additional Safe operation fields from the user operation signature which is\\n        // encoded as:\\n        // `abi.encodePacked(validAfter, validUntil, signatures)`\\n        {\\n            bytes calldata sig = userOp.signature;\\n            validAfter = uint48(bytes6(sig[0:6]));\\n            validUntil = uint48(bytes6(sig[6:12]));\\n            signatures = sig[12:];\\n        }\\n\\n        // It is important that **all** user operation fields are represented in the `SafeOp` data\\n        // somehow, to prevent\\n        // user operations from being submitted that do not fully respect the user preferences. The\\n        // only exception is\\n        // the `signature` bytes. Note that even `initCode` needs to be represented in the operation\\n        // data, otherwise\\n        // it can be replaced with a more expensive initialization that would charge the user\\n        // additional fees.\\n        {\\n            // In order to work around Solidity \\\"stack too deep\\\" errors related to too many stack\\n            // variables, manually\\n            // encode the `SafeOp` fields into a memory `struct` for computing the EIP-712\\n            // struct-hash. This works\\n            // because the `EncodedSafeOpStruct` struct has no \\\"dynamic\\\" fields so its memory layout\\n            // is identical to the\\n            // result of `abi.encode`-ing the individual fields.\\n            EncodedSafeOpStruct memory encodedSafeOp = EncodedSafeOpStruct({\\n                typeHash: SAFE_OP_TYPEHASH,\\n                safe: msg.sender,\\n                nonce: userOp.nonce,\\n                initCodeHash: keccak256(userOp.initCode),\\n                callDataHash: keccak256(userOp.callData),\\n                callGasLimit: userOp.unpackCallGasLimit(),\\n                verificationGasLimit: userOp.unpackVerificationGasLimit(),\\n                preVerificationGas: userOp.preVerificationGas,\\n                maxFeePerGas: userOp.unpackMaxFeePerGas(),\\n                maxPriorityFeePerGas: userOp.unpackMaxPriorityFeePerGas(),\\n                paymasterAndDataHash: keccak256(userOp.paymasterAndData),\\n                validAfter: validAfter,\\n                validUntil: validUntil,\\n                entryPoint: entryPoint()\\n            });\\n\\n            bytes32 safeOpStructHash;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly (\\\"memory-safe\\\") {\\n                // Since the `encodedSafeOp` value's memory layout is identical to the result of\\n                // `abi.encode`-ing the\\n                // individual `SafeOp` fields, we can pass it directly to `keccak256`. Additionally,\\n                // there are 14\\n                // 32-byte fields to hash, for a length of `14 * 32 = 448` bytes.\\n                safeOpStructHash := keccak256(encodedSafeOp, 448)\\n            }\\n\\n            operationData =\\n                abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeOpStructHash);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc ISafe7579\\n     */\\n    function domainSeparator() public view returns (bytes32) {\\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, block.chainid, this));\\n    }\\n\\n    /**\\n     * @inheritdoc ISafe7579\\n     */\\n    function getNonce(address safe, address validator) external view returns (uint256 nonce) {\\n        uint192 key = uint192(bytes24(bytes20(address(validator))));\\n        nonce = IEntryPoint(entryPoint()).getNonce(safe, key);\\n    }\\n}\\n\\nlibrary EIP712 {\\n    function encodeMessageData(\\n        bytes32 domainSeparator,\\n        bytes32 typeHash,\\n        bytes memory message\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return abi.encodePacked(\\n            bytes1(0x19),\\n            bytes1(0x01),\\n            domainSeparator,\\n            keccak256(abi.encodePacked(typeHash, message))\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x49bb0c2d7fdfbfd902bc3a38457766f8b796346fae97c3885e9837f79ec37e77\",\"license\":\"GPL-3.0\"},\"contracts/safe7579/core/AccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport { HandlerContext } from \\\"@safe-global/safe-contracts/contracts/handler/HandlerContext.sol\\\";\\nimport { AccountBase } from \\\"erc7579/core/AccountBase.sol\\\";\\n\\n/**\\n * Implements AccessControl for Safe7579 adapter.\\n * Since Safe7579 Adapter is installed as a fallback handler on the safe account, we are making use\\n * of handlercontext (ERC2771)\\n * @author zeroknots.eth | rhinestone.wtf\\n */\\nabstract contract AccessControl is HandlerContext, AccountBase {\\n    modifier onlyEntryPointOrSelf() virtual override {\\n        if (!(_msgSender() == entryPoint() || msg.sender == _msgSender())) {\\n            revert AccountAccessUnauthorized();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyEntryPoint() virtual override {\\n        if (_msgSender() != entryPoint()) {\\n            revert AccountAccessUnauthorized();\\n        }\\n        _;\\n    }\\n\\n    function entryPoint() public view virtual override returns (address) {\\n        return 0x0000000071727De22E5E9d8BAf0edAc6f37da032;\\n    }\\n}\\n\",\"keccak256\":\"0xdcff021d5838646db8b9453bd9b817c83a570c3be142d81b4c75ed4910cc090f\",\"license\":\"MIT\"},\"contracts/safe7579/core/ExecutionHelper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport { Safe7579DCUtil, Safe7579DCUtilSetup } from \\\"./SetupDCUtil.sol\\\";\\nimport { BatchedExecUtil } from \\\"../utils/DCUtil.sol\\\";\\nimport { Execution } from \\\"../interfaces/IERC7579Account.sol\\\";\\nimport { ISafe } from \\\"../interfaces/ISafe.sol\\\";\\n\\n/**\\n * Abstraction layer for executions.\\n * @dev All interactions with modules must originate from msg.sender == SafeProxy. This entails\\n * avoiding direct calls by the Safe7579 Adapter for actions like onInstall on modules or\\n * validateUserOp on validator modules, and utilizing the Safe's execTransactionFromModule feature\\n * instead.\\n * @dev Since Safe7579 offers features like TryExecute for batched executions, rewriting and\\n * verifying execution success across the codebase can be challenging and error-prone. These\\n * functions serve to interact with modules and external contracts.\\n */\\nabstract contract ExecutionHelper is Safe7579DCUtilSetup {\\n    event TryExecutionFailed(ISafe safe, uint256 numberInBatch);\\n    event TryExecutionsFailed(ISafe safe, bool[] success);\\n\\n    error ExecutionFailed();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   EXEC - REVERT ON FAIL                    */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n    function _exec(ISafe safe, Execution[] calldata executions) internal {\\n        _delegatecall({\\n            safe: safe,\\n            target: UTIL,\\n            callData: abi.encodeCall(BatchedExecUtil.execute, executions)\\n        });\\n    }\\n\\n    function _exec(ISafe safe, address target, uint256 value, bytes memory callData) internal {\\n        bool success = safe.execTransactionFromModule(target, value, callData, 0);\\n        if (!success) revert ExecutionFailed();\\n    }\\n\\n    function _delegatecall(ISafe safe, address target, bytes memory callData) internal {\\n        bool success = safe.execTransactionFromModule(target, 0, callData, 1);\\n        if (!success) revert ExecutionFailed();\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*             EXEC - REVERT ON FAIL & Return Values          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n    /**\\n     * Helper function to facilitate batched executions. Since Safe accounts do not support batched\\n     * executions natively, we nudge the safe to delegatecall to ./utils/DCUTIL.sol, which then\\n     * makes a multicall. This is to save on gas\\n     */\\n    function _execReturn(\\n        ISafe safe,\\n        Execution[] calldata executions\\n    )\\n        internal\\n        returns (bytes[] memory retDatas)\\n    {\\n        bytes memory tmp = _delegatecallReturn({\\n            safe: safe,\\n            target: UTIL,\\n            callData: abi.encodeCall(BatchedExecUtil.executeReturn, executions)\\n        });\\n        retDatas = abi.decode(tmp, (bytes[]));\\n    }\\n\\n    function _execReturn(\\n        ISafe safe,\\n        address target,\\n        uint256 value,\\n        bytes memory callData\\n    )\\n        internal\\n        returns (bytes memory retData)\\n    {\\n        bool success;\\n        (success, retData) = safe.execTransactionFromModuleReturnData(target, value, callData, 0);\\n        if (!success) revert ExecutionFailed();\\n    }\\n\\n    function _delegatecallReturn(\\n        ISafe safe,\\n        address target,\\n        bytes memory callData\\n    )\\n        internal\\n        returns (bytes memory retData)\\n    {\\n        bool success;\\n        (success, retData) = safe.execTransactionFromModuleReturnData(target, 0, callData, 1);\\n        if (!success) revert ExecutionFailed();\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                        EXEC - TRY                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n    /**\\n     * Helper function to facilitate batched executions. Since Safe accounts do not support batched\\n     * executions natively, we nudge the safe to delegatecall to ./utils/DCUTIL.sol, which then\\n     * makes a multicall. This is to save on gas\\n     */\\n    function _tryExec(ISafe safe, Execution[] calldata executions) internal {\\n        _tryDelegatecall({\\n            safe: safe,\\n            target: UTIL,\\n            callData: abi.encodeCall(BatchedExecUtil.tryExecute, executions)\\n        });\\n    }\\n\\n    function _tryExec(ISafe safe, address target, uint256 value, bytes memory callData) internal {\\n        bool success = safe.execTransactionFromModule(target, value, callData, 0);\\n        if (!success) emit TryExecutionFailed(safe, 0);\\n    }\\n\\n    function _tryDelegatecall(ISafe safe, address target, bytes memory callData) internal {\\n        bool success = safe.execTransactionFromModule(target, 0, callData, 1);\\n        if (!success) emit TryExecutionFailed(safe, 0);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*              EXEC - TRY & Return Values                    */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /**\\n     * Helper function to facilitate batched executions. Since Safe accounts do not support batched\\n     * executions natively, we nudge the safe to delegatecall to ./utils/DCUTIL.sol, which then\\n     * makes a multicall. This is to save on gas\\n     */\\n    function _tryExecReturn(\\n        ISafe safe,\\n        Execution[] calldata executions\\n    )\\n        internal\\n        returns (bool[] memory success, bytes[] memory retDatas)\\n    {\\n        bytes memory tmp = _tryDelegatecallReturn({\\n            safe: safe,\\n            target: UTIL,\\n            callData: abi.encodeCall(BatchedExecUtil.tryExecuteReturn, executions)\\n        });\\n        (success, retDatas) = abi.decode(tmp, (bool[], bytes[]));\\n    }\\n\\n    function _tryExecReturn(\\n        ISafe safe,\\n        address target,\\n        uint256 value,\\n        bytes memory callData\\n    )\\n        internal\\n        returns (bytes memory retData)\\n    {\\n        bool success;\\n        (success, retData) = safe.execTransactionFromModuleReturnData(target, value, callData, 0);\\n        if (!success) emit TryExecutionFailed(safe, 0);\\n    }\\n\\n    function _tryDelegatecallReturn(\\n        ISafe safe,\\n        address target,\\n        bytes memory callData\\n    )\\n        internal\\n        returns (bytes memory retData)\\n    {\\n        bool success;\\n        (success, retData) = safe.execTransactionFromModuleReturnData(target, 0, callData, 1);\\n        if (!success) emit TryExecutionFailed(safe, 0);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     STATICCALL TRICK                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /**\\n     * Safe account does not natively implement Enum.Operation.StaticCall,\\n     * using a trick with simulateAndRevert to execute a staticcall.\\n     * @param safe Safe account to execute the staticcall\\n     * @param target Target contract to staticcall\\n     * @param callData Data to be passed to the target contract\\n     */\\n    function _staticcallReturn(\\n        ISafe safe,\\n        address target,\\n        bytes memory callData\\n    )\\n        internal\\n        view\\n        returns (bytes memory result)\\n    {\\n        bytes memory staticCallData = abi.encodeCall(Safe7579DCUtil.staticCall, (target, callData));\\n        bytes memory simulationCallData =\\n            abi.encodeCall(ISafe.simulateAndRevert, (address(UTIL), staticCallData));\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    safe,\\n                    add(simulationCallData, 0x20),\\n                    mload(simulationCallData),\\n                    0x00,\\n                    0x20\\n                )\\n            )\\n\\n            let responseSize := sub(returndatasize(), 0x20)\\n            result := mload(0x40)\\n            mstore(0x40, add(result, responseSize))\\n            returndatacopy(result, 0x20, responseSize)\\n\\n            if iszero(mload(0x00)) { revert(add(result, 0x20), mload(result)) }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0edfc19f11a4eedac6262a9bf2c0b96a61e27555b2cfd4fd11e978ce0d1f7bb4\",\"license\":\"MIT\"},\"contracts/safe7579/core/Initializer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport { ISafe7579 } from \\\"../ISafe7579.sol\\\";\\nimport \\\"../DataTypes.sol\\\";\\nimport { ModuleManager } from \\\"./ModuleManager.sol\\\";\\nimport { IERC7484 } from \\\"../interfaces/IERC7484.sol\\\";\\nimport { SentinelList4337Lib } from \\\"sentinellist/SentinelList4337.sol\\\";\\nimport { SentinelListLib } from \\\"sentinellist/SentinelList.sol\\\";\\n\\n/**\\n * Functions that can be used to initialze Safe7579 for a Safe Account\\n * @author zeroknots.eth | rhinestone.wtf\\n */\\nabstract contract Initializer is ISafe7579, ModuleManager {\\n    using SentinelList4337Lib for SentinelList4337Lib.SentinelList;\\n    using SentinelListLib for SentinelListLib.SentinelList;\\n\\n    event Safe7579Initialized(address indexed safe);\\n\\n    error InvalidInitData(address safe);\\n\\n    /**\\n     * @inheritdoc ISafe7579\\n     */\\n    function launchpadValidators(ModuleInit[] calldata validators) external payable override {\\n        // this will revert if already initialized\\n        $validators.init({ account: msg.sender });\\n        uint256 length = validators.length;\\n        for (uint256 i; i < length; i++) {\\n            ModuleInit calldata validator = validators[i];\\n            $validators.push({ account: msg.sender, newEntry: validator.module });\\n            // @dev No events emitted here. Launchpad is expected to do this.\\n            // at this point, the safeproxy singleton is not yet updated to the SafeSingleton\\n            // calling execTransactionFromModule is not available yet.\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc ISafe7579\\n     */\\n    function initializeAccount(\\n        ModuleInit[] calldata validators,\\n        ModuleInit[] calldata executors,\\n        ModuleInit[] calldata fallbacks,\\n        ModuleInit[] calldata hooks,\\n        RegistryInit calldata registryInit\\n    )\\n        public\\n        payable\\n    {\\n        _configureRegistry(registryInit.registry, registryInit.attesters, registryInit.threshold);\\n        // this will revert if already initialized\\n        _initModules(validators, executors, fallbacks, hooks);\\n    }\\n\\n    /**\\n     * _initModules may be used via launchpad deploymet or directly by already deployed Safe\\n     * accounts\\n     */\\n    function _initModules(\\n        ModuleInit[] calldata validators,\\n        ModuleInit[] calldata executors,\\n        ModuleInit[] calldata fallbacks,\\n        ModuleInit[] calldata hooks\\n    )\\n        internal\\n    {\\n        uint256 length = validators.length;\\n        // if this function is called by the launchpad, validators will be initialized via\\n        // launchpadValidators()\\n        // to avoid double initialization, we check if the validators are already initialized\\n        if (!$validators.alreadyInitialized({ account: msg.sender })) {\\n            $validators.init({ account: msg.sender });\\n            for (uint256 i; i < length; i++) {\\n                ModuleInit calldata validator = validators[i];\\n                // enable module on Safe7579,  initialize module via Safe, emit events\\n                _installValidator(validator.module, validator.initData);\\n            }\\n        } else if (length != 0) {\\n            revert InvalidInitData(msg.sender);\\n        }\\n\\n        SentinelListLib.SentinelList storage $executors = $executorStorage[msg.sender];\\n        // this will revert if already initialized.\\n        $executors.init();\\n\\n        length = executors.length;\\n        for (uint256 i; i < length; i++) {\\n            ModuleInit calldata executor = executors[i];\\n            // enable module on Safe7579,  initialize module via Safe, emit events\\n            _installExecutor(executor.module, executor.initData);\\n        }\\n\\n        length = fallbacks.length;\\n        for (uint256 i; i < length; i++) {\\n            ModuleInit calldata _fallback = fallbacks[i];\\n            // enable module on Safe7579,  initialize module via Safe, emit events\\n            _installFallbackHandler(_fallback.module, _fallback.initData);\\n        }\\n\\n        length = hooks.length;\\n        for (uint256 i; i < length; i++) {\\n            ModuleInit calldata hook = hooks[i];\\n            // enable module on Safe7579,  initialize module via Safe, emit events\\n            _installHook(hook.module, hook.initData);\\n        }\\n\\n        emit Safe7579Initialized(msg.sender);\\n    }\\n\\n    /**\\n     * @inheritdoc ISafe7579\\n     */\\n    function setRegistry(\\n        IERC7484 registry,\\n        address[] calldata attesters,\\n        uint8 threshold\\n    )\\n        external\\n        onlyEntryPointOrSelf\\n    {\\n        _configureRegistry(registry, attesters, threshold);\\n    }\\n}\\n\",\"keccak256\":\"0x01c10ca8e3d1350b2808bdc332a4de7fff481f199e15e9812353b40762f8e13f\",\"license\":\"MIT\"},\"contracts/safe7579/core/ModuleManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport 'hardhat/console.sol';\\n\\nimport { SentinelListLib } from \\\"sentinellist/SentinelList.sol\\\";\\nimport { SentinelList4337Lib } from \\\"sentinellist/SentinelList4337.sol\\\";\\nimport { IModule, IHook } from \\\"../interfaces/IERC7579Module.sol\\\";\\nimport { IERC7579Module } from \\\"../external/ERC7579.sol\\\";\\nimport { ISafe } from \\\"../interfaces/ISafe.sol\\\";\\nimport { ISafe7579 } from \\\"../ISafe7579.sol\\\";\\nimport \\\"../DataTypes.sol\\\";\\n\\nimport { ModuleInstallUtil } from \\\"../utils/DCUtil.sol\\\";\\nimport { RegistryAdapter } from \\\"./RegistryAdapter.sol\\\";\\nimport { Receiver } from \\\"erc7579/core/Receiver.sol\\\";\\nimport { AccessControl } from \\\"./AccessControl.sol\\\";\\nimport { CallType, CALLTYPE_STATIC, CALLTYPE_SINGLE } from \\\"../lib/ModeLib.sol\\\";\\nimport {\\n    MODULE_TYPE_VALIDATOR,\\n    MODULE_TYPE_EXECUTOR,\\n    MODULE_TYPE_FALLBACK,\\n    MODULE_TYPE_HOOK\\n} from \\\"../interfaces/IERC7579Module.sol\\\";\\n\\n/**\\n * @title ModuleManager\\n * Contract that implements ERC7579 Module compatibility for Safe accounts\\n * @author zeroknots.eth | rhinestone.wtf\\n * @dev All Module types  are handled within this\\n * contract. To make it a bit easier to read, the contract is split into different sections:\\n * - Validator Modules\\n * - Executor Modules\\n * - Fallback Modules\\n * - Hook Modules\\n * Note: the Storage mappings for each section, are not listed on the very top, but in the\\n * respective section\\n */\\nabstract contract ModuleManager is ISafe7579, AccessControl, Receiver, RegistryAdapter {\\n    using SentinelListLib for SentinelListLib.SentinelList;\\n    using SentinelList4337Lib for SentinelList4337Lib.SentinelList;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     VALIDATOR MODULES                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n    // No mapping account => list necessary. this sentinellist flavour handles associated storage to\\n    // smart account itself to comply with 4337 storage restrictions\\n    SentinelList4337Lib.SentinelList internal $validators;\\n\\n    /**\\n     * install and initialize validator module\\n     */\\n    function _installValidator(\\n        address validator,\\n        bytes calldata data\\n    )\\n        internal\\n        withRegistry(validator, MODULE_TYPE_VALIDATOR)\\n        returns (bytes memory moduleInitData)\\n    {\\n        $validators.push({ account: msg.sender, newEntry: validator });\\n        return data;\\n    }\\n\\n    /**\\n     * Uninstall validator module\\n     * @dev This function does not prevent the user from uninstalling all validator modules.\\n     * Since the Safe7579 signature validation can fallback to Safe's checkSignature()\\n     * function, it is okay, if all validator modules are removed.\\n     * This does not brick the account\\n     */\\n    function _uninstallValidator(\\n        address validator,\\n        bytes calldata data\\n    )\\n        internal\\n        returns (bytes memory moduleInitData)\\n    {\\n        address prev;\\n        (prev, moduleInitData) = abi.decode(data, (address, bytes));\\n        $validators.pop({ account: msg.sender, prevEntry: prev, popEntry: validator });\\n    }\\n\\n    /**\\n     * Helper function that will calculate storage slot for\\n     * validator address within the linked list in ValidatorStorageHelper\\n     * and use Safe's getStorageAt() to read 32bytes from Safe's storage\\n     */\\n    function _isValidatorInstalled(address validator)\\n        internal\\n        view\\n        virtual\\n        returns (bool isInstalled)\\n    {\\n        isInstalled = $validators.contains({ account: msg.sender, entry: validator });\\n    }\\n\\n    /**\\n     * Get paginated list of installed validators\\n     */\\n    function getValidatorPaginated(\\n        address start,\\n        uint256 pageSize\\n    )\\n        external\\n        view\\n        virtual\\n        returns (address[] memory array, address next)\\n    {\\n        return $validators.getEntriesPaginated({\\n            account: msg.sender,\\n            start: start,\\n            pageSize: pageSize\\n        });\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      EXECUTOR MODULES                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n    mapping(address smartAccount => SentinelListLib.SentinelList _executors) internal\\n        $executorStorage;\\n\\n    modifier onlyExecutorModule() {\\n        if (!_isExecutorInstalled(_msgSender())) revert InvalidModule(_msgSender());\\n        _;\\n    }\\n\\n    function _installExecutor(\\n        address executor,\\n        bytes calldata data\\n    )\\n        internal\\n        withRegistry(executor, MODULE_TYPE_EXECUTOR)\\n        returns (bytes memory moduleInitData)\\n    {\\n        SentinelListLib.SentinelList storage $executors = $executorStorage[msg.sender];\\n        $executors.push(executor);\\n        return data;\\n    }\\n\\n    function _uninstallExecutor(\\n        address executor,\\n        bytes calldata data\\n    )\\n        internal\\n        returns (bytes memory moduleDeInitData)\\n    {\\n        SentinelListLib.SentinelList storage $executors = $executorStorage[msg.sender];\\n        address prev;\\n        (prev, moduleDeInitData) = abi.decode(data, (address, bytes));\\n        $executors.pop(prev, executor);\\n    }\\n\\n    function _isExecutorInstalled(address executor) internal view virtual returns (bool) {\\n        SentinelListLib.SentinelList storage $executors = $executorStorage[msg.sender];\\n        return $executors.contains(executor);\\n    }\\n\\n    function getExecutorsPaginated(\\n        address cursor,\\n        uint256 size\\n    )\\n        external\\n        view\\n        virtual\\n        returns (address[] memory array, address next)\\n    {\\n        SentinelListLib.SentinelList storage $executors = $executorStorage[msg.sender];\\n        return $executors.getEntriesPaginated(cursor, size);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      FALLBACK MODULES                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    mapping(address smartAccount => mapping(bytes4 selector => FallbackHandler handlerConfig))\\n        internal $fallbackStorage;\\n\\n    function _installFallbackHandler(\\n        address handler,\\n        bytes calldata params\\n    )\\n        internal\\n        virtual\\n        withRegistry(handler, MODULE_TYPE_FALLBACK)\\n        returns (bytes memory moduleInitData)\\n    {\\n        (bytes4 functionSig, CallType calltype, bytes memory initData) =\\n            abi.decode(params, (bytes4, CallType, bytes));\\n\\n        // disallow calls to onInstall or onUninstall.\\n        // this could create a security issue\\n        if (\\n            functionSig == IModule.onInstall.selector || functionSig == IModule.onUninstall.selector\\n        ) revert InvalidFallbackHandler(functionSig);\\n        if (_isFallbackHandlerInstalled(functionSig)) revert FallbackInstalled(functionSig);\\n\\n        FallbackHandler storage $fallbacks = $fallbackStorage[msg.sender][functionSig];\\n        $fallbacks.calltype = calltype;\\n        $fallbacks.handler = handler;\\n\\n        return initData;\\n    }\\n\\n    function _isFallbackHandlerInstalled(bytes4 functionSig) internal view virtual returns (bool) {\\n        FallbackHandler storage $fallbacks = $fallbackStorage[msg.sender][functionSig];\\n        return $fallbacks.handler != address(0);\\n    }\\n\\n    function _uninstallFallbackHandler(\\n        address, /*handler*/\\n        bytes calldata context\\n    )\\n        internal\\n        virtual\\n        returns (bytes memory moduleDeInitData)\\n    {\\n        bytes4 functionSig;\\n        (functionSig, moduleDeInitData) = abi.decode(context, (bytes4, bytes));\\n\\n        FallbackHandler storage $fallbacks = $fallbackStorage[msg.sender][functionSig];\\n        delete $fallbacks.handler;\\n    }\\n\\n    function _isFallbackHandlerInstalled(\\n        address _handler,\\n        bytes calldata additionalContext\\n    )\\n        internal\\n        view\\n        virtual\\n        returns (bool)\\n    {\\n        bytes4 functionSig = abi.decode(additionalContext, (bytes4));\\n\\n        FallbackHandler storage $fallbacks = $fallbackStorage[msg.sender][functionSig];\\n        return $fallbacks.handler == _handler;\\n    }\\n\\n    /**\\n     * @dev AccessControl: any external contract / EOA may call this function\\n     * Safe7579 Fallback supports the following feature set:\\n     *    CallTypes:\\n     *             - CALLTYPE_SINGLE\\n     *             - CALLTYPE_BATCH\\n     * @dev If a global hook and/or selector hook is set, it will be called\\n     */\\n    // solhint-disable-next-line no-complex-fallback\\n    fallback(bytes calldata callData)\\n        external\\n        payable\\n        virtual\\n        override(Receiver)\\n        receiverFallback\\n        withHook(msg.sig)\\n        returns (bytes memory fallbackRet)\\n    {\\n        // using JUMPI to avoid stack too deep\\n        return _callFallbackHandler(callData);\\n    }\\n\\n    function _callFallbackHandler(bytes calldata callData)\\n        private\\n        returns (bytes memory fallbackRet)\\n    {\\n        // get handler for specific function selector\\n        FallbackHandler storage $fallbacks = $fallbackStorage[msg.sender][msg.sig];\\n        address handler = $fallbacks.handler;\\n        CallType calltype = $fallbacks.calltype;\\n        // if no handler is set for the msg.sig, revert\\n        if (handler == address(0)) revert NoFallbackHandler(msg.sig);\\n\\n        // according to ERC7579, when calling to fallback modules, ERC2771 msg.sender has to be\\n        // appended to the calldata, this allows fallback modules to implement\\n        // authorization control\\n        if (calltype == CALLTYPE_STATIC) {\\n            return _staticcallReturn({\\n                safe: ISafe(msg.sender),\\n                target: handler,\\n                callData: abi.encodePacked(callData, _msgSender()) // append ERC2771\\n             });\\n        }\\n        if (calltype == CALLTYPE_SINGLE) {\\n            return _execReturn({\\n                safe: ISafe(msg.sender),\\n                target: handler,\\n                value: 0,\\n                callData: abi.encodePacked(callData, _msgSender()) // append ERC2771\\n             });\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                        HOOK MODULES                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    mapping(address smartAccount => address globalHook) internal $globalHook;\\n    mapping(address smartAccount => mapping(bytes4 => address hook)) internal $hookManager;\\n\\n    /**\\n     * Run precheck hook for global and function selector specific\\n     */\\n    function _preHooks(\\n        address globalHook,\\n        address sigHook\\n    )\\n        internal\\n        returns (bytes memory global, bytes memory sig)\\n    {\\n        if (globalHook != address(0)) {\\n            global = _execReturn({\\n                safe: ISafe(msg.sender),\\n                target: globalHook,\\n                value: 0,\\n                callData: abi.encodeCall(IHook.preCheck, (_msgSender(), msg.value, msg.data))\\n            });\\n            global = abi.decode(global, (bytes));\\n        }\\n        if (sigHook != address(0)) {\\n            sig = _execReturn({\\n                safe: ISafe(msg.sender),\\n                target: sigHook,\\n                value: 0,\\n                callData: abi.encodeCall(IHook.preCheck, (_msgSender(), msg.value, msg.data))\\n            });\\n            sig = abi.decode(sig, (bytes));\\n        }\\n    }\\n\\n    // Run post hooks (global and function sig)\\n    function _postHooks(\\n        address globalHook,\\n        address sigHook,\\n        bytes memory global,\\n        bytes memory sig\\n    )\\n        internal\\n    {\\n        if (globalHook != address(0)) {\\n            _exec({\\n                safe: ISafe(msg.sender),\\n                target: globalHook,\\n                value: 0,\\n                callData: abi.encodeCall(IHook.postCheck, (global))\\n            });\\n        }\\n        if (sigHook != address(0)) {\\n            _exec({\\n                safe: ISafe(msg.sender),\\n                target: sigHook,\\n                value: 0,\\n                callData: abi.encodeCall(IHook.postCheck, (sig))\\n            });\\n        }\\n    }\\n\\n    /**\\n     * modifier that executes global hook, and function signature specific hook if enabled\\n     */\\n    modifier withHook(bytes4 selector) {\\n        address globalHook = $globalHook[msg.sender];\\n        address sigHook = $hookManager[msg.sender][selector];\\n        (bytes memory global, bytes memory sig) = _preHooks(globalHook, sigHook);\\n        _;\\n        _postHooks(globalHook, sigHook, global, sig);\\n    }\\n\\n    function _installHook(\\n        address hook,\\n        bytes calldata data\\n    )\\n        internal\\n        virtual\\n        withRegistry(hook, MODULE_TYPE_HOOK)\\n        returns (bytes memory moduleInitData)\\n    {\\n        (HookType hookType, bytes4 selector, bytes memory initData) =\\n            abi.decode(data, (HookType, bytes4, bytes));\\n        address currentHook;\\n\\n        // handle global hooks\\n        if (hookType == HookType.GLOBAL && selector == 0x0) {\\n            currentHook = $globalHook[msg.sender];\\n            // Dont allow hooks to be overwritten. If a hook is currently installed, it must be\\n            // uninstalled first\\n            if (currentHook != address(0)) {\\n                revert HookAlreadyInstalled(currentHook);\\n            }\\n            $globalHook[msg.sender] = hook;\\n        } else if (hookType == HookType.SIG) {\\n            // Dont allow hooks to be overwritten. If a hook is currently installed, it must be\\n            // uninstalled first\\n            if (currentHook != address(0)) {\\n                revert HookAlreadyInstalled(currentHook);\\n            }\\n            currentHook = $hookManager[msg.sender][selector];\\n            $hookManager[msg.sender][selector] = hook;\\n        } else {\\n            revert InvalidHookType();\\n        }\\n\\n        return initData;\\n    }\\n\\n    function _uninstallHook(\\n        address, /*hook*/\\n        bytes calldata data\\n    )\\n        internal\\n        virtual\\n        returns (bytes memory moduleDeInitData)\\n    {\\n        HookType hookType;\\n        bytes4 selector;\\n        (hookType, selector, moduleDeInitData) = abi.decode(data, (HookType, bytes4, bytes));\\n        if (hookType == HookType.GLOBAL && selector == 0x0) {\\n            delete $globalHook[msg.sender];\\n        } else if (hookType == HookType.SIG) {\\n            delete $hookManager[msg.sender][selector];\\n        } else {\\n            revert InvalidHookType();\\n        }\\n    }\\n\\n    function _getCurrentHook(\\n        HookType hookType,\\n        bytes4 selector\\n    )\\n        internal\\n        view\\n        returns (address hook)\\n    {\\n        // handle global hooks\\n        if (hookType == HookType.GLOBAL && selector == 0x0) {\\n            hook = $globalHook[msg.sender];\\n        }\\n        if (hookType == HookType.SIG) {\\n            hook = $hookManager[msg.sender][selector];\\n        }\\n    }\\n\\n    function _isHookInstalled(\\n        address module,\\n        bytes calldata context\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        (HookType hookType, bytes4 selector) = abi.decode(context, (HookType, bytes4));\\n        address hook = _getCurrentHook({ hookType: hookType, selector: selector });\\n        return hook == module;\\n    }\\n\\n    function getActiveHook(bytes4 selector) public view returns (address hook) {\\n        return $hookManager[msg.sender][selector];\\n    }\\n\\n    function getActiveHook() public view returns (address hook) {\\n        return $globalHook[msg.sender];\\n    }\\n\\n    // solhint-disable-next-line code-complexity\\n    function _multiTypeInstall(\\n        address module,\\n        bytes calldata initData\\n    )\\n        internal\\n        returns (bytes memory _moduleInitData)\\n    {\\n        uint256[] calldata types;\\n        bytes[] calldata contexts;\\n        bytes calldata moduleInitData;\\n\\n        // equivalent of:\\n        // (types, contexs, moduleInitData) = abi.decode(initData,(uint[],bytes[],bytes)\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            let offset := initData.offset\\n            let baseOffset := offset\\n            let dataPointer := add(baseOffset, calldataload(offset))\\n\\n            types.offset := add(dataPointer, 32)\\n            types.length := calldataload(dataPointer)\\n            offset := add(offset, 32)\\n\\n            dataPointer := add(baseOffset, calldataload(offset))\\n            contexts.offset := add(dataPointer, 32)\\n            contexts.length := calldataload(dataPointer)\\n            offset := add(offset, 32)\\n\\n            dataPointer := add(baseOffset, calldataload(offset))\\n            moduleInitData.offset := add(dataPointer, 32)\\n            moduleInitData.length := calldataload(dataPointer)\\n        }\\n\\n        uint256 length = types.length;\\n        if (contexts.length != length) revert InvalidInput();\\n\\n        for (uint256 i; i < length; i++) {\\n            uint256 _type = types[i];\\n\\n            /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n            /*                      INSTALL VALIDATORS                    */\\n            /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n            if (_type == MODULE_TYPE_VALIDATOR) {\\n                _installValidator(module, contexts[i]);\\n            }\\n            /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n            /*                       INSTALL EXECUTORS                    */\\n            /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n            else if (_type == MODULE_TYPE_EXECUTOR) {\\n                _installExecutor(module, contexts[i]);\\n            }\\n            /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n            /*                       INSTALL FALLBACK                     */\\n            /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n            else if (_type == MODULE_TYPE_FALLBACK) {\\n                _installFallbackHandler(module, contexts[i]);\\n            }\\n            /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n            /*          INSTALL HOOK (global or sig specific)             */\\n            /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n            else if (_type == MODULE_TYPE_HOOK) {\\n                _installHook(module, contexts[i]);\\n            }\\n        }\\n        _moduleInitData = moduleInitData;\\n    }\\n}\\n\",\"keccak256\":\"0xc4504970979245ad53cf3802e5e4621cea2b668205b0776f2ff1ba8d348c6eb2\",\"license\":\"MIT\"},\"contracts/safe7579/core/RegistryAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport { IERC7484 } from \\\"../interfaces/IERC7484.sol\\\";\\nimport { ExecutionHelper } from \\\"./ExecutionHelper.sol\\\";\\nimport { ISafe } from \\\"../interfaces/ISafe.sol\\\";\\nimport { ISafe7579 } from \\\"../ISafe7579.sol\\\";\\n\\n/**\\n * IERC7484 Registry adapter.\\n * this feature is opt-in. The smart account owner can choose to use the registry and which\\n * attesters to trust.\\n * @author zeroknots.eth | rhinestone.wtf\\n */\\nabstract contract RegistryAdapter is ISafe7579, ExecutionHelper {\\n    mapping(address smartAccount => IERC7484 registry) internal $registry;\\n\\n    modifier withRegistry(address module, uint256 moduleType) {\\n        _checkRegistry(module, moduleType);\\n        _;\\n    }\\n\\n    /**\\n     * Check on ERC7484 Registry, if suffcient attestations were made\\n     * This will revert, if not succicient valid attestations are on the registry\\n     */\\n    function _checkRegistry(address module, uint256 moduleType) internal view {\\n        IERC7484 registry = $registry[msg.sender];\\n        if (address(registry) != address(0)) {\\n            // this will revert if attestations / threshold are not met\\n            registry.checkForAccount(msg.sender, module, moduleType);\\n        }\\n    }\\n\\n    /**\\n     * Configure ERC7484 Registry for Safe\\n     */\\n    function _configureRegistry(\\n        IERC7484 registry,\\n        address[] calldata attesters,\\n        uint8 threshold\\n    )\\n        internal\\n    {\\n        $registry[msg.sender] = registry;\\n        _exec({\\n            safe: ISafe(msg.sender),\\n            target: address(registry),\\n            value: 0,\\n            callData: abi.encodeCall(IERC7484.trustAttesters, (threshold, attesters))\\n        });\\n        emit ERC7484RegistryConfigured(msg.sender, registry);\\n    }\\n}\\n\",\"keccak256\":\"0x6f8f93f5134be3fd6352e5618b84f9278b3b44d4ea9dead62b6a785f573e4e45\",\"license\":\"MIT\"},\"contracts/safe7579/core/SetupDCUtil.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.23;\\n\\nimport { Safe7579DCUtil } from \\\"../utils/DCUtil.sol\\\";\\n\\n/**\\n * Deployes Safe7579DCUtil\\n */\\nabstract contract Safe7579DCUtilSetup {\\n    address internal UTIL;\\n\\n    constructor() {\\n        UTIL = address(new Safe7579DCUtil());\\n    }\\n}\\n\",\"keccak256\":\"0x1afcf4950e66a351f9fdd30a0fb0118f2922c37a4a584b60df93366dead54c22\",\"license\":\"MIT\"},\"contracts/safe7579/external/ERC7579.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable no-unused-import */\\nimport { MSAFactory as ERC7579AccountFactory } from \\\"erc7579/MSAFactory.sol\\\";\\nimport { MSAAdvanced as ERC7579Account } from \\\"erc7579/MSAAdvanced.sol\\\";\\nimport { Execution, IERC7579Account } from \\\"erc7579/interfaces/IERC7579Account.sol\\\";\\nimport {\\n    IModule as IERC7579Module,\\n    IValidator as IERC7579Validator,\\n    IExecutor as IERC7579Executor,\\n    IHook as IERC7579Hook,\\n    IFallback as IERC7579Fallback,\\n    MODULE_TYPE_VALIDATOR,\\n    MODULE_TYPE_EXECUTOR,\\n    MODULE_TYPE_HOOK,\\n    MODULE_TYPE_FALLBACK\\n} from \\\"erc7579/interfaces/IERC7579Module.sol\\\";\\n\\nimport {\\n    ModeLib as ERC7579ModeLib,\\n    ModeCode,\\n    CallType,\\n    ExecType,\\n    ModePayload,\\n    CALLTYPE_SINGLE,\\n    CALLTYPE_BATCH,\\n    CALLTYPE_DELEGATECALL,\\n    EXECTYPE_DEFAULT,\\n    MODE_DEFAULT\\n} from \\\"erc7579/lib/ModeLib.sol\\\";\\nimport { Execution, ExecutionLib as ERC7579ExecutionLib } from \\\"erc7579/lib/ExecutionLib.sol\\\";\\n\\nimport {\\n    Bootstrap as ERC7579Bootstrap,\\n    BootstrapConfig as ERC7579BootstrapConfig\\n} from \\\"erc7579/utils/Bootstrap.sol\\\";\\n/* solhint-enable no-unused-import */\",\"keccak256\":\"0x1b7b6abd1abcb25b27f79008941523c83f0965817c0d9384419c2423acc1fac0\",\"license\":\"MIT\"},\"contracts/safe7579/interfaces/IERC1271.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.20;\\n\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param _dataHash Arbitrary length data signed on behalf of address(this)\\n     * @param _signature Signature byte array associated with _data\\n     *\\n     * MUST return the bytes4 magic value 0x1626ba7e when function passes.\\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc >\\n     * 0.5)\\n     * MUST allow external calls\\n     */\\n    function isValidSignature(\\n        bytes32 _dataHash,\\n        bytes calldata _signature\\n    )\\n        external\\n        view\\n        returns (bytes4);\\n}\\n\",\"keccak256\":\"0xb393da93ddb9aca17c3a952bd0c667f190cbf8e0abc2b63c075951469deaa21a\",\"license\":\"LGPL-3.0-only\"},\"contracts/safe7579/interfaces/IERC7484.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC7484 {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*          Check with Registry internal attesters            */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n    function check(address module) external view;\\n\\n    function checkForAccount(address smartAccount, address module) external view;\\n\\n    function check(address module, uint256 moduleType) external view;\\n\\n    function checkForAccount(\\n        address smartAccount,\\n        address module,\\n        uint256 moduleType\\n    )\\n        external\\n        view;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*              Check with external attester(s)               */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    function check(address module, address attester) external view;\\n\\n    function check(address module, uint256 moduleType, address attester) external view;\\n\\n    function checkN(\\n        address module,\\n        address[] calldata attesters,\\n        uint256 threshold\\n    )\\n        external\\n        view;\\n\\n    function checkN(\\n        address module,\\n        uint256 moduleType,\\n        address[] calldata attesters,\\n        uint256 threshold\\n    )\\n        external\\n        view;\\n\\n    function trustAttesters(uint8 threshold, address[] calldata attesters) external;\\n}\\n\",\"keccak256\":\"0xf1f6b1b94f6c3ce7413558cc28be572cd16afec8ecc9fbde4cb5cc5b482f5a95\",\"license\":\"MIT\"},\"contracts/safe7579/interfaces/IERC7579Account.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { CallType, ExecType, ModeCode } from \\\"../lib/ModeLib.sol\\\";\\n\\nstruct Execution {\\n    address target;\\n    uint256 value;\\n    bytes callData;\\n}\\n\\ninterface IERC7579AccountEvents {\\n    event ModuleInstalled(uint256 moduleTypeId, address module);\\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\\n}\\n\\ninterface IERC7579Account is IERC7579AccountEvents {\\n    // Error thrown when an unsupported ModuleType is requested\\n    error UnsupportedModuleType(uint256 moduleTypeId);\\n    // Error thrown when an execution with an unsupported CallType was made\\n    error UnsupportedCallType(CallType callType);\\n    // Error thrown when an execution with an unsupported ExecType was made\\n    error UnsupportedExecType(ExecType execType);\\n    // Error thrown when account initialization fails\\n    error AccountInitializationFailed();\\n    /**\\n     * @dev Executes a transaction on behalf of the account.\\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * If a mode is requested that is not supported by the Account, it MUST revert\\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\\n     * @param executionCalldata The encoded execution call data\\n     */\\n\\n    function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\\n\\n    /**\\n     * @dev Executes a transaction on behalf of the account.\\n     *         This function is intended to be called by Executor Modules\\n     * @dev Ensure adequate authorization control: i.e. onlyExecutorModule\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * If a mode is requested that is not supported by the Account, it MUST revert\\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\\n     * @param executionCalldata The encoded execution call data\\n     */\\n    function executeFromExecutor(\\n        ModeCode mode,\\n        bytes calldata executionCalldata\\n    )\\n        external\\n        payable\\n        returns (bytes[] memory returnData);\\n\\n    /**\\n     * @dev ERC-1271 isValidSignature\\n     *         This function is intended to be used to validate a smart account signature\\n     * and may forward the call to a validator module\\n     *\\n     * @param hash The hash of the data that is signed\\n     * @param data The data that is signed\\n     */\\n    function isValidSignature(bytes32 hash, bytes calldata data) external returns (bytes4);\\n\\n    /**\\n     * @dev installs a Module of a certain type on the smart account\\n     * @dev Implement Authorization control of your chosing\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     * @param module the module address\\n     * @param initData arbitrary data that may be required on the module during `onInstall`\\n     * initialization.\\n     */\\n    function installModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata initData\\n    )\\n        external\\n        payable;\\n\\n    /**\\n     * @dev uninstalls a Module of a certain type on the smart account\\n     * @dev Implement Authorization control of your chosing\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     * @param module the module address\\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\\n     * de-initialization.\\n     */\\n    function uninstallModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata deInitData\\n    )\\n        external\\n        payable;\\n\\n    /**\\n     * Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\\n     * @param encodedMode the encoded mode\\n     */\\n    function supportsExecutionMode(ModeCode encodedMode) external view returns (bool);\\n\\n    /**\\n     * Function to check if the account supports installation of a certain module type Id\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     */\\n    function supportsModule(uint256 moduleTypeId) external view returns (bool);\\n\\n    /**\\n     * Function to check if the account has a certain module installed\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\\n     *            thus may be necessary to query multiple module types\\n     * @param module the module address\\n     * @param additionalContext additional context data that the smart account may interpret to\\n     *                          identifiy conditions under which the module is installed.\\n     *                          usually this is not necessary, but for some special hooks that\\n     *                          are stored in mappings, this param might be needed\\n     */\\n    function isModuleInstalled(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata additionalContext\\n    )\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the account id of the smart account\\n     * @return accountImplementationId the account id of the smart account\\n     * the accountId should be structured like so:\\n     *        \\\"vendorname.accountname.semver\\\"\\n     */\\n    function accountId() external view returns (string memory accountImplementationId);\\n}\\n\",\"keccak256\":\"0x55c67ffa09b0087e97322a0881494dd497250af4586904403181c536baadb164\",\"license\":\"MIT\"},\"contracts/safe7579/interfaces/IERC7579Module.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { PackedUserOperation } from \\\"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\\\";\\n\\nuint256 constant VALIDATION_SUCCESS = 0;\\nuint256 constant VALIDATION_FAILED = 1;\\n\\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\\nuint256 constant MODULE_TYPE_FALLBACK = 3;\\nuint256 constant MODULE_TYPE_HOOK = 4;\\n\\ninterface IModule {\\n    error AlreadyInitialized(address smartAccount);\\n    error NotInitialized(address smartAccount);\\n\\n    /**\\n     * @dev This function is called by the smart account during installation of the module\\n     * @param data arbitrary data that may be required on the module during `onInstall`\\n     * initialization\\n     *\\n     * MUST revert on error (i.e. if module is already enabled)\\n     */\\n    function onInstall(bytes calldata data) external;\\n\\n    /**\\n     * @dev This function is called by the smart account during uninstallation of the module\\n     * @param data arbitrary data that may be required on the module during `onUninstall`\\n     * de-initialization\\n     *\\n     * MUST revert on error\\n     */\\n    function onUninstall(bytes calldata data) external;\\n\\n    /**\\n     * @dev Returns boolean value if module is a certain type\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     *\\n     * MUST return true if the module is of the given type and false otherwise\\n     */\\n    function isModuleType(uint256 moduleTypeId) external view returns (bool);\\n\\n    /**\\n     * @dev Returns if the module was already initialized for a provided smartaccount\\n     */\\n    function isInitialized(address smartAccount) external view returns (bool);\\n}\\n\\ninterface IValidator is IModule {\\n    error InvalidTargetAddress(address target);\\n\\n    /**\\n     * @dev Validates a transaction on behalf of the account.\\n     *         This function is intended to be called by the MSA during the ERC-4337 validaton phase\\n     *         Note: solely relying on bytes32 hash and signature is not suffcient for some\\n     * validation implementations (i.e. SessionKeys often need access to userOp.calldata)\\n     * @param userOp The user operation to be validated. The userOp MUST NOT contain any metadata.\\n     * The MSA MUST clean up the userOp before sending it to the validator.\\n     * @param userOpHash The hash of the user operation to be validated\\n     * @return return value according to ERC-4337\\n     */\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash\\n    )\\n        external\\n        returns (uint256);\\n\\n    /**\\n     * Validator can be used for ERC-1271 validation\\n     */\\n    function isValidSignatureWithSender(\\n        address sender,\\n        bytes32 hash,\\n        bytes calldata data\\n    )\\n        external\\n        view\\n        returns (bytes4);\\n}\\n\\ninterface IExecutor is IModule { }\\n\\ninterface IHook is IModule {\\n    function preCheck(\\n        address msgSender,\\n        uint256 msgValue,\\n        bytes calldata msgData\\n    )\\n        external\\n        returns (bytes memory hookData);\\n\\n    function postCheck(bytes calldata hookData) external returns (bool);\\n}\\n\\ninterface IFallback is IModule { }\",\"keccak256\":\"0xed0aae999a2f369d2ce6bed6609c2fb58612fc3a638c1a6845518f2b0590f31d\",\"license\":\"MIT\"},\"contracts/safe7579/interfaces/ISafe.sol\":{\"content\":\"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\ninterface ISafe {\\n    function setup(\\n        address[] calldata _owners,\\n        uint256 _threshold,\\n        address to,\\n        bytes calldata data,\\n        address fallbackHandler,\\n        address paymentToken,\\n        uint256 payment,\\n        address payable paymentReceiver\\n    )\\n        external;\\n\\n    /**\\n     * @dev Allows a Module to execute a Safe transaction without any further confirmations.\\n     * @param to Destination address of module transaction.\\n     * @param value Ether value of module transaction.\\n     * @param data Data payload of module transaction.\\n     * @param operation Operation type of module transaction.\\n     */\\n    function execTransactionFromModule(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        uint8 operation\\n    )\\n        external\\n        returns (bool success);\\n\\n    /**\\n     * @notice Execute `operation` (0: Call, 1: DelegateCall) to `to` with `value` (Native Token)\\n     * and return data\\n     * @param to Destination address of module transaction.\\n     * @param value Ether value of module transaction.\\n     * @param data Data payload of module transaction.\\n     * @param operation Operation type of module transaction.\\n     * @return success Boolean flag indicating if the call succeeded.\\n     * @return returnData Data returned by the call.\\n     */\\n    function execTransactionFromModuleReturnData(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        uint8 operation\\n    )\\n        external\\n        returns (bool success, bytes memory returnData);\\n\\n    /**\\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert\\n     * otherwise.\\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\\n     * @param data That should be signed (this is passed to an external validator contract)\\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract\\n     * signature (EIP-1271) or approved hash.\\n     */\\n    function checkSignatures(\\n        bytes32 dataHash,\\n        bytes memory data,\\n        bytes memory signatures\\n    )\\n        external\\n        view;\\n\\n    function signedMessages(bytes32) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator for this contract, as defined in the EIP-712 standard.\\n     * @return bytes32 The domain separator hash.\\n     */\\n    function domainSeparator() external view returns (bytes32);\\n\\n    function getStorageAt(uint256 offset, uint256 length) external view returns (bytes memory);\\n\\n    /**\\n     * @dev Returns array of modules.\\n     * @param start Start of the page.\\n     * @param pageSize Maximum number of modules that should be returned.\\n     * @return array Array of modules.\\n     * @return next Start of the next page.\\n     */\\n    function getModulesPaginated(\\n        address start,\\n        uint256 pageSize\\n    )\\n        external\\n        view\\n        returns (address[] memory array, address next);\\n\\n    /**\\n     * @notice Enables the module `module` for the Safe.\\n     * @dev This can only be done via a Safe transaction.\\n     * @param module Module to be enabled.\\n     */\\n    function enableModule(address module) external;\\n\\n    function VERSION() external view returns (string memory);\\n\\n    function simulateAndRevert(address targetContract, bytes memory calldataPayload) external;\\n}\\n\",\"keccak256\":\"0xfd9de7afe85ae40bacc324c2d9a70e77318681ed80245076600db1359e592888\",\"license\":\"LGPL-3.0-only\"},\"contracts/safe7579/interfaces/ISafeOp.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nbytes32 constant SAFE_OP_TYPEHASH =\\n    0x84aa190356f56b8c87825f54884392a9907c23ee0f8e1ea86336b763faf021bd;\\n\\ninterface ISafeOp {\\n    struct EncodedSafeOpStruct {\\n        bytes32 typeHash;\\n        address safe;\\n        uint256 nonce;\\n        bytes32 initCodeHash;\\n        bytes32 callDataHash;\\n        uint256 callGasLimit;\\n        uint256 verificationGasLimit;\\n        uint256 preVerificationGas;\\n        uint256 maxFeePerGas;\\n        uint256 maxPriorityFeePerGas;\\n        bytes32 paymasterAndDataHash;\\n        uint48 validAfter;\\n        uint48 validUntil;\\n        address entryPoint;\\n    }\\n}\\n\",\"keccak256\":\"0xb7bff9fad01b661a835eece9964f338fbdb4c80d14d438de5c25ea888eb29808\",\"license\":\"MIT\"},\"contracts/safe7579/lib/ExecutionLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { Execution } from \\\"../interfaces/IERC7579Account.sol\\\";\\n\\n/**\\n * Helper Library for decoding Execution calldata\\n * malloc for memory allocation is bad for gas. use this assembly instead\\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\\n */\\nlibrary ExecutionLib {\\n    function decodeBatch(bytes calldata callData)\\n        internal\\n        pure\\n        returns (Execution[] calldata executionBatch)\\n    {\\n        /*\\n         * Batch Call Calldata Layout\\n         * Offset (in bytes)    | Length (in bytes) | Contents\\n         * 0x0                  | 0x4               | bytes4 function selector\\n        *  0x4                  | -                 |\\n        abi.encode(IERC7579Execution.Execution[])\\n         */\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            let dataPointer := add(callData.offset, calldataload(callData.offset))\\n\\n            // Extract the ERC7579 Executions\\n            executionBatch.offset := add(dataPointer, 32)\\n            executionBatch.length := calldataload(dataPointer)\\n        }\\n    }\\n\\n    function encodeBatch(Execution[] memory executions)\\n        internal\\n        pure\\n        returns (bytes memory callData)\\n    {\\n        callData = abi.encode(executions);\\n    }\\n\\n    function decodeSingle(bytes calldata executionCalldata)\\n        internal\\n        pure\\n        returns (address target, uint256 value, bytes calldata callData)\\n    {\\n        target = address(bytes20(executionCalldata[0:20]));\\n        value = uint256(bytes32(executionCalldata[20:52]));\\n        callData = executionCalldata[52:];\\n    }\\n\\n    function encodeSingle(\\n        address target,\\n        uint256 value,\\n        bytes memory callData\\n    )\\n        internal\\n        pure\\n        returns (bytes memory userOpCalldata)\\n    {\\n        userOpCalldata = abi.encodePacked(target, value, callData);\\n    }\\n}\\n\",\"keccak256\":\"0x5852404ef72dbe607a5402af160494067e7d9e6bf1fbf9460ff309e53b4db399\",\"license\":\"MIT\"},\"contracts/safe7579/lib/ModeLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/**\\n * @title ModeLib\\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\\n * To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\\n * encoding is used.\\n *    Function Signature of execute function:\\n *           function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\\n * This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\\n * context.\\n * NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\\n * implement\\n * more complex execution modes may use the entire bytes32.\\n *\\n * |--------------------------------------------------------------------|\\n * | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\\n * |--------------------------------------------------------------------|\\n * | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\\n * |--------------------------------------------------------------------|\\n *\\n * CALLTYPE: 1 byte\\n * CallType is used to determine how the executeCalldata paramter of the execute function has to be\\n * decoded.\\n * It can be either single, batch or delegatecall. In the future different calls could be added.\\n * CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\\n *\\n * EXECTYPE: 1 byte\\n * ExecType is used to determine how the account should handle the execution.\\n * It can indicate if the execution should revert on failure or continue execution.\\n * In the future more execution modes may be added.\\n * Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\\n * a batch fails, the entire batch is reverted\\n *\\n * UNUSED: 4 bytes\\n * Unused bytes are reserved for future use.\\n *\\n * ModeSelector: bytes4\\n * The \\\"optional\\\" mode selector can be used by account vendors, to implement custom behavior in\\n * their accounts.\\n * the way a ModeSelector is to be calculated is bytes4(keccak256(\\\"vendorname.featurename\\\"))\\n * this is to prevent collisions between different vendors, while allowing innovation and the\\n * development of new features without coordination between ERC-7579 implementing accounts\\n *\\n * ModePayload: 22 bytes\\n * Mode payload is used to pass additional data to the smart account execution, this may be\\n * interpreted depending on the ModeSelector\\n *\\n * ExecutionCallData: n bytes\\n * single, delegatecall or batch exec abi.encoded as bytes\\n */\\n\\n// Custom type for improved developer experience\\ntype ModeCode is bytes32;\\n\\ntype CallType is bytes1;\\n\\ntype ExecType is bytes1;\\n\\ntype ModeSelector is bytes4;\\n\\ntype ModePayload is bytes22;\\n\\n// Default CallType\\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\\n// Batched CallType\\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\\n// @dev Implementing delegatecall is OPTIONAL!\\n// implement delegatecall with extreme care.\\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\\n\\n// @dev default behavior is to revert on failure\\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\\n// Since this is value 0x00, no additional encoding is required for simple accounts\\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\\n// @dev account may elect to change execution behavior. For example \\\"try exec\\\" / \\\"allow fail\\\"\\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\\n\\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\\n// Example declaration of a custom mode selector\\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\\\"default.mode.offset\\\")));\\n\\n/**\\n * @dev ModeLib is a helper library to encode/decode ModeCodes\\n */\\nlibrary ModeLib {\\n    function decode(ModeCode mode)\\n        internal\\n        pure\\n        returns (\\n            CallType _calltype,\\n            ExecType _execType,\\n            ModeSelector _modeSelector,\\n            ModePayload _modePayload\\n        )\\n    {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            _calltype := mode\\n            _execType := shl(8, mode)\\n            _modeSelector := shl(48, mode)\\n            _modePayload := shl(80, mode)\\n        }\\n    }\\n\\n    function encode(\\n        CallType callType,\\n        ExecType execType,\\n        ModeSelector mode,\\n        ModePayload payload\\n    )\\n        internal\\n        pure\\n        returns (ModeCode)\\n    {\\n        return ModeCode.wrap(\\n            bytes32(\\n                abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)\\n            )\\n        );\\n    }\\n\\n    function encodeSimpleBatch() internal pure returns (ModeCode mode) {\\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\\n    }\\n\\n    function encodeSimpleSingle() internal pure returns (ModeCode mode) {\\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\\n    }\\n\\n    function getCallType(ModeCode mode) internal pure returns (CallType calltype) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            calltype := mode\\n        }\\n    }\\n}\\n\\nusing { eqModeSelector as == } for ModeSelector global;\\nusing { eqCallType as == } for CallType global;\\nusing { eqExecType as == } for ExecType global;\\n\\nfunction eqCallType(CallType a, CallType b) pure returns (bool) {\\n    return CallType.unwrap(a) == CallType.unwrap(b);\\n}\\n\\nfunction eqExecType(ExecType a, ExecType b) pure returns (bool) {\\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\\n}\\n\\nfunction eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\\n}\\n\",\"keccak256\":\"0xcfd7f705b61c9e23c6847c964719b7ccd62773692777a4be9b473cf5209c89fd\",\"license\":\"MIT\"},\"contracts/safe7579/utils/DCUtil.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.22;\\n\\nimport { Execution } from \\\"../interfaces/IERC7579Account.sol\\\";\\nimport { IModule as IERC7579Module } from \\\"../interfaces/IERC7579Module.sol\\\";\\n\\ncontract ModuleInstallUtil {\\n    event ModuleInstalled(uint256 moduleTypeId, address module);\\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\\n\\n    function installModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata initData\\n    )\\n        external\\n    {\\n        IERC7579Module(module).onInstall(initData);\\n        emit ModuleInstalled(moduleTypeId, address(module));\\n    }\\n\\n    function unInstallModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata initData\\n    )\\n        external\\n    {\\n        IERC7579Module(module).onUninstall(initData);\\n        emit ModuleUninstalled(moduleTypeId, address(module));\\n    }\\n}\\n\\ncontract BatchedExecUtil {\\n    function tryExecute(Execution[] calldata executions) external returns (bool success) {\\n        uint256 length = executions.length;\\n\\n        for (uint256 i; i < length; i++) {\\n            Execution calldata _exec = executions[i];\\n            (success,) = _tryExecute(_exec.target, _exec.value, _exec.callData);\\n        }\\n    }\\n\\n    function execute(Execution[] calldata executions) external {\\n        uint256 length = executions.length;\\n\\n        for (uint256 i; i < length; i++) {\\n            Execution calldata _exec = executions[i];\\n            _execute(_exec.target, _exec.value, _exec.callData);\\n        }\\n    }\\n\\n    function executeReturn(Execution[] calldata executions)\\n        external\\n        returns (bytes[] memory result)\\n    {\\n        uint256 length = executions.length;\\n        result = new bytes[](length);\\n\\n        for (uint256 i; i < length; i++) {\\n            Execution calldata _exec = executions[i];\\n            result[i] = _execute(_exec.target, _exec.value, _exec.callData);\\n        }\\n    }\\n\\n    function tryExecuteReturn(Execution[] calldata executions)\\n        external\\n        returns (bool[] memory success, bytes[] memory result)\\n    {\\n        uint256 length = executions.length;\\n        result = new bytes[](length);\\n        success = new bool[](length);\\n\\n        for (uint256 i; i < length; i++) {\\n            Execution calldata _exec = executions[i];\\n            (success[i], result[i]) = _tryExecute(_exec.target, _exec.value, _exec.callData);\\n        }\\n    }\\n\\n    function _execute(\\n        address target,\\n        uint256 value,\\n        bytes calldata callData\\n    )\\n        internal\\n        virtual\\n        returns (bytes memory result)\\n    {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, callData.offset, callData.length)\\n            if iszero(call(gas(), target, value, result, callData.length, codesize(), 0x00)) {\\n                // Bubble up the revert if the call reverts.\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n\\n    function _tryExecute(\\n        address target,\\n        uint256 value,\\n        bytes calldata callData\\n    )\\n        internal\\n        virtual\\n        returns (bool success, bytes memory result)\\n    {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, callData.offset, callData.length)\\n            success := iszero(call(gas(), target, value, result, callData.length, codesize(), 0x00))\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n}\\n\\ncontract Safe7579DCUtil is ModuleInstallUtil, BatchedExecUtil {\\n    function staticCall(address target, bytes memory data) external view {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            let ptr := mload(0x40)\\n            let success := staticcall(gas(), target, add(data, 0x20), mload(data), 0x00, 0x00)\\n            returndatacopy(ptr, 0x00, returndatasize())\\n            if success { return(ptr, returndatasize()) }\\n            revert(ptr, returndatasize())\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd9261ef6e698bcd11bc2f02167211df3380bbfd958ef6ad44bbe9608bf50f7fd\",\"license\":\"MIT\"},\"erc7579/MSAAdvanced.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport \\\"./lib/ModeLib.sol\\\";\\nimport { ExecutionLib } from \\\"./lib/ExecutionLib.sol\\\";\\nimport { ExecutionHelper } from \\\"./core/ExecutionHelper.sol\\\";\\nimport { PackedUserOperation } from \\\"account-abstraction/interfaces/PackedUserOperation.sol\\\";\\nimport \\\"./interfaces/IERC7579Module.sol\\\";\\nimport { IERC7579Account } from \\\"./interfaces/IERC7579Account.sol\\\";\\nimport { IMSA } from \\\"./interfaces/IMSA.sol\\\";\\nimport { ModuleManager } from \\\"./core/ModuleManager.sol\\\";\\nimport { HookManager } from \\\"./core/HookManager.sol\\\";\\n\\n/**\\n * @author zeroknots.eth | rhinestone.wtf\\n * Reference implementation of a very simple ERC7579 Account.\\n * This account implements CallType: SINGLE, BATCH and DELEGATECALL.\\n * This account implements ExecType: DEFAULT and TRY.\\n * Hook support is implemented\\n */\\ncontract MSAAdvanced is IMSA, ExecutionHelper, ModuleManager, HookManager {\\n    using ExecutionLib for bytes;\\n    using ModeLib for ModeCode;\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     * @dev this function is only callable by the entry point or the account itself\\n     * @dev this function demonstrates how to implement\\n     * CallType SINGLE and BATCH and ExecType DEFAULT and TRY\\n     * @dev this function demonstrates how to implement hook support (modifier)\\n     */\\n    function execute(\\n        ModeCode mode,\\n        bytes calldata executionCalldata\\n    )\\n        external\\n        payable\\n        onlyEntryPointOrSelf\\n        withHook\\n    {\\n        (CallType callType, ExecType execType,,) = mode.decode();\\n\\n        // check if calltype is batch or single\\n        if (callType == CALLTYPE_BATCH) {\\n            // destructure executionCallData according to batched exec\\n            Execution[] calldata executions = executionCalldata.decodeBatch();\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) _execute(executions);\\n            else if (execType == EXECTYPE_TRY) _tryExecute(executions);\\n            else revert UnsupportedExecType(execType);\\n        } else if (callType == CALLTYPE_SINGLE) {\\n            // destructure executionCallData according to single exec\\n            (address target, uint256 value, bytes calldata callData) =\\n                executionCalldata.decodeSingle();\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) _execute(target, value, callData);\\n            // TODO: implement event emission for tryExecute singleCall\\n            else if (execType == EXECTYPE_TRY) _tryExecute(target, value, callData);\\n            else revert UnsupportedExecType(execType);\\n        } else if (callType == CALLTYPE_DELEGATECALL) {\\n            // destructure executionCallData according to single exec\\n            address delegate = address(uint160(bytes20(executionCalldata[0:20])));\\n            bytes calldata callData = executionCalldata[20:];\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) _executeDelegatecall(delegate, callData);\\n            else if (execType == EXECTYPE_TRY) _tryExecuteDelegatecall(delegate, callData);\\n            else revert UnsupportedExecType(execType);\\n        } else {\\n            revert UnsupportedCallType(callType);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     * @dev this function is only callable by an installed executor module\\n     * @dev this function demonstrates how to implement\\n     * CallType SINGLE and BATCH and ExecType DEFAULT and TRY\\n     * @dev this function demonstrates how to implement hook support (modifier)\\n     */\\n    function executeFromExecutor(\\n        ModeCode mode,\\n        bytes calldata executionCalldata\\n    )\\n        external\\n        payable\\n        onlyExecutorModule\\n        withHook\\n        returns (\\n            bytes[] memory returnData // TODO returnData is not used\\n        )\\n    {\\n        (CallType callType, ExecType execType,,) = mode.decode();\\n\\n        // check if calltype is batch or single\\n        if (callType == CALLTYPE_BATCH) {\\n            // destructure executionCallData according to batched exec\\n            Execution[] calldata executions = executionCalldata.decodeBatch();\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) returnData = _execute(executions);\\n            else if (execType == EXECTYPE_TRY) returnData = _tryExecute(executions);\\n            else revert UnsupportedExecType(execType);\\n        } else if (callType == CALLTYPE_SINGLE) {\\n            // destructure executionCallData according to single exec\\n            (address target, uint256 value, bytes calldata callData) =\\n                executionCalldata.decodeSingle();\\n            returnData = new bytes[](1);\\n            bool success;\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) {\\n                returnData[0] = _execute(target, value, callData);\\n            }\\n            // TODO: implement event emission for tryExecute singleCall\\n            else if (execType == EXECTYPE_TRY) {\\n                (success, returnData[0]) = _tryExecute(target, value, callData);\\n                if (!success) emit TryExecuteUnsuccessful(0, returnData[0]);\\n            } else {\\n                revert UnsupportedExecType(execType);\\n            }\\n        } else if (callType == CALLTYPE_DELEGATECALL) {\\n            // destructure executionCallData according to single exec\\n            address delegate = address(uint160(bytes20(executionCalldata[0:20])));\\n            bytes calldata callData = executionCalldata[20:];\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) _executeDelegatecall(delegate, callData);\\n            else if (execType == EXECTYPE_TRY) _tryExecuteDelegatecall(delegate, callData);\\n            else revert UnsupportedExecType(execType);\\n        } else {\\n            revert UnsupportedCallType(callType);\\n        }\\n    }\\n\\n    /**\\n     * @dev ERC-4337 executeUserOp according to ERC-4337 v0.7\\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\\n     *      The implementation of the function is OPTIONAL\\n     *\\n     * @param userOp PackedUserOperation struct (see ERC-4337 v0.7+)\\n     */\\n    function executeUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash\\n    )\\n        external\\n        payable\\n        onlyEntryPoint\\n    {\\n        bytes calldata callData = userOp.callData[4:];\\n        (bool success,) = address(this).delegatecall(callData);\\n        if (!success) revert ExecutionFailed();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function installModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata initData\\n    )\\n        external\\n        payable\\n        onlyEntryPointOrSelf\\n        withHook\\n    {\\n        if (!IModule(module).isModuleType(moduleTypeId)) revert MismatchModuleTypeId(moduleTypeId);\\n\\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) _installValidator(module, initData);\\n        else if (moduleTypeId == MODULE_TYPE_EXECUTOR) _installExecutor(module, initData);\\n        else if (moduleTypeId == MODULE_TYPE_FALLBACK) _installFallbackHandler(module, initData);\\n        else if (moduleTypeId == MODULE_TYPE_HOOK) _installHook(module, initData);\\n        else revert UnsupportedModuleType(moduleTypeId);\\n        emit ModuleInstalled(moduleTypeId, module);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function uninstallModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata deInitData\\n    )\\n        external\\n        payable\\n        onlyEntryPointOrSelf\\n        withHook\\n    {\\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\\n            _uninstallValidator(module, deInitData);\\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\\n            _uninstallExecutor(module, deInitData);\\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\\n            _uninstallFallbackHandler(module, deInitData);\\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\\n            _uninstallHook(module, deInitData);\\n        } else {\\n            revert UnsupportedModuleType(moduleTypeId);\\n        }\\n        emit ModuleUninstalled(moduleTypeId, module);\\n    }\\n\\n    /**\\n     * @dev ERC-4337 validateUserOp according to ERC-4337 v0.7\\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\\n     * this validation function should decode / sload the validator module to validate the userOp\\n     * and call it.\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * @param userOp PackedUserOperation struct (see ERC-4337 v0.7+)\\n     */\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 missingAccountFunds\\n    )\\n        external\\n        payable\\n        virtual\\n        onlyEntryPoint\\n        payPrefund(missingAccountFunds)\\n        returns (uint256 validSignature)\\n    {\\n        address validator;\\n        // @notice validator encoding in nonce is just an example!\\n        // @notice this is not part of the standard!\\n        // Account Vendors may choose any other way to implement validator selection\\n        uint256 nonce = userOp.nonce;\\n        assembly {\\n            validator := shr(96, nonce)\\n        }\\n\\n        // check if validator is enabled. If not terminate the validation phase.\\n        if (!_isValidatorInstalled(validator)) return VALIDATION_FAILED;\\n\\n        // bubble up the return value of the validator module\\n        validSignature = IValidator(validator).validateUserOp(userOp, userOpHash);\\n    }\\n\\n    /**\\n     * @dev ERC-1271 isValidSignature\\n     *         This function is intended to be used to validate a smart account signature\\n     * and may forward the call to a validator module\\n     *\\n     * @param hash The hash of the data that is signed\\n     * @param data The data that is signed\\n     */\\n    function isValidSignature(\\n        bytes32 hash,\\n        bytes calldata data\\n    )\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bytes4)\\n    {\\n        address validator = address(bytes20(data[0:20]));\\n        if (!_isValidatorInstalled(validator)) revert InvalidModule(validator);\\n        return IValidator(validator).isValidSignatureWithSender(msg.sender, hash, data[20:]);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function isModuleInstalled(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata additionalContext\\n    )\\n        external\\n        view\\n        override\\n        returns (bool)\\n    {\\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\\n            return _isValidatorInstalled(module);\\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\\n            return _isExecutorInstalled(module);\\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\\n            return _isFallbackHandlerInstalled(abi.decode(additionalContext, (bytes4)), module);\\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\\n            return _isHookInstalled(module);\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function accountId() external view virtual override returns (string memory) {\\n        // vendor.flavour.SemVer\\n        return \\\"uMSA.advanced/withHook.v0.1\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function supportsExecutionMode(ModeCode mode)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bool isSupported)\\n    {\\n        (CallType callType, ExecType execType,,) = mode.decode();\\n        if (callType == CALLTYPE_BATCH) isSupported = true;\\n        else if (callType == CALLTYPE_SINGLE) isSupported = true;\\n        else if (callType == CALLTYPE_DELEGATECALL) isSupported = true;\\n        // if callType is not single, batch or delegatecall return false\\n        else return false;\\n\\n        if (execType == EXECTYPE_DEFAULT) isSupported = true;\\n        else if (execType == EXECTYPE_TRY) isSupported = true;\\n        // if execType is not default or try, return false\\n        else return false;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function supportsModule(uint256 modulTypeId) external view virtual override returns (bool) {\\n        if (modulTypeId == MODULE_TYPE_VALIDATOR) return true;\\n        else if (modulTypeId == MODULE_TYPE_EXECUTOR) return true;\\n        else if (modulTypeId == MODULE_TYPE_FALLBACK) return true;\\n        else if (modulTypeId == MODULE_TYPE_HOOK) return true;\\n        else return false;\\n    }\\n\\n    /**\\n     * @dev Initializes the account. Function might be called directly, or by a Factory\\n     * @param data. encoded data that can be used during the initialization phase\\n     */\\n    function initializeAccount(bytes calldata data) public payable virtual {\\n        // checks if already initialized and reverts before setting the state to initialized\\n        _initModuleManager();\\n\\n        // this is just implemented for demonstration purposes. You can use any other initialization\\n        // logic here.\\n        (address bootstrap, bytes memory bootstrapCall) = abi.decode(data, (address, bytes));\\n        (bool success,) = bootstrap.delegatecall(bootstrapCall);\\n        if (!success) revert();\\n    }\\n}\\n\",\"keccak256\":\"0x4e9527aaf0860dcb4e97c73f282795236672c807b6c3b25f6fa1773071d01ff4\",\"license\":\"MIT\"},\"erc7579/MSAFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { LibClone } from \\\"solady/utils/LibClone.sol\\\";\\nimport { IMSA } from \\\"./interfaces/IMSA.sol\\\";\\n\\ncontract MSAFactory {\\n    address public immutable implementation;\\n\\n    constructor(address _msaImplementation) {\\n        implementation = _msaImplementation;\\n    }\\n\\n    function createAccount(\\n        bytes32 salt,\\n        bytes calldata initCode\\n    )\\n        public\\n        payable\\n        virtual\\n        returns (address)\\n    {\\n        bytes32 _salt = _getSalt(salt, initCode);\\n        (bool alreadyDeployed, address account) =\\n            LibClone.createDeterministicERC1967(msg.value, implementation, _salt);\\n\\n        if (!alreadyDeployed) {\\n            IMSA(account).initializeAccount(initCode);\\n        }\\n        return account;\\n    }\\n\\n    function getAddress(\\n        bytes32 salt,\\n        bytes calldata initcode\\n    )\\n        public\\n        view\\n        virtual\\n        returns (address)\\n    {\\n        bytes32 _salt = _getSalt(salt, initcode);\\n        return LibClone.predictDeterministicAddressERC1967(implementation, _salt, address(this));\\n    }\\n\\n    function _getSalt(\\n        bytes32 _salt,\\n        bytes calldata initCode\\n    )\\n        public\\n        pure\\n        virtual\\n        returns (bytes32 salt)\\n    {\\n        salt = keccak256(abi.encodePacked(_salt, initCode));\\n    }\\n}\\n\",\"keccak256\":\"0x59cf4ab16a3c0ce97f3b619be9521292628d21539783ed1b057d45f08c488dd6\",\"license\":\"MIT\"},\"erc7579/core/AccountBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\n/**\\n * @title reference implementation of the minimal modular smart account with Hook Extension\\n * @author zeroknots.eth | rhinestone.wtf\\n */\\ncontract AccountBase {\\n    error AccountAccessUnauthorized();\\n\\n    /////////////////////////////////////////////////////\\n    // Access Control\\n    ////////////////////////////////////////////////////\\n\\n    modifier onlyEntryPointOrSelf() virtual {\\n        if (!(msg.sender == entryPoint() || msg.sender == address(this))) {\\n            revert AccountAccessUnauthorized();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyEntryPoint() virtual {\\n        if (msg.sender != entryPoint()) {\\n            revert AccountAccessUnauthorized();\\n        }\\n        _;\\n    }\\n\\n    function entryPoint() public view virtual returns (address) {\\n        return 0x0000000071727De22E5E9d8BAf0edAc6f37da032;\\n    }\\n\\n    /// @dev Sends to the EntryPoint (i.e. `msg.sender`) the missing funds for this transaction.\\n    /// Subclass MAY override this modifier for better funds management.\\n    /// (e.g. send to the EntryPoint more than the minimum required, so that in future transactions\\n    /// it will not be required to send again)\\n    ///\\n    /// `missingAccountFunds` is the minimum value this modifier should send the EntryPoint,\\n    /// which MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\\n    modifier payPrefund(uint256 missingAccountFunds) virtual {\\n        _;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if missingAccountFunds {\\n                // Ignore failure (it's EntryPoint's job to verify, not the account's).\\n                pop(call(gas(), caller(), missingAccountFunds, codesize(), 0x00, codesize(), 0x00))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x11805c609cfd00250d52f440983ea54daaddc2d2bd0da83676ffef6192fecb82\",\"license\":\"MIT\"},\"erc7579/core/ExecutionHelper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { Execution } from \\\"../interfaces/IERC7579Account.sol\\\";\\n\\n/**\\n * @title Execution\\n * @dev This contract executes calls in the context of this contract.\\n * @author zeroknots.eth | rhinestone.wtf\\n * shoutout to solady (vectorized, ross) for this code\\n * https://github.com/Vectorized/solady/blob/main/src/accounts/ERC4337.sol\\n */\\ncontract ExecutionHelper {\\n    error ExecutionFailed();\\n\\n    event TryExecuteUnsuccessful(uint256 batchExecutionindex, bytes result);\\n\\n    function _execute(Execution[] calldata executions) internal returns (bytes[] memory result) {\\n        uint256 length = executions.length;\\n        result = new bytes[](length);\\n\\n        for (uint256 i; i < length; i++) {\\n            Execution calldata _exec = executions[i];\\n            result[i] = _execute(_exec.target, _exec.value, _exec.callData);\\n        }\\n    }\\n\\n    function _tryExecute(Execution[] calldata executions)\\n        internal\\n        returns (bytes[] memory result)\\n    {\\n        uint256 length = executions.length;\\n        result = new bytes[](length);\\n\\n        for (uint256 i; i < length; i++) {\\n            Execution calldata _exec = executions[i];\\n            bool success;\\n            (success, result[i]) = _tryExecute(_exec.target, _exec.value, _exec.callData);\\n            if (!success) emit TryExecuteUnsuccessful(i, result[i]);\\n        }\\n    }\\n\\n    function _execute(\\n        address target,\\n        uint256 value,\\n        bytes calldata callData\\n    )\\n        internal\\n        virtual\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, callData.offset, callData.length)\\n            if iszero(call(gas(), target, value, result, callData.length, codesize(), 0x00)) {\\n                // Bubble up the revert if the call reverts.\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n\\n    function _tryExecute(\\n        address target,\\n        uint256 value,\\n        bytes calldata callData\\n    )\\n        internal\\n        virtual\\n        returns (bool success, bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, callData.offset, callData.length)\\n            success := call(gas(), target, value, result, callData.length, codesize(), 0x00)\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Execute a delegatecall with `delegate` on this account.\\n    function _executeDelegatecall(\\n        address delegate,\\n        bytes calldata callData\\n    )\\n        internal\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, callData.offset, callData.length)\\n            // Forwards the `data` to `delegate` via delegatecall.\\n            if iszero(delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)) {\\n                // Bubble up the revert if the call reverts.\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Execute a delegatecall with `delegate` on this account and catch reverts.\\n    function _tryExecuteDelegatecall(\\n        address delegate,\\n        bytes calldata callData\\n    )\\n        internal\\n        returns (bool success, bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, callData.offset, callData.length)\\n            // Forwards the `data` to `delegate` via delegatecall.\\n            success := delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa8ccc4cdddbcbb51594644a6a3b96657bae861da6461a149ca8e4c2678da0b20\",\"license\":\"MIT\"},\"erc7579/core/HookManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport \\\"./ModuleManager.sol\\\";\\nimport \\\"../interfaces/IERC7579Account.sol\\\";\\nimport \\\"../interfaces/IERC7579Module.sol\\\";\\n\\n/**\\n * @title reference implementation of HookManager\\n * @author zeroknots.eth | rhinestone.wtf\\n */\\nabstract contract HookManager {\\n    /// @custom:storage-location erc7201:hookmanager.storage.msa\\n    struct HookManagerStorage {\\n        IHook _hook;\\n    }\\n\\n    // keccak256(\\\"hookmanager.storage.msa\\\");\\n    bytes32 constant HOOKMANAGER_STORAGE_LOCATION =\\n        0x36e05829dd1b9a4411d96a3549582172d7f071c1c0db5c573fcf94eb28431608;\\n\\n    error HookPostCheckFailed();\\n    error HookAlreadyInstalled(address currentHook);\\n\\n    modifier withHook() {\\n        address hook = _getHook();\\n        if (hook == address(0)) {\\n            _;\\n        } else {\\n            bytes memory hookData = IHook(hook).preCheck(msg.sender, msg.value, msg.data);\\n            _;\\n            IHook(hook).postCheck(hookData);\\n        }\\n    }\\n\\n    function _setHook(address hook) internal virtual {\\n        bytes32 slot = HOOKMANAGER_STORAGE_LOCATION;\\n        assembly {\\n            sstore(slot, hook)\\n        }\\n    }\\n\\n    function _installHook(address hook, bytes calldata data) internal virtual {\\n        address currentHook = _getHook();\\n        if (currentHook != address(0)) {\\n            revert HookAlreadyInstalled(currentHook);\\n        }\\n        _setHook(hook);\\n        IHook(hook).onInstall(data);\\n    }\\n\\n    function _uninstallHook(address hook, bytes calldata data) internal virtual {\\n        _setHook(address(0));\\n        IHook(hook).onUninstall(data);\\n    }\\n\\n    function _getHook() internal view returns (address _hook) {\\n        bytes32 slot = HOOKMANAGER_STORAGE_LOCATION;\\n        assembly {\\n            _hook := sload(slot)\\n        }\\n    }\\n\\n    function _isHookInstalled(address module) internal view returns (bool) {\\n        return _getHook() == module;\\n    }\\n\\n    function getActiveHook() external view returns (address hook) {\\n        return _getHook();\\n    }\\n}\\n\",\"keccak256\":\"0xea44de4892ede553b9642b7bbcfe35745e5129d5a02bd04c90cfa2e15c5ece77\",\"license\":\"MIT\"},\"erc7579/core/ModuleManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { SentinelListLib, SENTINEL } from \\\"sentinellist/SentinelList.sol\\\";\\nimport {\\n    CallType, CALLTYPE_SINGLE, CALLTYPE_DELEGATECALL, CALLTYPE_STATIC\\n} from \\\"../lib/ModeLib.sol\\\";\\nimport { AccountBase } from \\\"./AccountBase.sol\\\";\\nimport \\\"../interfaces/IERC7579Module.sol\\\";\\nimport \\\"forge-std/interfaces/IERC165.sol\\\";\\nimport \\\"./Receiver.sol\\\";\\n\\n/**\\n * @title ModuleManager\\n * @author zeroknots.eth | rhinestone.wtf\\n * @dev This contract manages Validator, Executor and Fallback modules for the MSA\\n * @dev it uses SentinelList to manage the linked list of modules\\n * NOTE: the linked list is just an example. accounts may implement this differently\\n */\\nabstract contract ModuleManager is AccountBase, Receiver {\\n    using SentinelListLib for SentinelListLib.SentinelList;\\n\\n    error InvalidModule(address module);\\n    error NoFallbackHandler(bytes4 selector);\\n    error CannotRemoveLastValidator();\\n\\n    // keccak256(\\\"modulemanager.storage.msa\\\");\\n    bytes32 internal constant MODULEMANAGER_STORAGE_LOCATION =\\n        0xf88ce1fdb7fb1cbd3282e49729100fa3f2d6ee9f797961fe4fb1871cea89ea02;\\n\\n    struct FallbackHandler {\\n        address handler;\\n        CallType calltype;\\n    }\\n\\n    /// @custom:storage-location erc7201:modulemanager.storage.msa\\n    struct ModuleManagerStorage {\\n        // linked list of validators. List is initialized by initializeAccount()\\n        SentinelListLib.SentinelList $valdiators;\\n        // linked list of executors. List is initialized by initializeAccount()\\n        SentinelListLib.SentinelList $executors;\\n        // single fallback handler for all fallbacks\\n        // account vendors may implement this differently. This is just a reference implementation\\n        mapping(bytes4 selector => FallbackHandler fallbackHandler) $fallbacks;\\n    }\\n\\n    function $moduleManager() internal pure virtual returns (ModuleManagerStorage storage $ims) {\\n        bytes32 position = MODULEMANAGER_STORAGE_LOCATION;\\n        assembly {\\n            $ims.slot := position\\n        }\\n    }\\n\\n    modifier onlyExecutorModule() {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\\n        if (!$executors.contains(msg.sender)) revert InvalidModule(msg.sender);\\n        _;\\n    }\\n\\n    modifier onlyValidatorModule(address validator) {\\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\\n        if (!$valdiators.contains(validator)) revert InvalidModule(validator);\\n        _;\\n    }\\n\\n    function _initModuleManager() internal virtual {\\n        ModuleManagerStorage storage $ims = $moduleManager();\\n        $ims.$executors.init();\\n        $ims.$valdiators.init();\\n    }\\n\\n    function isAlreadyInitialized() internal view virtual returns (bool) {\\n        ModuleManagerStorage storage $ims = $moduleManager();\\n        return $ims.$valdiators.alreadyInitialized();\\n    }\\n\\n    /////////////////////////////////////////////////////\\n    //  Manage Validators\\n    ////////////////////////////////////////////////////\\n    function _installValidator(address validator, bytes calldata data) internal virtual {\\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\\n        $valdiators.push(validator);\\n        IValidator(validator).onInstall(data);\\n    }\\n\\n    function _uninstallValidator(address validator, bytes calldata data) internal {\\n        // TODO: check if its the last validator. this might brick the account\\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\\n        (address prev, bytes memory disableModuleData) = abi.decode(data, (address, bytes));\\n        $valdiators.pop(prev, validator);\\n        IValidator(validator).onUninstall(disableModuleData);\\n    }\\n\\n    function _isValidatorInstalled(address validator) internal view virtual returns (bool) {\\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\\n        return $valdiators.contains(validator);\\n    }\\n\\n    /**\\n     * THIS IS NOT PART OF THE STANDARD\\n     * Helper Function to access linked list\\n     */\\n    function getValidatorPaginated(\\n        address cursor,\\n        uint256 size\\n    )\\n        external\\n        view\\n        virtual\\n        returns (address[] memory array, address next)\\n    {\\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\\n        return $valdiators.getEntriesPaginated(cursor, size);\\n    }\\n\\n    /////////////////////////////////////////////////////\\n    //  Manage Executors\\n    ////////////////////////////////////////////////////\\n\\n    function _installExecutor(address executor, bytes calldata data) internal {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\\n        $executors.push(executor);\\n        IExecutor(executor).onInstall(data);\\n    }\\n\\n    function _uninstallExecutor(address executor, bytes calldata data) internal {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\\n        (address prev, bytes memory disableModuleData) = abi.decode(data, (address, bytes));\\n        $executors.pop(prev, executor);\\n        IExecutor(executor).onUninstall(disableModuleData);\\n    }\\n\\n    function _isExecutorInstalled(address executor) internal view virtual returns (bool) {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\\n        return $executors.contains(executor);\\n    }\\n\\n    /**\\n     * THIS IS NOT PART OF THE STANDARD\\n     * Helper Function to access linked list\\n     */\\n    function getExecutorsPaginated(\\n        address cursor,\\n        uint256 size\\n    )\\n        external\\n        view\\n        virtual\\n        returns (address[] memory array, address next)\\n    {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\\n        return $executors.getEntriesPaginated(cursor, size);\\n    }\\n\\n    /////////////////////////////////////////////////////\\n    //  Manage Fallback\\n    ////////////////////////////////////////////////////\\n\\n    function _installFallbackHandler(address handler, bytes calldata params) internal virtual {\\n        bytes4 selector = bytes4(params[0:4]);\\n        CallType calltype = CallType.wrap(bytes1(params[4]));\\n        bytes memory initData = params[5:];\\n\\n        if (_isFallbackHandlerInstalled(selector)) {\\n            revert(\\\"Function selector already used\\\");\\n        }\\n        $moduleManager().$fallbacks[selector] = FallbackHandler(handler, calltype);\\n        IFallback(handler).onInstall(initData);\\n    }\\n\\n    function _uninstallFallbackHandler(\\n        address handler,\\n        bytes calldata deInitData\\n    )\\n        internal\\n        virtual\\n    {\\n        bytes4 selector = bytes4(deInitData[0:4]);\\n        bytes memory _deInitData = deInitData[4:];\\n\\n        if (!_isFallbackHandlerInstalled(selector)) {\\n            revert(\\\"Function selector not used\\\");\\n        }\\n\\n        FallbackHandler memory activeFallback = $moduleManager().$fallbacks[selector];\\n\\n        if (activeFallback.handler != handler) {\\n            revert(\\\"Function selector not used by this handler\\\");\\n        }\\n\\n        CallType callType = activeFallback.calltype;\\n\\n        $moduleManager().$fallbacks[selector] = FallbackHandler(address(0), CallType.wrap(0x00));\\n\\n        IFallback(handler).onUninstall(_deInitData);\\n    }\\n\\n    function _isFallbackHandlerInstalled(bytes4 functionSig) internal view virtual returns (bool) {\\n        FallbackHandler storage $fallback = $moduleManager().$fallbacks[functionSig];\\n        return $fallback.handler != address(0);\\n    }\\n\\n    function _isFallbackHandlerInstalled(\\n        bytes4 functionSig,\\n        address _handler\\n    )\\n        internal\\n        view\\n        virtual\\n        returns (bool)\\n    {\\n        FallbackHandler storage $fallback = $moduleManager().$fallbacks[functionSig];\\n        return $fallback.handler == _handler;\\n    }\\n\\n    function getActiveFallbackHandler(bytes4 functionSig)\\n        external\\n        view\\n        virtual\\n        returns (FallbackHandler memory)\\n    {\\n        return $moduleManager().$fallbacks[functionSig];\\n    }\\n\\n    // FALLBACK\\n    fallback() external payable override(Receiver) receiverFallback {\\n        FallbackHandler storage $fallbackHandler = $moduleManager().$fallbacks[msg.sig];\\n        address handler = $fallbackHandler.handler;\\n        CallType calltype = $fallbackHandler.calltype;\\n        if (handler == address(0)) revert NoFallbackHandler(msg.sig);\\n\\n        if (calltype == CALLTYPE_STATIC) {\\n            assembly {\\n                function allocate(length) -> pos {\\n                    pos := mload(0x40)\\n                    mstore(0x40, add(pos, length))\\n                }\\n\\n                let calldataPtr := allocate(calldatasize())\\n                calldatacopy(calldataPtr, 0, calldatasize())\\n\\n                // The msg.sender address is shifted to the left by 12 bytes to remove the padding\\n                // Then the address without padding is stored right after the calldata\\n                let senderPtr := allocate(20)\\n                mstore(senderPtr, shl(96, caller()))\\n\\n                // Add 20 bytes for the address appended add the end\\n                let success :=\\n                    staticcall(gas(), handler, calldataPtr, add(calldatasize(), 20), 0, 0)\\n\\n                let returnDataPtr := allocate(returndatasize())\\n                returndatacopy(returnDataPtr, 0, returndatasize())\\n                if iszero(success) { revert(returnDataPtr, returndatasize()) }\\n                return(returnDataPtr, returndatasize())\\n            }\\n        }\\n        if (calltype == CALLTYPE_SINGLE) {\\n            assembly {\\n                function allocate(length) -> pos {\\n                    pos := mload(0x40)\\n                    mstore(0x40, add(pos, length))\\n                }\\n\\n                let calldataPtr := allocate(calldatasize())\\n                calldatacopy(calldataPtr, 0, calldatasize())\\n\\n                // The msg.sender address is shifted to the left by 12 bytes to remove the padding\\n                // Then the address without padding is stored right after the calldata\\n                let senderPtr := allocate(20)\\n                mstore(senderPtr, shl(96, caller()))\\n\\n                // Add 20 bytes for the address appended add the end\\n                let success := call(gas(), handler, 0, calldataPtr, add(calldatasize(), 20), 0, 0)\\n\\n                let returnDataPtr := allocate(returndatasize())\\n                returndatacopy(returnDataPtr, 0, returndatasize())\\n                if iszero(success) { revert(returnDataPtr, returndatasize()) }\\n                return(returnDataPtr, returndatasize())\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe74e93d4912692c5fc816e8706030eb8401ec8b862c98c3566230dfd3ed8791f\",\"license\":\"MIT\"},\"erc7579/core/Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/**\\n * @title Receiver\\n * @dev This contract receives safe-transferred ERC721 and ERC1155 tokens.\\n * @author Modified from Solady\\n * (https://github.com/Vectorized/solady/blob/main/src/accounts/Receiver.sol)\\n */\\nabstract contract Receiver {\\n    /// @dev For receiving ETH.\\n    receive() external payable virtual { }\\n\\n    /// @dev Fallback function with the `receiverFallback` modifier.\\n    fallback() external payable virtual receiverFallback { }\\n\\n    /// @dev Modifier for the fallback function to handle token callbacks.\\n    modifier receiverFallback() virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := shr(224, calldataload(0))\\n            // 0x150b7a02: `onERC721Received(address,address,uint256,bytes)`.\\n            // 0xf23a6e61: `onERC1155Received(address,address,uint256,uint256,bytes)`.\\n            // 0xbc197c81: `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\\n            if or(eq(s, 0x150b7a02), or(eq(s, 0xf23a6e61), eq(s, 0xbc197c81))) {\\n                mstore(0x20, s) // Store `msg.sig`.\\n                return(0x3c, 0x20) // Return `msg.sig`.\\n            }\\n        }\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x42d41b30a6582d95d737fd75122b621a8af1ec3123782d91a29385b67612b9e4\",\"license\":\"MIT\"},\"erc7579/interfaces/IERC4337Account.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { PackedUserOperation } from \\\"account-abstraction/interfaces/PackedUserOperation.sol\\\";\\n\\ninterface IERC4337Account {\\n    /**\\n     * Validate user's signature and nonce\\n     * the entryPoint will make the call to the recipient only if this validation call returns\\n     * successfully.\\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\\n     * This allows making a \\\"simulation call\\\" without a valid signature\\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to\\n     * signal failure.\\n     *\\n     * @dev Must validate caller is the entryPoint.\\n     *      Must validate the signature and nonce\\n     * @param userOp              - The operation that is about to be executed.\\n     * @param userOpHash          - Hash of the user's request data. can be used as the basis for\\n     * signature.\\n     * @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\\n     *                              This is the minimum amount to transfer to the sender(entryPoint)\\n     * to be\\n     *                              able to make the call. The excess is left as a deposit in the\\n     * entrypoint\\n     *                              for future calls. Can be withdrawn anytime using\\n     * \\\"entryPoint.withdrawTo()\\\".\\n     *                              In case there is a paymaster in the request (or the current\\n     * deposit is high\\n     *                              enough), this value will be zero.\\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData`\\n     * and\\n     *                              `_unpackValidationData` to encode and decode.\\n     *                              <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark\\n     * signature failure,\\n     *                                 otherwise, an address of an \\\"authorizer\\\" contract.\\n     *                              <6-byte> validUntil - Last timestamp this operation is valid. 0\\n     * for \\\"indefinite\\\"\\n     *                              <6-byte> validAfter - First timestamp this operation is valid\\n     *                                                    If an account doesn't use time-range, it\\n     * is enough to\\n     *                                                    return SIG_VALIDATION_FAILED value (1) for\\n     * signature failure.\\n     *                              Note that the validation code cannot use block.timestamp (or\\n     * block.number) directly.\\n     */\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 missingAccountFunds\\n    )\\n        external\\n        payable\\n        returns (uint256 validationData);\\n\\n    /**\\n     * Account may implement this execute method.\\n     * passing this methodSig at the beginning of callData will cause the entryPoint to pass the\\n     * full UserOp (and hash)\\n     * to the account.\\n     * The account should skip the methodSig, and use the callData (and optionally, other UserOp\\n     * fields)\\n     *\\n     * @param userOp              - The operation that was just validated.\\n     * @param userOpHash          - Hash of the user's request data.\\n     */\\n    function executeUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash\\n    )\\n        external\\n        payable;\\n}\\n\",\"keccak256\":\"0x55f4a9fe65535a8b3f6db727c764aad1eb237a22828f2565941d0c079e9b7e3e\",\"license\":\"MIT\"},\"erc7579/interfaces/IERC7579Account.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { CallType, ExecType, ModeCode } from \\\"../lib/ModeLib.sol\\\";\\n\\nstruct Execution {\\n    address target;\\n    uint256 value;\\n    bytes callData;\\n}\\n\\ninterface IERC7579Account {\\n    event ModuleInstalled(uint256 moduleTypeId, address module);\\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\\n\\n    /**\\n     * @dev Executes a transaction on behalf of the account.\\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * If a mode is requested that is not supported by the Account, it MUST revert\\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\\n     * @param executionCalldata The encoded execution call data\\n     */\\n    function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\\n\\n    /**\\n     * @dev Executes a transaction on behalf of the account.\\n     *         This function is intended to be called by Executor Modules\\n     * @dev Ensure adequate authorization control: i.e. onlyExecutorModule\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * If a mode is requested that is not supported by the Account, it MUST revert\\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\\n     * @param executionCalldata The encoded execution call data\\n     */\\n    function executeFromExecutor(\\n        ModeCode mode,\\n        bytes calldata executionCalldata\\n    )\\n        external\\n        payable\\n        returns (bytes[] memory returnData);\\n\\n    /**\\n     * @dev ERC-1271 isValidSignature\\n     *         This function is intended to be used to validate a smart account signature\\n     * and may forward the call to a validator module\\n     *\\n     * @param hash The hash of the data that is signed\\n     * @param data The data that is signed\\n     */\\n    function isValidSignature(bytes32 hash, bytes calldata data) external view returns (bytes4);\\n\\n    /**\\n     * @dev installs a Module of a certain type on the smart account\\n     * @dev Implement Authorization control of your chosing\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     * @param module the module address\\n     * @param initData arbitrary data that may be required on the module during `onInstall`\\n     * initialization.\\n     */\\n    function installModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata initData\\n    )\\n        external\\n        payable;\\n\\n    /**\\n     * @dev uninstalls a Module of a certain type on the smart account\\n     * @dev Implement Authorization control of your chosing\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     * @param module the module address\\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\\n     * de-initialization.\\n     */\\n    function uninstallModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata deInitData\\n    )\\n        external\\n        payable;\\n\\n    /**\\n     * Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\\n     * @param encodedMode the encoded mode\\n     */\\n    function supportsExecutionMode(ModeCode encodedMode) external view returns (bool);\\n\\n    /**\\n     * Function to check if the account supports installation of a certain module type Id\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     */\\n    function supportsModule(uint256 moduleTypeId) external view returns (bool);\\n\\n    /**\\n     * Function to check if the account has a certain module installed\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\\n     *            thus may be necessary to query multiple module types\\n     * @param module the module address\\n     * @param additionalContext additional context data that the smart account may interpret to\\n     *                          identifiy conditions under which the module is installed.\\n     *                          usually this is not necessary, but for some special hooks that\\n     *                          are stored in mappings, this param might be needed\\n     */\\n    function isModuleInstalled(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata additionalContext\\n    )\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the account id of the smart account\\n     * @return accountImplementationId the account id of the smart account\\n     * the accountId should be structured like so:\\n     *        \\\"vendorname.accountname.semver\\\"\\n     */\\n    function accountId() external view returns (string memory accountImplementationId);\\n}\\n\",\"keccak256\":\"0x08368aba5f1bb83eb57e9f8d31a04edee4be69159b4844a6443f65100917011c\",\"license\":\"MIT\"},\"erc7579/interfaces/IERC7579Module.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { PackedUserOperation } from \\\"account-abstraction/interfaces/PackedUserOperation.sol\\\";\\n\\nuint256 constant VALIDATION_SUCCESS = 0;\\nuint256 constant VALIDATION_FAILED = 1;\\n\\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\\nuint256 constant MODULE_TYPE_FALLBACK = 3;\\nuint256 constant MODULE_TYPE_HOOK = 4;\\n\\ninterface IModule {\\n    error AlreadyInitialized(address smartAccount);\\n    error NotInitialized(address smartAccount);\\n\\n    /**\\n     * @dev This function is called by the smart account during installation of the module\\n     * @param data arbitrary data that may be required on the module during `onInstall`\\n     * initialization\\n     *\\n     * MUST revert on error (i.e. if module is already enabled)\\n     */\\n    function onInstall(bytes calldata data) external;\\n\\n    /**\\n     * @dev This function is called by the smart account during uninstallation of the module\\n     * @param data arbitrary data that may be required on the module during `onUninstall`\\n     * de-initialization\\n     *\\n     * MUST revert on error\\n     */\\n    function onUninstall(bytes calldata data) external;\\n\\n    /**\\n     * @dev Returns boolean value if module is a certain type\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     *\\n     * MUST return true if the module is of the given type and false otherwise\\n     */\\n    function isModuleType(uint256 moduleTypeId) external view returns (bool);\\n\\n    /**\\n     * @dev Returns if the module was already initialized for a provided smartaccount\\n     */\\n    function isInitialized(address smartAccount) external view returns (bool);\\n}\\n\\ninterface IValidator is IModule {\\n    error InvalidTargetAddress(address target);\\n\\n    /**\\n     * @dev Validates a transaction on behalf of the account.\\n     *         This function is intended to be called by the MSA during the ERC-4337 validaton phase\\n     *         Note: solely relying on bytes32 hash and signature is not suffcient for some\\n     * validation implementations (i.e. SessionKeys often need access to userOp.calldata)\\n     * @param userOp The user operation to be validated. The userOp MUST NOT contain any metadata.\\n     * The MSA MUST clean up the userOp before sending it to the validator.\\n     * @param userOpHash The hash of the user operation to be validated\\n     * @return return value according to ERC-4337\\n     */\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash\\n    )\\n        external\\n        returns (uint256);\\n\\n    /**\\n     * Validator can be used for ERC-1271 validation\\n     */\\n    function isValidSignatureWithSender(\\n        address sender,\\n        bytes32 hash,\\n        bytes calldata data\\n    )\\n        external\\n        view\\n        returns (bytes4);\\n}\\n\\ninterface IExecutor is IModule { }\\n\\ninterface IHook is IModule {\\n    function preCheck(\\n        address msgSender,\\n        uint256 msgValue,\\n        bytes calldata msgData\\n    )\\n        external\\n        returns (bytes memory hookData);\\n\\n    function postCheck(bytes calldata hookData) external;\\n}\\n\\ninterface IFallback is IModule { }\\n\",\"keccak256\":\"0x78ab984fc364972382a73a0d793c558f52800999d5e0e69c4df326a1de840604\",\"license\":\"MIT\"},\"erc7579/interfaces/IMSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { IERC7579Account } from \\\"./IERC7579Account.sol\\\";\\nimport { IERC4337Account } from \\\"./IERC4337Account.sol\\\";\\n\\nimport { CallType, ExecType, ModeCode } from \\\"../lib/ModeLib.sol\\\";\\n\\ninterface IMSA is IERC7579Account, IERC4337Account {\\n    // Error thrown when an unsupported ModuleType is requested\\n    error UnsupportedModuleType(uint256 moduleTypeId);\\n    // Error thrown when an execution with an unsupported CallType was made\\n    error UnsupportedCallType(CallType callType);\\n    // Error thrown when an execution with an unsupported ExecType was made\\n    error UnsupportedExecType(ExecType execType);\\n    // Error thrown when account initialization fails\\n    error AccountInitializationFailed();\\n    // Error thrown when account installs/unistalls module with mismatched input `moduleTypeId`\\n    error MismatchModuleTypeId(uint256 moduleTypeId);\\n\\n    /**\\n     * @dev Initializes the account. Function might be called directly, or by a Factory\\n     * @param data. encoded data that can be used during the initialization phase\\n     */\\n    function initializeAccount(bytes calldata data) external payable;\\n}\\n\",\"keccak256\":\"0x649ef44dfc5ba9b485b31cda765335e96f35aa6e595fd8d86c28a62aa8982cbe\",\"license\":\"MIT\"},\"erc7579/lib/ExecutionLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { Execution } from \\\"../interfaces/IERC7579Account.sol\\\";\\n\\n/**\\n * Helper Library for decoding Execution calldata\\n * malloc for memory allocation is bad for gas. use this assembly instead\\n */\\nlibrary ExecutionLib {\\n    function decodeBatch(bytes calldata callData)\\n        internal\\n        pure\\n        returns (Execution[] calldata executionBatch)\\n    {\\n        /*\\n         * Batch Call Calldata Layout\\n         * Offset (in bytes)    | Length (in bytes) | Contents\\n         * 0x0                  | 0x4               | bytes4 function selector\\n        *  0x4                  | -                 |\\n        abi.encode(IERC7579Execution.Execution[])\\n         */\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            let dataPointer := add(callData.offset, calldataload(callData.offset))\\n\\n            // Extract the ERC7579 Executions\\n            executionBatch.offset := add(dataPointer, 32)\\n            executionBatch.length := calldataload(dataPointer)\\n        }\\n    }\\n\\n    function encodeBatch(Execution[] memory executions)\\n        internal\\n        pure\\n        returns (bytes memory callData)\\n    {\\n        callData = abi.encode(executions);\\n    }\\n\\n    function decodeSingle(bytes calldata executionCalldata)\\n        internal\\n        pure\\n        returns (address target, uint256 value, bytes calldata callData)\\n    {\\n        target = address(bytes20(executionCalldata[0:20]));\\n        value = uint256(bytes32(executionCalldata[20:52]));\\n        callData = executionCalldata[52:];\\n    }\\n\\n    function encodeSingle(\\n        address target,\\n        uint256 value,\\n        bytes memory callData\\n    )\\n        internal\\n        pure\\n        returns (bytes memory userOpCalldata)\\n    {\\n        userOpCalldata = abi.encodePacked(target, value, callData);\\n    }\\n}\\n\",\"keccak256\":\"0xa6d41aa7532a4bff83a8c335a8050ebe0c7a73c456d70594d2123dc293892c5c\",\"license\":\"MIT\"},\"erc7579/lib/ModeLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/**\\n * @title ModeLib\\n * To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\\n * encoding is used.\\n *    Function Signature of execute function:\\n *           function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\\n * This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\\n * context.\\n * NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\\n * implement\\n * more complex execution modes may use the entire bytes32.\\n *\\n * |--------------------------------------------------------------------|\\n * | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\\n * |--------------------------------------------------------------------|\\n * | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\\n * |--------------------------------------------------------------------|\\n *\\n * CALLTYPE: 1 byte\\n * CallType is used to determine how the executeCalldata paramter of the execute function has to be\\n * decoded.\\n * It can be either single, batch or delegatecall. In the future different calls could be added.\\n * CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\\n *\\n * EXECTYPE: 1 byte\\n * ExecType is used to determine how the account should handle the execution.\\n * It can indicate if the execution should revert on failure or continue execution.\\n * In the future more execution modes may be added.\\n * Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\\n * a batch fails, the entire batch is reverted\\n *\\n * UNUSED: 4 bytes\\n * Unused bytes are reserved for future use.\\n *\\n * ModeSelector: bytes4\\n * The \\\"optional\\\" mode selector can be used by account vendors, to implement custom behavior in\\n * their accounts.\\n * the way a ModeSelector is to be calculated is bytes4(keccak256(\\\"vendorname.featurename\\\"))\\n * this is to prevent collisions between different vendors, while allowing innovation and the\\n * development of new features without coordination between ERC-7579 implementing accounts\\n *\\n * ModePayload: 22 bytes\\n * Mode payload is used to pass additional data to the smart account execution, this may be\\n * interpreted depending on the ModeSelector\\n *\\n * ExecutionCallData: n bytes\\n * single, delegatecall or batch exec abi.encoded as bytes\\n */\\nimport { Execution } from \\\"../interfaces/IERC7579Account.sol\\\";\\n\\n// Custom type for improved developer experience\\ntype ModeCode is bytes32;\\n\\ntype CallType is bytes1;\\n\\ntype ExecType is bytes1;\\n\\ntype ModeSelector is bytes4;\\n\\ntype ModePayload is bytes22;\\n\\n// Default CallType\\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\\n// Batched CallType\\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\\n// @dev Implementing delegatecall is OPTIONAL!\\n// implement delegatecall with extreme care.\\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\\n\\n// @dev default behavior is to revert on failure\\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\\n// Since this is value 0x00, no additional encoding is required for simple accounts\\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\\n// @dev account may elect to change execution behavior. For example \\\"try exec\\\" / \\\"allow fail\\\"\\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\\n\\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\\n// Example declaration of a custom mode selector\\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\\\"default.mode.offset\\\")));\\n\\n/**\\n * @dev ModeLib is a helper library to encode/decode ModeCodes\\n */\\nlibrary ModeLib {\\n    function decode(ModeCode mode)\\n        internal\\n        pure\\n        returns (\\n            CallType _calltype,\\n            ExecType _execType,\\n            ModeSelector _modeSelector,\\n            ModePayload _modePayload\\n        )\\n    {\\n        assembly {\\n            _calltype := mode\\n            _execType := shl(8, mode)\\n            _modeSelector := shl(48, mode)\\n            _modePayload := shl(80, mode)\\n        }\\n    }\\n\\n    function encode(\\n        CallType callType,\\n        ExecType execType,\\n        ModeSelector mode,\\n        ModePayload payload\\n    )\\n        internal\\n        pure\\n        returns (ModeCode)\\n    {\\n        return ModeCode.wrap(\\n            bytes32(\\n                abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)\\n            )\\n        );\\n    }\\n\\n    function encodeSimpleBatch() internal pure returns (ModeCode mode) {\\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\\n    }\\n\\n    function encodeSimpleSingle() internal pure returns (ModeCode mode) {\\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\\n    }\\n\\n    function getCallType(ModeCode mode) internal pure returns (CallType calltype) {\\n        assembly {\\n            calltype := mode\\n        }\\n    }\\n}\\n\\nusing { eqModeSelector as == } for ModeSelector global;\\nusing { eqCallType as == } for CallType global;\\nusing { eqExecType as == } for ExecType global;\\n\\nfunction eqCallType(CallType a, CallType b) pure returns (bool) {\\n    return CallType.unwrap(a) == CallType.unwrap(b);\\n}\\n\\nfunction eqExecType(ExecType a, ExecType b) pure returns (bool) {\\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\\n}\\n\\nfunction eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\\n}\\n\",\"keccak256\":\"0x02ce0fc8805d1427841f32e2335157e3fae18e99d5c49ba46d53e12fcd1a5185\",\"license\":\"MIT\"},\"erc7579/utils/Bootstrap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport \\\"../core/ModuleManager.sol\\\";\\nimport \\\"../core/HookManager.sol\\\";\\n\\nimport \\\"../interfaces/IERC7579Module.sol\\\";\\n\\nstruct BootstrapConfig {\\n    address module;\\n    bytes data;\\n}\\n\\ncontract Bootstrap is ModuleManager, HookManager {\\n    function singleInitMSA(IModule validator, bytes calldata data) external {\\n        // init validator\\n        _installValidator(address(validator), data);\\n    }\\n\\n    /**\\n     * This function is intended to be called by the MSA with a delegatecall.\\n     * Make sure that the MSA already initilazed the linked lists in the ModuleManager prior to\\n     * calling this function\\n     */\\n    function initMSA(\\n        BootstrapConfig[] calldata $valdiators,\\n        BootstrapConfig[] calldata $executors,\\n        BootstrapConfig calldata _hook,\\n        BootstrapConfig[] calldata _fallbacks\\n    )\\n        external\\n    {\\n        // init validators\\n        for (uint256 i; i < $valdiators.length; i++) {\\n            _installValidator($valdiators[i].module, $valdiators[i].data);\\n        }\\n\\n        // init executors\\n        for (uint256 i; i < $executors.length; i++) {\\n            if ($executors[i].module == address(0)) continue;\\n            _installExecutor($executors[i].module, $executors[i].data);\\n        }\\n\\n        // init hook\\n        if (_hook.module != address(0)) {\\n            _installHook(_hook.module, _hook.data);\\n        }\\n\\n        // init fallback\\n        for (uint256 i; i < _fallbacks.length; i++) {\\n            if (_fallbacks[i].module == address(0)) continue;\\n            _installFallbackHandler(_fallbacks[i].module, _fallbacks[i].data);\\n        }\\n    }\\n\\n    function _getInitMSACalldata(\\n        BootstrapConfig[] calldata $valdiators,\\n        BootstrapConfig[] calldata $executors,\\n        BootstrapConfig calldata _hook,\\n        BootstrapConfig[] calldata _fallbacks\\n    )\\n        external\\n        view\\n        returns (bytes memory init)\\n    {\\n        init = abi.encode(\\n            address(this),\\n            abi.encodeCall(this.initMSA, ($valdiators, $executors, _hook, _fallbacks))\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x0f1474b9f03cc19e781766784dc28d701036d2a06145c16fb3b88e7746249ef3\",\"license\":\"MIT\"},\"forge-std/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    /// uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x414b2861b1acbf816ccb7346d3f16cf6c1e002e9e5e40d2f1f26fa5ddc2ea600\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\\n\",\"keccak256\":\"0x7434453e6d3b7d0e5d0eb7846ffdbc27f0ccf3b163591263739b628074dc103a\",\"license\":\"MIT\"},\"sentinellist/SentinelList.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\naddress constant SENTINEL = address(0x1);\\naddress constant ZERO_ADDRESS = address(0x0);\\n\\nlibrary SentinelListLib {\\n    struct SentinelList {\\n        mapping(address => address) entries;\\n    }\\n\\n    error LinkedList_AlreadyInitialized();\\n    error LinkedList_InvalidPage();\\n    error LinkedList_InvalidEntry(address entry);\\n    error LinkedList_EntryAlreadyInList(address entry);\\n\\n    function init(SentinelList storage self) internal {\\n        if (alreadyInitialized(self)) revert LinkedList_AlreadyInitialized();\\n        self.entries[SENTINEL] = SENTINEL;\\n    }\\n\\n    function alreadyInitialized(SentinelList storage self) internal view returns (bool) {\\n        return self.entries[SENTINEL] != ZERO_ADDRESS;\\n    }\\n\\n    function getNext(SentinelList storage self, address entry) internal view returns (address) {\\n        if (entry == ZERO_ADDRESS) {\\n            revert LinkedList_InvalidEntry(entry);\\n        }\\n        return self.entries[entry];\\n    }\\n\\n    function push(SentinelList storage self, address newEntry) internal {\\n        if (newEntry == ZERO_ADDRESS || newEntry == SENTINEL) {\\n            revert LinkedList_InvalidEntry(newEntry);\\n        }\\n        if (self.entries[newEntry] != ZERO_ADDRESS) revert LinkedList_EntryAlreadyInList(newEntry);\\n        self.entries[newEntry] = self.entries[SENTINEL];\\n        self.entries[SENTINEL] = newEntry;\\n    }\\n\\n    function pop(SentinelList storage self, address prevEntry, address popEntry) internal {\\n        if (popEntry == ZERO_ADDRESS || popEntry == SENTINEL) {\\n            revert LinkedList_InvalidEntry(prevEntry);\\n        }\\n        if (self.entries[prevEntry] != popEntry) revert LinkedList_InvalidEntry(popEntry);\\n        self.entries[prevEntry] = self.entries[popEntry];\\n        self.entries[popEntry] = ZERO_ADDRESS;\\n    }\\n\\n    function popAll(SentinelList storage self) internal {\\n        address next = self.entries[SENTINEL];\\n        while (next != ZERO_ADDRESS) {\\n            address current = next;\\n            next = self.entries[next];\\n            self.entries[current] = ZERO_ADDRESS;\\n        }\\n        self.entries[SENTINEL] = ZERO_ADDRESS;\\n    }\\n\\n    function contains(SentinelList storage self, address entry) internal view returns (bool) {\\n        return SENTINEL != entry && self.entries[entry] != ZERO_ADDRESS;\\n    }\\n\\n    function getEntriesPaginated(\\n        SentinelList storage self,\\n        address start,\\n        uint256 pageSize\\n    )\\n        internal\\n        view\\n        returns (address[] memory array, address next)\\n    {\\n        if (start != SENTINEL && !contains(self, start)) revert LinkedList_InvalidEntry(start);\\n        if (pageSize == 0) revert LinkedList_InvalidPage();\\n        // Init array with max page size\\n        array = new address[](pageSize);\\n\\n        // Populate return array\\n        uint256 entryCount = 0;\\n        next = self.entries[start];\\n        while (next != ZERO_ADDRESS && next != SENTINEL && entryCount < pageSize) {\\n            array[entryCount] = next;\\n            next = self.entries[next];\\n            entryCount++;\\n        }\\n\\n        /**\\n         * Because of the argument validation, we can assume that the loop will always iterate over\\n         * the valid entry list values\\n         *       and the `next` variable will either be an enabled entry or a sentinel address\\n         * (signalling the end).\\n         *\\n         *       If we haven't reached the end inside the loop, we need to set the next pointer to\\n         * the last element of the entry array\\n         *       because the `next` variable (which is a entry by itself) acting as a pointer to the\\n         * start of the next page is neither\\n         *       incSENTINELrent page, nor will it be included in the next one if you pass it as a\\n         * start.\\n         */\\n        if (next != SENTINEL && entryCount > 0) {\\n            next = array[entryCount - 1];\\n        }\\n        // Set correct size of returned array\\n        // solhint-disable-next-line no-inline-assembly\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(array, entryCount)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0fdb07d60acf6c8272517b2cf9a7ce36cef7dabd3acfc61e7424662818044da2\",\"license\":\"MIT\"},\"sentinellist/SentinelList4337.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\naddress constant SENTINEL = address(0x1);\\naddress constant ZERO_ADDRESS = address(0x0);\\n\\n/**\\n * Implements a linked list, but adheres to ERC-4337 storage restrictions.\\n * Intended use: validator modules for modular ERC-4337 smart accounts\\n * @author kopy-kat | rhinestone.wtf\\n */\\nlibrary SentinelList4337Lib {\\n    struct SentinelList {\\n        mapping(address key => mapping(address account => address entry)) entries;\\n    }\\n\\n    error LinkedList_AlreadyInitialized();\\n    error LinkedList_InvalidPage();\\n    error LinkedList_InvalidEntry(address entry);\\n    error LinkedList_EntryAlreadyInList(address entry);\\n\\n    function init(SentinelList storage self, address account) internal {\\n        if (alreadyInitialized(self, account)) revert LinkedList_AlreadyInitialized();\\n        self.entries[SENTINEL][account] = SENTINEL;\\n    }\\n\\n    function alreadyInitialized(\\n        SentinelList storage self,\\n        address account\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return self.entries[SENTINEL][account] != ZERO_ADDRESS;\\n    }\\n\\n    function getNext(\\n        SentinelList storage self,\\n        address account,\\n        address entry\\n    )\\n        internal\\n        view\\n        returns (address)\\n    {\\n        if (entry == ZERO_ADDRESS) {\\n            revert LinkedList_InvalidEntry(entry);\\n        }\\n        return self.entries[entry][account];\\n    }\\n\\n    function push(SentinelList storage self, address account, address newEntry) internal {\\n        if (newEntry == ZERO_ADDRESS || newEntry == SENTINEL) {\\n            revert LinkedList_InvalidEntry(newEntry);\\n        }\\n        if (self.entries[newEntry][account] != ZERO_ADDRESS) {\\n            revert LinkedList_EntryAlreadyInList(newEntry);\\n        }\\n        self.entries[newEntry][account] = self.entries[SENTINEL][account];\\n        self.entries[SENTINEL][account] = newEntry;\\n    }\\n\\n    function pop(\\n        SentinelList storage self,\\n        address account,\\n        address prevEntry,\\n        address popEntry\\n    )\\n        internal\\n    {\\n        if (popEntry == ZERO_ADDRESS || popEntry == SENTINEL) {\\n            revert LinkedList_InvalidEntry(prevEntry);\\n        }\\n        if (self.entries[prevEntry][account] != popEntry) {\\n            revert LinkedList_InvalidEntry(popEntry);\\n        }\\n        self.entries[prevEntry][account] = self.entries[popEntry][account];\\n        self.entries[popEntry][account] = ZERO_ADDRESS;\\n    }\\n\\n    function popAll(SentinelList storage self, address account) internal {\\n        address next = self.entries[SENTINEL][account];\\n        while (next != ZERO_ADDRESS) {\\n            address current = next;\\n            next = self.entries[next][account];\\n            self.entries[current][account] = ZERO_ADDRESS;\\n        }\\n        self.entries[SENTINEL][account] = ZERO_ADDRESS;\\n    }\\n\\n    function contains(\\n        SentinelList storage self,\\n        address account,\\n        address entry\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return SENTINEL != entry && self.entries[entry][account] != ZERO_ADDRESS;\\n    }\\n\\n    function getEntriesPaginated(\\n        SentinelList storage self,\\n        address account,\\n        address start,\\n        uint256 pageSize\\n    )\\n        internal\\n        view\\n        returns (address[] memory array, address next)\\n    {\\n        if (start != SENTINEL && !contains(self, account, start)) {\\n            revert LinkedList_InvalidEntry(start);\\n        }\\n        if (pageSize == 0) revert LinkedList_InvalidPage();\\n        // Init array with max page size\\n        array = new address[](pageSize);\\n\\n        // Populate return array\\n        uint256 entryCount = 0;\\n        next = self.entries[start][account];\\n        while (next != ZERO_ADDRESS && next != SENTINEL && entryCount < pageSize) {\\n            array[entryCount] = next;\\n            next = self.entries[next][account];\\n            entryCount++;\\n        }\\n\\n        /**\\n         * Because of the argument validation, we can assume that the loop will always iterate over\\n         * the valid entry list values\\n         *       and the `next` variable will either be an enabled entry or a sentinel address\\n         * (signalling the end).\\n         *\\n         *       If we haven't reached the end inside the loop, we need to set the next pointer to\\n         * the last element of the entry array\\n         *       because the `next` variable (which is a entry by itself) acting as a pointer to the\\n         * start of the next page is neither\\n         *       incSENTINELrent page, nor will it be included in the next one if you pass it as a\\n         * start.\\n         */\\n        if (next != SENTINEL && entryCount > 0) {\\n            next = array[entryCount - 1];\\n        }\\n        // Set correct size of returned array\\n        // solhint-disable-next-line no-inline-assembly\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(array, entryCount)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x173a41622f0525822de4252e768907b83d5b43b6a939a6448082c5cfcdd76b33\",\"license\":\"MIT\"},\"solady/utils/LibClone.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Minimal proxy library.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\\n/// @author Minimal proxy by 0age (https://github.com/0age)\\n/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie\\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\\n/// @author Minimal ERC1967 proxy by jtriley-eth (https://github.com/jtriley-eth/minimum-viable-proxy)\\n///\\n/// @dev Minimal proxy:\\n/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,\\n/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,\\n/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.\\n///\\n/// @dev Minimal proxy (PUSH0 variant):\\n/// This is a new minimal proxy that uses the PUSH0 opcode introduced during Shanghai.\\n/// It is optimized first for minimal runtime gas, then for minimal bytecode.\\n/// The PUSH0 clone functions are intentionally postfixed with a jarring \\\"_PUSH0\\\" as\\n/// many EVM chains may not support the PUSH0 opcode in the early months after Shanghai.\\n/// Please use with caution.\\n///\\n/// @dev Clones with immutable args (CWIA):\\n/// The implementation of CWIA here implements a `receive()` method that emits the\\n/// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,\\n/// enabling us to accept hard gas-capped `sends` & `transfers` for maximum backwards\\n/// composability. The minimal proxy implementation does not offer this feature.\\n///\\n/// @dev Minimal ERC1967 proxy:\\n/// An minimal ERC1967 proxy, intended to be upgraded with UUPS.\\n/// This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\\n/// This proxy is automatically verified on Etherscan.\\n///\\n/// @dev ERC1967I proxy:\\n/// An variant of the minimal ERC1967 proxy, with a special code path that activates\\n/// if `calldatasize() == 1`. This code path skips the delegatecall and directly returns the\\n/// `implementation` address. The returned implementation is guaranteed to be valid if the\\n/// keccak256 of the proxy's code is equal to `ERC1967I_CODE_HASH`.\\nlibrary LibClone {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The keccak256 of the deployed code for the ERC1967 proxy.\\n    bytes32 internal constant ERC1967_CODE_HASH =\\n        0xaaa52c8cc8a0e3fd27ce756cc6b4e70c51423e9b597b11f32d3e49f8b1fc890d;\\n\\n    /// @dev The keccak256 of the deployed code for the ERC1967I proxy.\\n    bytes32 internal constant ERC1967I_CODE_HASH =\\n        0xce700223c0d4cea4583409accfc45adac4a093b3519998a9cbbe1504dadba6f7;\\n\\n    /// @dev The keccak256 of the deployed code for the ERC1967 beacon proxy.\\n    bytes32 internal constant ERC1967_BEACON_PROXY_CODE_HASH =\\n        0x14044459af17bc4f0f5aa2f658cb692add77d1302c29fe2aebab005eea9d1162;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Unable to deploy the clone.\\n    error DeploymentFailed();\\n\\n    /// @dev The salt must start with either the zero address or `by`.\\n    error SaltDoesNotStartWith();\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                  MINIMAL PROXY OPERATIONS                  */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Deploys a clone of `implementation`.\\n    function clone(address implementation) internal returns (address instance) {\\n        instance = clone(0, implementation);\\n    }\\n\\n    /// @dev Deploys a clone of `implementation`.\\n    /// Deposits `value` ETH during deployment.\\n    function clone(uint256 value, address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * --------------------------------------------------------------------------+\\n             * CREATION (9 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\\n             * --------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize     | r         |                              |\\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\\n             * 81         | DUP2              | r 0 r     |                              |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\\n             * --------------------------------------------------------------------------|\\n             * RUNTIME (44 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\\n             * --------------------------------------------------------------------------|\\n             *                                                                           |\\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | 0                      |                       |\\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\\n             *                                                                           |\\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\\n             *                                                                           |\\n             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * fd      | REVERT         |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\\n             * f3      | RETURN         |                        | [0..rds): returndata  |\\n             * --------------------------------------------------------------------------+\\n             */\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            instance := create(value, 0x0c, 0x35)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\\n    function cloneDeterministic(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = cloneDeterministic(0, implementation, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    function cloneDeterministic(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            instance := create2(value, 0x0c, 0x35, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code of the clone of `implementation`.\\n    function initCode(address implementation) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(add(result, 0x40), 0x5af43d3d93803e602a57fd5bf30000000000000000000000)\\n            mstore(add(result, 0x28), implementation)\\n            mstore(add(result, 0x14), 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            mstore(result, 0x35) // Store the length.\\n            mstore(0x40, add(result, 0x60)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            hash := keccak256(0x0c, 0x35)\\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic clone of `implementation`,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)\\n        internal\\n        pure\\n        returns (address predicted)\\n    {\\n        bytes32 hash = initCodeHash(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*          MINIMAL PROXY OPERATIONS (PUSH0 VARIANT)          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Deploys a PUSH0 clone of `implementation`.\\n    function clone_PUSH0(address implementation) internal returns (address instance) {\\n        instance = clone_PUSH0(0, implementation);\\n    }\\n\\n    /// @dev Deploys a PUSH0 clone of `implementation`.\\n    /// Deposits `value` ETH during deployment.\\n    function clone_PUSH0(uint256 value, address implementation)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * --------------------------------------------------------------------------+\\n             * CREATION (9 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\\n             * --------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize     | r         |                              |\\n             * 5f         | PUSH0             | 0 r       |                              |\\n             * 81         | DUP2              | r 0 r     |                              |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\\n             * 5f         | PUSH0             | 0 o r 0 r |                              |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\\n             * --------------------------------------------------------------------------|\\n             * RUNTIME (45 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\\n             * --------------------------------------------------------------------------|\\n             *                                                                           |\\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5f      | PUSH0          | 0                      |                       |\\n             * 5f      | PUSH0          | 0 0                    |                       |\\n             *                                                                           |\\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0                |                       |\\n             * 5f      | PUSH0          | 0 cds 0 0              |                       |\\n             * 5f      | PUSH0          | 0 0 cds 0 0            |                       |\\n             * 37      | CALLDATACOPY   | 0 0                    | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0                | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 cds 0 0              | [0..cds): calldata    |\\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0         | [0..cds): calldata    |\\n             * 5a      | GAS            | gas addr 0 cds 0 0     | [0..cds): calldata    |\\n             * f4      | DELEGATECALL   | success                | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds success            | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 rds success          | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 0 rds success        | [0..cds): calldata    |\\n             * 3e      | RETURNDATACOPY | success                | [0..rds): returndata  |\\n             *                                                                           |\\n             * 60 0x29 | PUSH1 0x29     | 0x29 success           | [0..rds): returndata  |\\n             * 57      | JUMPI          |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\\n             * fd      | REVERT         |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b      | JUMPDEST       |                        | [0..rds): returndata  |\\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\\n             * f3      | RETURN         |                        | [0..rds): returndata  |\\n             * --------------------------------------------------------------------------+\\n             */\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            instance := create(value, 0x0e, 0x36)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\\n    function cloneDeterministic_PUSH0(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = cloneDeterministic_PUSH0(0, implementation, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    function cloneDeterministic_PUSH0(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            instance := create2(value, 0x0e, 0x36, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code of the PUSH0 clone of `implementation`.\\n    function initCode_PUSH0(address implementation) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(add(result, 0x40), 0x5af43d5f5f3e6029573d5ffd5b3d5ff300000000000000000000) // 16\\n            mstore(add(result, 0x26), implementation) // 20\\n            mstore(add(result, 0x12), 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            mstore(result, 0x36) // Store the length.\\n            mstore(0x40, add(result, 0x60)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the PUSH0 clone of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash_PUSH0(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            hash := keccak256(0x0e, 0x36)\\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic PUSH0 clone of `implementation`,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress_PUSH0(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHash_PUSH0(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*           CLONES WITH IMMUTABLE ARGS OPERATIONS            */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: This implementation of CWIA differs from the original implementation.\\n    // If the calldata is empty, it will emit a `ReceiveETH(uint256)` event and skip the `DELEGATECALL`.\\n\\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.\\n    function clone(address implementation, bytes memory data) internal returns (address instance) {\\n        instance = clone(0, implementation, data);\\n    }\\n\\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.\\n    /// Deposits `value` ETH during deployment.\\n    function clone(uint256 value, address implementation, bytes memory data)\\n        internal\\n        returns (address instance)\\n    {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n            // The `creationSize` is `extraLength + 108`\\n            // The `runSize` is `creationSize - 10`.\\n\\n            /**\\n             * ---------------------------------------------------------------------------------------------------+\\n             * CREATION (10 bytes)                                                                                |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                                                |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * 61 runSize | PUSH2 runSize     | r         |                                                       |\\n             * 3d         | RETURNDATASIZE    | 0 r       |                                                       |\\n             * 81         | DUP2              | r 0 r     |                                                       |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                                                       |\\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                                                       |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code                            |\\n             * f3         | RETURN            |           | [0..runSize): runtime code                            |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * RUNTIME (98 bytes + extraLength)                                                                   |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * Opcode   | Mnemonic       | Stack                    | Memory                                      |\\n             * ---------------------------------------------------------------------------------------------------|\\n             *                                                                                                    |\\n             * ::: if no calldata, emit event & return w/o `DELEGATECALL` ::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds                      |                                             |\\n             * 60 0x2c  | PUSH1 0x2c     | 0x2c cds                 |                                             |\\n             * 57       | JUMPI          |                          |                                             |\\n             * 34       | CALLVALUE      | cv                       |                                             |\\n             * 3d       | RETURNDATASIZE | 0 cv                     |                                             |\\n             * 52       | MSTORE         |                          | [0..0x20): callvalue                        |\\n             * 7f sig   | PUSH32 0x9e..  | sig                      | [0..0x20): callvalue                        |\\n             * 59       | MSIZE          | 0x20 sig                 | [0..0x20): callvalue                        |\\n             * 3d       | RETURNDATASIZE | 0 0x20 sig               | [0..0x20): callvalue                        |\\n             * a1       | LOG1           |                          | [0..0x20): callvalue                        |\\n             * 00       | STOP           |                          | [0..0x20): callvalue                        |\\n             * 5b       | JUMPDEST       |                          |                                             |\\n             *                                                                                                    |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds                      |                                             |\\n             * 3d       | RETURNDATASIZE | 0 cds                    |                                             |\\n             * 3d       | RETURNDATASIZE | 0 0 cds                  |                                             |\\n             * 37       | CALLDATACOPY   |                          | [0..cds): calldata                          |\\n             *                                                                                                    |\\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d       | RETURNDATASIZE | 0                        | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0                      | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0 0                    | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0 0 0                  | [0..cds): calldata                          |\\n             * 61 extra | PUSH2 extra    | e 0 0 0 0                | [0..cds): calldata                          |\\n             *                                                                                                    |\\n             * ::: copy extra data to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 80       | DUP1           | e e 0 0 0 0              | [0..cds): calldata                          |\\n             * 60 0x62  | PUSH1 0x62     | 0x62 e e 0 0 0 0         | [0..cds): calldata                          |\\n             * 36       | CALLDATASIZE   | cds 0x62 e e 0 0 0 0     | [0..cds): calldata                          |\\n             * 39       | CODECOPY       | e 0 0 0 0                | [0..cds): calldata, [cds..cds+e): extraData |\\n             *                                                                                                    |\\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 01       | ADD            | cds+e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3d       | RETURNDATASIZE | 0 cds+e 0 0 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 73 addr  | PUSH20 addr    | addr 0 cds+e 0 0 0 0     | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 5a       | GAS            | gas addr 0 cds+e 0 0 0 0 | [0..cds): calldata, [cds..cds+e): extraData |\\n             * f4       | DELEGATECALL   | success 0 0              | [0..cds): calldata, [cds..cds+e): extraData |\\n             *                                                                                                    |\\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d       | RETURNDATASIZE | rds success 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3d       | RETURNDATASIZE | rds rds success 0 0      | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 93       | SWAP4          | 0 rds success 0 rds      | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 80       | DUP1           | 0 0 rds success 0 rds    | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3e       | RETURNDATACOPY | success 0 rds            | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * 60 0x60  | PUSH1 0x60     | 0x60 success 0 rds       | [0..rds): returndata                        |\\n             * 57       | JUMPI          | 0 rds                    | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * fd       | REVERT         |                          | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b       | JUMPDEST       | 0 rds                    | [0..rds): returndata                        |\\n             * f3       | RETURN         |                          | [0..rds): returndata                        |\\n             * ---------------------------------------------------------------------------------------------------+\\n             */\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\\n                // The actual EVM limit may be smaller and may change over time.\\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            instance := create(value, sub(data, 0x4c), add(extraLength, 0x6c))\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation`\\n    /// with immutable arguments encoded in `data` and `salt`.\\n    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = cloneDeterministic(0, implementation, data, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation`\\n    /// with immutable arguments encoded in `data` and `salt`.\\n    function cloneDeterministic(\\n        uint256 value,\\n        address implementation,\\n        bytes memory data,\\n        bytes32 salt\\n    ) internal returns (address instance) {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\\n                // The actual EVM limit may be smaller and may change over time.\\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            instance := create2(value, sub(data, 0x4c), add(extraLength, 0x6c), salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`\\n    /// using immutable arguments encoded in `data`.\\n    function initCode(address implementation, bytes memory data)\\n        internal\\n        pure\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let dataLength := mload(data)\\n\\n            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.\\n            // The actual EVM limit may be smaller and may change over time.\\n            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))\\n\\n            let o := add(result, 0x8c)\\n            let end := add(o, dataLength)\\n\\n            // Copy the `data` into `result`.\\n            for { let d := sub(add(data, 0x20), o) } 1 {} {\\n                mstore(o, mload(add(o, d)))\\n                o := add(o, 0x20)\\n                if iszero(lt(o, end)) { break }\\n            }\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            mstore(add(result, 0x6c), 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\\n            mstore(add(result, 0x5f), implementation) // Write the address of the implementation.\\n            // Write the rest of the bytecode.\\n            mstore(\\n                add(result, 0x4b),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                add(result, 0x32),\\n                0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                add(result, 0x12),\\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(end, shl(0xf0, extraLength))\\n            mstore(add(end, 0x02), 0) // Zeroize the slot after the result.\\n            mstore(result, add(extraLength, 0x6c)) // Store the length.\\n            mstore(0x40, add(0x22, end)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`\\n    /// using immutable arguments encoded in `data`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash(address implementation, bytes memory data)\\n        internal\\n        pure\\n        returns (bytes32 hash)\\n    {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.\\n            // The actual EVM limit may be smaller and may change over time.\\n            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                sub(data, 0x5a),\\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic clone of\\n    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes memory data,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHash(implementation, data);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*              MINIMAL ERC1967 PROXY OPERATIONS              */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: The ERC1967 proxy here is intended to be upgraded with UUPS.\\n    // This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\\n\\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\\n    function deployERC1967(address implementation) internal returns (address instance) {\\n        instance = deployERC1967(0, implementation);\\n    }\\n\\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\\n    /// Deposits `value` ETH during deployment.\\n    function deployERC1967(uint256 value, address implementation)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * ---------------------------------------------------------------------------------+\\n             * CREATION (34 bytes)                                                              |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\\n             * 81         | DUP2           | r 0 r            |                                 |\\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\\n             * ---------------------------------------------------------------------------------|\\n             * RUNTIME (61 bytes)                                                               |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             *                                                                                  |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36         | CALLDATASIZE   | cds              |                                 |\\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | 0                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 60 0x38    | PUSH1 0x38     | dest succ        | [0..returndatasize): returndata |\\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\\n             * ---------------------------------------------------------------------------------+\\n             */\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\\n            mstore(0x20, 0x6009)\\n            mstore(0x1e, implementation)\\n            mstore(0x0a, 0x603d3d8160223d3973)\\n            instance := create(value, 0x21, 0x5f)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\\n    function deployDeterministicERC1967(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = deployDeterministicERC1967(0, implementation, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    function deployDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\\n            mstore(0x20, 0x6009)\\n            mstore(0x1e, implementation)\\n            mstore(0x0a, 0x603d3d8160223d3973)\\n            instance := create2(value, 0x21, 0x5f, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967(address implementation, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        return createDeterministicERC1967(0, implementation, salt);\\n    }\\n\\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\\n            mstore(0x20, 0x6009)\\n            mstore(0x1e, implementation)\\n            mstore(0x0a, 0x603d3d8160223d3973)\\n            // Compute and store the bytecode hash.\\n            mstore(add(m, 0x35), keccak256(0x21, 0x5f))\\n            mstore(m, shl(88, address()))\\n            mstore8(m, 0xff) // Write the prefix.\\n            mstore(add(m, 0x15), salt)\\n            instance := keccak256(m, 0x55)\\n            for {} 1 {} {\\n                if iszero(extcodesize(instance)) {\\n                    instance := create2(value, 0x21, 0x5f, salt)\\n                    if iszero(instance) {\\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    break\\n                }\\n                alreadyDeployed := 1\\n                if iszero(value) { break }\\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                break\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation`.\\n    function initCodeERC1967(address implementation) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(\\n                add(result, 0x60),\\n                0x3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f300\\n            )\\n            mstore(\\n                add(result, 0x40),\\n                0x55f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076cc\\n            )\\n            mstore(add(result, 0x20), or(shl(24, implementation), 0x600951))\\n            mstore(add(result, 0x09), 0x603d3d8160223d3973)\\n            mstore(result, 0x5f) // Store the length.\\n            mstore(0x40, add(result, 0x80)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHashERC1967(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\\n            mstore(0x20, 0x6009)\\n            mstore(0x1e, implementation)\\n            mstore(0x0a, 0x603d3d8160223d3973)\\n            hash := keccak256(0x21, 0x5f)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic ERC1967 proxy of `implementation`,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddressERC1967(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHashERC1967(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                 ERC1967I PROXY OPERATIONS                  */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: This proxy has a special code path that activates if `calldatasize() == 1`.\\n    // This code path skips the delegatecall and directly returns the `implementation` address.\\n    // The returned implementation is guaranteed to be valid if the keccak256 of the\\n    // proxy's code is equal to `ERC1967I_CODE_HASH`.\\n\\n    /// @dev Deploys a minimal ERC1967I proxy with `implementation`.\\n    function deployERC1967I(address implementation) internal returns (address instance) {\\n        instance = deployERC1967I(0, implementation);\\n    }\\n\\n    /// @dev Deploys a ERC1967I proxy with `implementation`.\\n    /// Deposits `value` ETH during deployment.\\n    function deployERC1967I(uint256 value, address implementation)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * ---------------------------------------------------------------------------------+\\n             * CREATION (34 bytes)                                                              |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\\n             * 81         | DUP2           | r 0 r            |                                 |\\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\\n             * ---------------------------------------------------------------------------------|\\n             * RUNTIME (82 bytes)                                                               |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             *                                                                                  |\\n             * ::: check calldatasize ::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36         | CALLDATASIZE   | cds              |                                 |\\n             * 58         | PC             | 1 cds            |                                 |\\n             * 14         | EQ             | eqs              |                                 |\\n             * 60 0x43    | PUSH1 0x43     | dest eqs         |                                 |\\n             * 57         | JUMPI          |                  |                                 |\\n             *                                                                                  |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36         | CALLDATASIZE   | cds              |                                 |\\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | 0                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 60 0x3E    | PUSH1 0x3E     | dest succ        | [0..returndatasize): returndata |\\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: implementation , return :::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b         | JUMPDEST       |                  |                                 |\\n             * 60 0x20    | PUSH1 0x20     | 32               |                                 |\\n             * 60 0x0F    | PUSH1 0x0F     | o 32             |                                 |\\n             * 3d         | RETURNDATASIZE | 0 o 32           |                                 |\\n             * 39         | CODECOPY       |                  | [0..32): implementation slot    |\\n             * 3d         | RETURNDATASIZE | 0                | [0..32): implementation slot    |\\n             * 51         | MLOAD          | slot             | [0..32): implementation slot    |\\n             * 54         | SLOAD          | impl             | [0..32): implementation slot    |\\n             * 3d         | RETURNDATASIZE | 0 impl           | [0..32): implementation slot    |\\n             * 52         | MSTORE         |                  | [0..32): implementation address |\\n             * 59         | MSIZE          | 32               | [0..32): implementation address |\\n             * 3d         | RETURNDATASIZE | 0 32             | [0..32): implementation address |\\n             * f3         | RETURN         |                  | [0..32): implementation address |\\n             * ---------------------------------------------------------------------------------+\\n             */\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\\n            instance := create(value, 0x0c, 0x74)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.\\n    function deployDeterministicERC1967I(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = deployDeterministicERC1967I(0, implementation, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    function deployDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\\n            instance := create2(value, 0x0c, 0x74, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967I(address implementation, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        return createDeterministicERC1967I(0, implementation, salt);\\n    }\\n\\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\\n            // Compute and store the bytecode hash.\\n            mstore(add(m, 0x35), keccak256(0x0c, 0x74))\\n            mstore(m, shl(88, address()))\\n            mstore8(m, 0xff) // Write the prefix.\\n            mstore(add(m, 0x15), salt)\\n            instance := keccak256(m, 0x55)\\n            for {} 1 {} {\\n                if iszero(extcodesize(instance)) {\\n                    instance := create2(value, 0x0c, 0x74, salt)\\n                    if iszero(instance) {\\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    break\\n                }\\n                alreadyDeployed := 1\\n                if iszero(value) { break }\\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                break\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation`.\\n    function initCodeERC1967I(address implementation) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(\\n                add(result, 0x74),\\n                0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3\\n            )\\n            mstore(\\n                add(result, 0x54),\\n                0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4\\n            )\\n            mstore(add(result, 0x34), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\\n            mstore(add(result, 0x1d), implementation)\\n            mstore(add(result, 0x09), 0x60523d8160223d3973)\\n            mstore(add(result, 0x94), 0)\\n            mstore(result, 0x74) // Store the length.\\n            mstore(0x40, add(result, 0xa0)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHashERC1967I(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\\n            hash := keccak256(0x0c, 0x74)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic ERC1967I proxy of `implementation`,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddressERC1967I(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHashERC1967I(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*            CONSTANT ERC1967 BOOTSTRAP OPERATIONS           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: This enables an ERC1967 proxy to be deployed at a deterministic address\\n    // independent of the implementation:\\n    // ```\\n    //     address bootstrap = LibClone.constantERC1967Bootstrap();\\n    //     address instance = LibClone.deployDeterministicERC1967(0, bootstrap, salt);\\n    //     LibClone.bootstrapConstantERC1967(bootstrap, implementation);\\n    // ```\\n\\n    /// @dev Deploys the constant ERC1967 bootstrap if it has not been deployed.\\n    function constantERC1967Bootstrap() internal returns (address bootstrap) {\\n        bootstrap = constantERC1967BootstrapAddress();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(extcodesize(bootstrap)) {\\n                mstore(0x20, 0x0894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc55)\\n                mstore(0x00, 0x60258060093d393df358357f36)\\n                if iszero(create2(0, 0x13, 0x2e, 0)) {\\n                    mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the implementation address of the ERC1967 bootstrap for this contract.\\n    function constantERC1967BootstrapAddress() internal view returns (address bootstrap) {\\n        bytes32 hash = 0xfe1a42b9c571a6a8c083c94ac67b9cfd74e2582923426aa3b762e3431d717cd1;\\n        bootstrap = predictDeterministicAddress(hash, bytes32(0), address(this));\\n    }\\n\\n    /// @dev Replaces the implementation at `instance`.\\n    function bootstrapERC1967(address instance, address implementation) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, shr(96, shl(96, implementation)))\\n            if iszero(call(gas(), instance, 0, 0x00, 0x20, codesize(), 0x00)) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*          MINIMAL ERC1967 BEACON PROXY OPERATIONS           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: If you use this proxy, you MUST make sure that the beacon is a\\n    // valid ERC1967 beacon. This means that the beacon must always return a valid\\n    // address upon a staticcall to `implementation()`, given sufficient gas.\\n    // For performance, the deployment operations and the proxy assumes that the\\n    // beacon is always valid and will NOT validate it.\\n\\n    /// @dev Deploys a minimal ERC1967 beacon proxy.\\n    function deployERC1967BeaconProxy(address beacon) internal returns (address instance) {\\n        instance = deployERC1967BeaconProxy(0, beacon);\\n    }\\n\\n    /// @dev Deploys a minimal ERC1967 beacon proxy.\\n    /// Deposits `value` ETH during deployment.\\n    function deployERC1967BeaconProxy(uint256 value, address beacon)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * ---------------------------------------------------------------------------------+\\n             * CREATION (34 bytes)                                                              |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\\n             * 81         | DUP2           | r 0 r            |                                 |\\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\\n             * 73 beac    | PUSH20 beac    | beac 0 r         | [0..runSize): runtime code      |\\n             * 60 slotPos | PUSH1 slotPos  | slotPos beac 0 r | [0..runSize): runtime code      |\\n             * 51         | MLOAD          | slot beac 0 r    | [0..runSize): runtime code      |\\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\\n             * ---------------------------------------------------------------------------------|\\n             * RUNTIME (82 bytes)                                                               |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             *                                                                                  |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36         | CALLDATASIZE   | cds              |                                 |\\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | 0                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ~~~~~~~ beacon staticcall sub procedure ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\\n             * 60 0x20       | PUSH1 0x20       | 32                          |                 |\\n             * 36            | CALLDATASIZE     | cds 32                      |                 |\\n             * 60 0x04       | PUSH1 0x04       | 4 cds 32                    |                 |\\n             * 36            | CALLDATASIZE     | cds 4 cds 32                |                 |\\n             * 63 0x5c60da1b | PUSH4 0x5c60da1b | 0x5c60da1b cds 4 cds 32     |                 |\\n             * 60 0xe0       | PUSH1 0xe0       | 224 0x5c60da1b cds 4 cds 32 |                 |\\n             * 1b            | SHL              | sel cds 4 cds 32            |                 |\\n             * 36            | CALLDATASIZE     | cds sel cds 4 cds 32        |                 |\\n             * 52            | MSTORE           | cds 4 cds 32                | sel             |\\n             * 7f slot       | PUSH32 slot      | s cds 4 cds 32              | sel             |\\n             * 54            | SLOAD            | beac cds 4 cds 32           | sel             |\\n             * 5a            | GAS              | g beac cds 4 cds 32         | sel             |\\n             * fa            | STATICCALL       | succ                        | impl            |\\n             * 50            | POP              |                             | impl            |\\n             * 36            | CALLDATASIZE     | cds                         | impl            |\\n             * 51            | MLOAD            | impl                        | impl            |\\n             * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\\n             * 5a         | GAS            | g impl 0 cds 0 0 | [0..calldatasize): calldata     |\\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 60 0x4d    | PUSH1 0x4d     | dest succ        | [0..returndatasize): returndata |\\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\\n             * ---------------------------------------------------------------------------------+\\n             */\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\\n            instance := create(value, 0x0c, 0x74)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic minimal ERC1967 beacon proxy with `salt`.\\n    function deployDeterministicERC1967BeaconProxy(address beacon, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = deployDeterministicERC1967BeaconProxy(0, beacon, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic minimal ERC1967 beacon proxy with `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    function deployDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\\n            instance := create2(value, 0x0c, 0x74, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Creates a deterministic minimal ERC1967 beacon proxy with `salt`.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967BeaconProxy(address beacon, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        return createDeterministicERC1967BeaconProxy(0, beacon, salt);\\n    }\\n\\n    /// @dev Creates a deterministic minimal ERC1967 beacon proxy with `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\\n            // Compute and store the bytecode hash.\\n            mstore(add(m, 0x35), keccak256(0x0c, 0x74))\\n            mstore(m, shl(88, address()))\\n            mstore8(m, 0xff) // Write the prefix.\\n            mstore(add(m, 0x15), salt)\\n            instance := keccak256(m, 0x55)\\n            for {} 1 {} {\\n                if iszero(extcodesize(instance)) {\\n                    instance := create2(value, 0x0c, 0x74, salt)\\n                    if iszero(instance) {\\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    break\\n                }\\n                alreadyDeployed := 1\\n                if iszero(value) { break }\\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                break\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code of the minimal ERC1967 beacon proxy.\\n    function initCodeERC1967BeaconProxy(address beacon)\\n        internal\\n        pure\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(\\n                add(result, 0x74),\\n                0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3\\n            )\\n            mstore(\\n                add(result, 0x54),\\n                0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c\\n            )\\n            mstore(add(result, 0x34), 0x60195155f3363d3d373d3d363d602036600436635c60da)\\n            mstore(add(result, 0x1d), beacon)\\n            mstore(add(result, 0x09), 0x60523d8160223d3973)\\n            mstore(add(result, 0x94), 0)\\n            mstore(result, 0x74) // Store the length.\\n            mstore(0x40, add(result, 0xa0)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the minimal ERC1967 beacon proxy.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHashERC1967BeaconProxy(address beacon) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\\n            hash := keccak256(0x0c, 0x74)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic ERC1967 beacon proxy,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddressERC1967BeaconProxy(\\n        address beacon,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHashERC1967BeaconProxy(beacon);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      OTHER OPERATIONS                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the address when a contract with initialization code hash,\\n    /// `hash`, is deployed with `salt`, by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\\n        internal\\n        pure\\n        returns (address predicted)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and store the bytecode hash.\\n            mstore8(0x00, 0xff) // Write the prefix.\\n            mstore(0x35, hash)\\n            mstore(0x01, shl(96, deployer))\\n            mstore(0x15, salt)\\n            predicted := keccak256(0x00, 0x55)\\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Requires that `salt` starts with either the zero address or `by`.\\n    function checkStartsWith(bytes32 salt, address by) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the salt does not start with the zero address or `by`.\\n            if iszero(or(iszero(shr(96, salt)), eq(shr(96, shl(96, by)), shr(96, salt)))) {\\n                mstore(0x00, 0x0c4549ef) // `SaltDoesNotStartWith()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xeef85d149b91730bbcf9a657bcd716de80ad0919b9e085beb9c018eb451c0aa1\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608080604052346200008a576108c28181016001600160401b038111838210176200007457829162003ef1833903906000f080156200006857600080546001600160a01b0319166001600160a01b0392909216919091179055604051613e619081620000908239f35b6040513d6000823e3d90fd5b634e487b7160e01b600052604160045260246000fd5b600080fdfe6080604090808252600490813610156100a6575b505036156100a45760008035908160e01c9263bc197c81841463f23a6e6185141763150b7a0285141761009a57906100929133825260056020526001600160a01b03918282822054169460066020526001600160e01b031983832091168252602052205416610082818461317c565b9161008c36613b29565b94613243565b602081519101f35b836020526020603cf35b005b600091823560e01c9182630a664dba1461220a57508163112d3a7d146121eb5781631626ba7e1461219a57816319822f7c14611c5c578163540fb4f9146119825781636a5e15151461191b57816385571368146117ba5781639517e29f146114f65781639cfd7cff146113b6578163a71763a814610f32578163b0d691fe14610f07578163b875d5d814610eb9578163d03c791414610e99578163d691c9641461091a578163d828435d14610835578163e9ae5c5314610425578163ea5f61d014610296578163eab77e17146101e5578163f2dc691d146101b9575063f698da25146101925780610013565b90346101b557816003193601126101b5576020906101ae612b1e565b9051908152f35b5080fd5b8383346101e25760203660031901126101e257506101d960209235612ae3565b90519015158152f35b80fd5b8284346101b55760603660031901126101b55782356001600160a01b03811681036102925760243567ffffffffffffffff811161028e5761022990369086016122d6565b916044359360ff8516850361028a5760131936013560601c6f71727de22e5e9d8baf0edac6f37da0328114908115610280575b5015610271575061026e949550612e59565b80f35b869051635629665f60e11b8152fd5b905033148861025c565b8580fd5b8380fd5b8280fd5b8383346101e257816003193601126101e2576102b0612237565b91602435913381526020906003602052828120906001600160a01b03918287169360019760018614159081610413575b506103fd5786156103ee579087916102f7886130de565b9784966000528260205285886000205416995b610388575b50505050600182871614158061037f575b61033c575b5050906103389183525192839283612307565b0390f35b9194509060001985019085821161036c57508394955061035f906103389461311d565b5116929150838580610325565b80601188634e487b7160e01b6024945252fd5b50821515610320565b909192959885811690811515806103e4575b806103db575b156103d35750806103b18b8b61311d565b52600052828252856103c9868960002054169a613131565b969392919061030a565b99965061030f565b50828b106103a0565b508782141561039a565b88865163f725081760e01b8152fd5b60248986885191637c84ecfb60e01b8352820152fd5b61041e915083613c5e565b158a6102e0565b9050610430366123be565b9290338552602095600587526001600160a01b039687828820541692600682528288207fe9ae5c53000000000000000000000000000000000000000000000000000000008952825288838920541694610489868661317c565b989097601319908136013560601c6f71727de22e5e9d8baf0edac6f37da032811490811561082b575b501561081c576001600160f81b031990818160081b16801560001461066d5750811690600160f81b820361054d5750505050509161054261026e98999261053485610548963501948c5416935194827f3f707e6b0000000000000000000000000000000000000000000000000000000087948501528135910160248401613a7b565b03601f19810184528361258e565b336137ad565b613243565b9080929395949d50156000146106145750505061057e8a610572610596948694613a53565b96929491963691612aac565b8751958694859463468721a760e01b86528501612cc8565b03816000335af1918215610609576000926105ce575b5050156105bf575061026e949550613243565b869051632b3f6d1160e21b8152fd5b90809250813d8311610602575b6105e5818361258e565b810103126105fd576105f690612c6c565b38806105ac565b600080fd5b503d6105db565b83513d6000823e3d90fd5b90809395509b9395919a9b146000146106585750505081601411610654576106496105489261026e9836910160148401612aac565b903560601c336137ad565b8780fd5b602493505191632e5bf3f960e21b8352820152fd5b9190600160f81b9e98979695949d9e92838114600014610806575081169182036106eb575050505061026e9850610548939291610534826106e5933501948c5416935194827f50c890220000000000000000000000000000000000000000000000000000000087948501528135910160248401613a7b565b3361386f565b90809293959750156000146107cc57505050839161070f6107339a61071b93613a53565b9c9294919c3691612aac565b85519b8c94859463468721a760e01b86528501612cc8565b03818b335af180156107c257889061078c575b61026e975015610758575b5050613243565b7fb8bc84bd77f5eb08210b8eb20fd63b3ec6a7992d277ab94663bae0e066f792ac9188825191338352820152a13880610751565b508187813d83116107bb575b6107a2818361258e565b81010312610654576107b661026e97612c6c565b610746565b503d610798565b81513d8a823e3d90fd5b919a955091939082036106585750505081601411610654576107fb6105489261026e9836910160148401612aac565b903560601c3361386f565b856024918a51916308c3ee0360e11b8352820152fd5b838751635629665f60e11b8152fd5b90503314386104b2565b8284346101b557806003193601126101b55761084f612237565b6001600160a01b039360243585811681036105fd5777ffffffffffffffffffffffffffffffffffffffff00000000916020968551947f35567e1a0000000000000000000000000000000000000000000000000000000086521690840152851b16602482015283816044816f71727de22e5e9d8baf0edac6f37da0325afa92831561090f57926108e0575b5051908152f35b9091508281813d8311610908575b6108f8818361258e565b810103126105fd575190836108d9565b503d6108ee565b8251903d90823e3d90fd5b9050610925366123be565b909391601319918236013560601c953385526020966003885261094a818a8820613c5e565b15610e6a5750338552600587526001600160a01b039081898720541696600689528987207fd691c9640000000000000000000000000000000000000000000000000000000088528952828a88205416936109a4858a61317c565b9790966109b0336139b2565b6001600160f81b031990818160081b168015600014610c0e5750811690600160f81b8203610ac9575050505050610a2e91610a288261053493350191885416918b519384917f61085573000000000000000000000000000000000000000000000000000000008d8401528c8135910160248401613a7b565b33613ddd565b80518101878282031261028a57878201519067ffffffffffffffff8211610ac5579188610a669281610a6c9897969501920101613d5d565b95613243565b83519280840190808552835180925280868601968360051b870101940192955b828710610a995785850386f35b909192938280610ab5600193603f198a82030186528851612384565b9601920196019592919092610a8c565b8680fd5b9080929395949d9c9b965015600014610ba5575050506000610b25610af78c999897969594610b0d94613a53565b9b9293919590610b05613a1e565b9c3691612aac565b8d519586948594635229073f60e01b86528501612cc8565b038183335af1908115610b9a57600090600092610b74575b5015610b65578697989950610b55610a6c9697613110565b52610b5f87613110565b50613243565b898951632b3f6d1160e21b8152fd5b9050610b9391503d806000833e610b8b818361258e565b810190612c93565b9038610b3d565b89513d6000823e3d90fd5b819c929a9b9c94939414600014610bf857505080601411610ac557610a6c9594939291610be4610bef92610bd7613a1e565b9a36910160148401612aac565b903560601c33613ddd565b610b5588613110565b602492508b5191632e5bf3f960e21b8352820152fd5b959d9c9b9a9998979695600160f81b929190838103610e5357508116918203610d3c57505050505061053490610c888a610c8e9495969798999a9b350191885416918b519384917f9abb6e17000000000000000000000000000000000000000000000000000000008d8401528c8135910160248401613a7b565b33613ce0565b8051810190888189840193031261028a57878101519067ffffffffffffffff9182811161065457810183603f8201121561065457898101518b8b610cd1836130c6565b610cdd8351918261258e565b838152019160051b83010191858311610d38578c8c9101915b838310610d20575050505089810151918211610ac5579188610a6692610a6c979695940101613d5d565b8190610d2b84612c6c565b8152019101908b90610cf6565b8980fd5b90809293949a955015600014610e1357505050610d8e610d608792610d769c613a53565b9a9293919d90610d6e613a1e565b9b3691612aac565b8c519d8e948594635229073f60e01b86528501612cc8565b038183335af18015610e09578596979899610a6c96908892610dec575b5015610dba57610b5588613110565b7fb8bc84bd77f5eb08210b8eb20fd63b3ec6a7992d277ab94663bae0e066f792ac8a8051338152898c820152a1610bef565b9050610e0291503d8089833e610b8b818361258e565b9038610dab565b88513d87823e3d90fd5b819c949596979899929a9b9c14600014610bf857505080601411610ac557610a6c9594939291610e48610bef92610bd7613a1e565b903560601c33613ce0565b868f9160249251916308c3ee0360e11b8352820152fd5b866024918a51917fb927fe5e000000000000000000000000000000000000000000000000000000008352820152fd5b8383346101e25760203660031901126101e257506101d960209235612a21565b839150346102925760203660031901126102925735916001600160e01b031983168093036105fd57816001600160a01b03916020943382526006865282822090825285522054169051908152f35b8284346101b557816003193601126101b557602090516f71727de22e5e9d8baf0edac6f37da0328152f35b9050610f3d3661228f565b92909391338652602090600582526001600160a01b039283898920541693600684528989207fa71763a8000000000000000000000000000000000000000000000000000000008a528452808a8a20541695610f98878761317c565b99909860131936013560601c6f71727de22e5e9d8baf0edac6f37da03281149081156113ac575b501561139d57839291906001860361111a5790610fde91810190613831565b92169083861680158015611110575b6110fa5780858f611011866001600160a01b03166000526002602052604060002090565b336000528b526000205416036110e45750508a8561026e9c9d956106e59561054899956105349561105d637827252560e01b9b6001600160a01b03166000526002602052604060002090565b336000528852611087838b6000205416916001600160a01b03166000526002602052604060002090565b336000528852896000206001600160a01b031991828254161790556110bf856001600160a01b03166000526002602052604060002090565b33600052885289600020908154169055935b54169651978895860152602485016129c5565b602492508d5191637c84ecfb60e01b8352820152fd5b506024918d5191637c84ecfb60e01b8352820152fd5b5060018114610fed565b9250600285036111f9579061113e8493928e8e33815260038b522093810190613831565b93169184871691821580156111ef575b6111d857828f879086600052848c526000205416036111c15750958c9d956106e595610548999561026e9f949586637827252560e01b9b610534986000528952838b6000205416916000528a6000206001600160a01b0319928382541617905560005289600020908154169055936110d1565b90506024918e5191637c84ecfb60e01b8352820152fd5b60249150838f5191637c84ecfb60e01b8352820152fd5b506001831461114e565b9492909a9b93959160038714600014611289578c9086019385878603126101b557611223876123a9565b97848801359367ffffffffffffffff851161028e5761026e9e6105489a61125a6106e59961053498637827252560e01b9d01613465565b9133875288526001600160e01b03198a87209116865287528885206001600160a01b03198154169055936110d1565b8b87959d9c9397969294961460001461138757906112a991810190613480565b929091600281101561137457801580611362575b1561130057505050936105348a637827252560e01b9561026e9c9d956106e59561054899338552600587528885206001600160a01b031981541690555b936110d1565b60010361135457508a637827252560e01b9561026e9c9d956106e595610548999561053495338652600688526001600160e01b03198a87209116865287528885206001600160a01b031981541690556112fa565b8c51635691922f60e01b8152fd5b506001600160e01b03198316156112bd565b60248d602184634e487b7160e01b835252fd5b602483868f519163041c38b360e41b8352820152fd5b828d51635629665f60e11b8152fd5b9050331438610fbf565b8284346101b557816003193601126101b55781815180947fffa1ad7400000000000000000000000000000000000000000000000000000000825281335afa9182156114eb578092611492575b61033883836114806034825180947f736166652d000000000000000000000000000000000000000000000000000000602083015261144a815180926020602586019101612361565b81017f2e657263373537392e76302e302e310000000000000000000000000000000000602582015203601481018552018361258e565b51918291602083526020830190612384565b9091503d8082853e6114a4818561258e565b8301926020818503126101b55780519067ffffffffffffffff821161029257019083601f830112156101e25750610338928160206114e4935191016129ea565b9083611402565b9051903d90823e3d90fd5b82846115013661228f565b95929391909333865260056020526001600160a01b0392838188205416926006602052818820907f9517e29f0000000000000000000000000000000000000000000000000000000091828a5260205285838a20541695611561878761317c565b99909860131936013560601c6f71727de22e5e9d8baf0edac6f37da03281149081156117b0575b50156117a257600187036115e157508a83610548979695936115ca61026e9e9f94610534956115b961054299613935565b6115c38533612ffc565b3691612aac565b925b541695519687946020860152602485016129c5565b6002870361160e57508a836105489796959361160861026e9e9f61053495610542986136c5565b926115cc565b6003870361163557508a836105489796959361160861026e9e9f61053495610542986134c2565b86810361165b57508a836105489796959361160861026e9e9f61053495610542986132e6565b909b508561178c578b358c019b8c91602082013582019060208201913592888101350193358303611765579d91908d9e8f5b8435116116be57505050508a61026e9b9c506105429361054897969593611608610534943690602081359101612aac565b839f8082602060019360051b880101358381146000146117065750506116fb6116e88287876132cf565b6116f18c613935565b6115c38c33612ffc565b505b019f508f61168d565b6002810361172c57505061172561171e8287876132cf565b908b6136c5565b505b6116fd565b6003810361174b5750506117256117448287876132cf565b908b6134c2565b036117275761172561175e8287876132cf565b908b6132e6565b87517fb4fa3fb3000000000000000000000000000000000000000000000000000000008152fd5b6024908686519163041c38b360e41b8352820152fd5b8551635629665f60e11b8152fd5b905033148e611588565b8284346101b557806003193601126101b5576117d4612237565b90602435916001600160a01b038082169460019560018114158061190a575b6118f4575084156118e55785611808866130de565b9561182783956001600160a01b03166000526002602052604060002090565b903360005260209160205284876000205416985b611866575b505050600182871614158061037f5761033c575050906103389183525192839283612307565b90919497848116801515806118db575b806118d2575b156118ca57906118aa916118908b8b61311d565b526001600160a01b03166000526002602052604060002090565b336000528252846118c18588600020541699613131565b9592919061183b565b509794611840565b50828a1061187c565b5086811415611876565b86845163f725081760e01b8152fd5b87602491865191637c84ecfb60e01b8352820152fd5b506119158433613c97565b156117f3565b905060203660031901126101b55780359067ffffffffffffffff821161029257611947913691016122d6565b61195033612f80565b825b81811061195d578380f35b8061197c6119766119716001948688612979565b6129b1565b33612ffc565b01611952565b83915060031960a03682011261028e5767ffffffffffffffff91803583811161028a576119b290369083016122d6565b929094602435858111610654576119cc90369085016122d6565b604435878111610d38576119e390369087016122d6565b939094606435898111611c58576119fd90369089016122d6565b979099608435818111611c5457606081360394850112611c545780830135916001600160a01b03948584168403611c505760248301359060221901811215611c5057820184810135918211611c5057602401918160051b36038313611c5057604401359160ff83168303611c5057611a7493612e59565b60019a8b60005260209960028b5284600020336000528b528385600020541615600014611c19578c8e611aa633612f80565b828110611bdd57505050505b338c5260038952828c20918b600052828a52836000205416611bcf5750896000528752600020886001600160a01b031982541617905587895b828110611b9c575050505085875b828110611b695750505050845b818110611b365785337ff48581d8a62b775b74f2fb67f1d5806a9a356fbcc598040ab3071d3e37af40c28280a280f35b80611b62611b4687938588612979565b611b5c611b52826129b1565b9187810190612f4d565b916132e6565b5001611b06565b611b93611b77828587612979565b611b8d611b83826129b1565b9189810190612f4d565b916134c2565b50018690611af9565b611bc6611baa828587612979565b611bc0611bb6826129b1565b918b810190612f4d565b916136c5565b50018890611aeb565b82516329e42f3360e11b8152fd5b611c108d6115c3611c04611bf285888a612979565b611bfb816129b1565b93810190612f4d565b91909261197681613935565b50018d90611aa6565b905015611ab2576024908351907fd8e3ed1b0000000000000000000000000000000000000000000000000000000082523390820152fd5b8f80fd5b8d80fd5b8b80fd5b828460031960603682011261029257833567ffffffffffffffff9182821161217657610120828701918336030112612176576f71727de22e5e9d8baf0edac6f37da032917fffffffffffffffffffffffffffffffff8e8d821dd1a1627450f125390c825fce36601319013560601c0161218b5760248101358060601c8015801561217a575b156120435750611cf5610104830184612f4d565b919092826006116120295782600c1161202957600684013594611d1e6115c36044840183612f4d565b6020815191012091611d366115c36064830184612f4d565b602081519101209060848101356fffffffffffffffffffffffffffffffff92611d6b6115c360c48501359660e4860190612f4d565b60208151910120958d51978d6101c08a01908a82109082111761202d57928f926101c0999795928460a496611e5b9e9d9b9996527f84aa190356f56b8c87825f54884392a9907c23ee0f8e1ea86336b763faf021bd8b523360208c01528a01526060890152608088015283811660a088015260801c60c0870152013560e0850152811661010084015260801c610120830152610140820152843560d01c6101608201528560d01c610180820152866101a082015220611e69611e2b612b1e565b9189519485916020830194859091604292601960f81b8352600160f81b6001840152600283015260228201520190565b03601f19810185528461258e565b82519020333b1561202957918891611e9e8b948a51958694859463934f3a1160e01b8652600b190192600c8a019286016125f3565b0381335afa9081612016575b50611fdd579065ffffffffffff60a01b7fffffffffffff000000000000000000000000000000000000000000000000000060019335169160301c1617175b935b604435611efc575b6020858551908152f35b8351926020840190811184821017611fc85791611f499391602093865282528451938492839263468721a760e01b8452898401526044356024840152608060448401526084830190612384565b6000606483015203816000335af1908115611fbd57600091611f83575b5015611f7457828080611ef2565b905051632b3f6d1160e21b8152fd5b90506020813d602011611fb5575b81611f9e6020938361258e565b810103126105fd57611faf90612c6c565b84611f66565b3d9150611f91565b82513d6000823e3d90fd5b604187634e487b7160e01b6000525260246000fd5b7fffffffffffff000000000000000000000000000000000000000000000000000065ffffffffffff60a01b9135169160301c1617611ee8565b61202290979197612548565b9588611eaa565b8880fd5b50508f8f6041602492634e487b7160e01b835252fd5b906121599061214361215f959489519586937f970032030000000000000000000000000000000000000000000000000000000060208601528b60248601526001600160a01b036120928361224d565b16606486015260848501526121336120c36120b0604485018461292b565b61012060a48901526101848801916125d2565b916120e86120d4606486018361292b565b606319898703810160c48b015295916125d2565b608485013560e488015261212b6101049160a4870135838a015260c48701356101248a015261211a60e488018561292b565b90878b8403016101448c01526125d2565b94019061292b565b91858403016101648601526125d2565b602435604483015203601f19810184528361258e565b33612cfa565b602081805181010312612176576020015193611eea565b8480fd5b506121858133613c97565b15611ce1565b868551635629665f60e11b8152fd5b8383346101e257816003193601126101e2576024359067ffffffffffffffff82116101e257506121e36020936121dc6001600160e01b03199336908301612261565b913561261f565b915191168152f35b8284346101b5576020906101d96122013661228f565b929190916123ee565b839085346102925782600319360112610292576001600160a01b0390602093338152600585522054168152f35b600435906001600160a01b03821682036105fd57565b35906001600160a01b03821682036105fd57565b9181601f840112156105fd5782359167ffffffffffffffff83116105fd57602083818601950101116105fd57565b60606003198201126105fd57600435916024356001600160a01b03811681036105fd57916044359067ffffffffffffffff82116105fd576122d291600401612261565b9091565b9181601f840112156105fd5782359167ffffffffffffffff83116105fd576020808501948460051b0101116105fd57565b909291926040820190604083528051809252606083019160208092019160005b82811061234457505050506001600160a01b036020919416910152565b83516001600160a01b031685529381019392810192600101612327565b60005b8381106123745750506000910152565b8181015183820152602001612364565b9060209161239d81518092818552858086019101612361565b601f01601f1916010190565b35906001600160e01b0319821682036105fd57565b9060406003198301126105fd57600435916024359067ffffffffffffffff82116105fd576122d291600401612261565b90929060018103612409575050506124069033613c97565b90565b6002810361242b57505050612406903360005260036020526040600020613c5e565b6003810361247e575081602091810103126105fd57612449906123a9565b3360005260046020526001600160e01b0319604060002091166000526020526001600160a01b03806040600020541691161490565b9192916004036125405782604091810103126105fd5781359160028310156105fd5760206124ac91016123a9565b60009280158061252e575b61250e575b6001146124d6575b506001600160a01b0380911691161490565b9091503360005260066020526001600160e01b0319604060002091166000526020526001600160a01b036040600020541690386124c4565b336000908152600560205260409020546001600160a01b031693506124bc565b506001600160e01b03198216156124b7565b505050600090565b67ffffffffffffffff811161255c57604052565b634e487b7160e01b600052604160045260246000fd5b6040810190811067ffffffffffffffff82111761255c57604052565b90601f8019910116810190811067ffffffffffffffff82111761255c57604052565b90602091808252806000848401376000828201840152601f01601f1916010190565b908060209392818452848401376000828201840152601f01601f1916010190565b92906124069492612611918552606060208601526060850190612384565b9260408185039101526125d2565b918015806128a0575b61289257806014116105fd57813560601c9081158015612881575b6126d4576126af936105346126a9926013199560146040519788957ff551e2ee0000000000000000000000000000000000000000000000000000000060208801528136013560601c602488015260448701526060606487015260848601930191016125d2565b33612b99565b6020818051810103126105fd57602001516001600160e01b0319811681036105fd5790565b905060409182517ff698da250000000000000000000000000000000000000000000000000000000081526020948582600481335afa91821561287657600092612845575b506127d890855187810191825287815261273181612572565b51902085519087820190815287825261274982612572565b61279687805180936127878c8301967f60b3cbf8b4a223d68d641b3b6ddf9a298e7f33710cf3d3a9d1146b5a6150fbca885251809285850190612361565b8101038a81018452018261258e565b519020956127ca8651978892830194859091604292601960f81b8352600160f81b6001840152600283015260228201520190565b03601f19810187528661258e565b8451902091333b156105fd5761280e6014926000948651978895869563934f3a1160e01b875260131901930191600486016125f3565b0381335afa90811561283b575061282c575b50630b135d3f60e11b90565b61283590612548565b38612820565b513d6000823e3d90fd5b9091508581813d831161286f575b61285d818361258e565b810103126105fd5751906127d8612718565b503d612853565b85513d6000823e3d90fd5b5061288c8233613c97565b15612643565b505050630b135d3f60e11b90565b506040517f5ae6bd37000000000000000000000000000000000000000000000000000000008152836004820152602081602481335afa90811561291f576000916128ed575b501515612628565b90506020813d602011612917575b816129086020938361258e565b810103126105fd5751386128e5565b3d91506128fb565b6040513d6000823e3d90fd5b9035601e19823603018112156105fd57016020813591019167ffffffffffffffff82116105fd5781360383136105fd57565b67ffffffffffffffff811161255c57601f01601f191660200190565b919081101561299b5760051b81013590603e19813603018212156105fd570190565b634e487b7160e01b600052603260045260246000fd5b356001600160a01b03811681036105fd5790565b6001600160a01b03612406949360609383521660208201528160408201520190612384565b909291926129f78161295d565b91612a05604051938461258e565b8294828452828201116105fd576020612a1f930190612361565b565b8060081b6001600160f81b031980921682600160f81b91828114600014612a8c57505060019283925b8380612a82575b15612a5d575050505090565b83612a76575b505050600014612a705790565b50600090565b16149050388080612a63565b5081811615612a51565b80612a9d5750506001928392612a4a565b03612540576001928392612a4a565b929192612ab88261295d565b91612ac6604051938461258e565b8294818452818301116105fd578281602093846000960137010152565b60018103612af15750600190565b60028103612aff5750600190565b60038103612b0d5750600190565b600403612b1957600190565b600090565b60405160208101907f47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a794692188252466040820152306060820152606081526080810181811067ffffffffffffffff82111761255c5760405251902090565b6040906001600160a01b0361240694931681528160208201520190612384565b600090602092949394612bd96040519687927f6a221657000000000000000000000000000000000000000000000000000000008785015260248401612b79565b0394612bed601f199687810183528261258e565b612c35612c416001600160a01b0385541692604051928391888301957fb4faba0900000000000000000000000000000000000000000000000000000000875260248401612b79565b0388810183528261258e565b51915afa503d91604051928181850101604052016020833e60005115612c6357565b50602081519101fd5b519081151582036105fd57565b9080601f830112156105fd578151612406926020016129ea565b9190916040818403126105fd57612ca981612c6c565b92602082015167ffffffffffffffff81116105fd576124069201612c79565b9392612cf5906000936001600160a01b036060941687526020870152608060408701526080860190612384565b930152565b90612d45909392936001600160a01b0392839160405196879586948593635229073f60e01b855216600484015260009889968793846024840152608060448401526084830190612384565b8360648301520393165af1908115612d9c57838092612d7a575b50509115612d6957565b6004604051632b3f6d1160e21b8152fd5b909150612d929293503d8091833e610b8b818361258e565b9190913880612d5f565b6040513d85823e3d90fd5b612dee926020916001600160a01b03938492604051958694859363468721a760e01b8552166004840152826000988993846024840152608060448401526084830190612384565b8360648301520393165af1918215612e4d578092612e10575b505015612d6957565b9091506020823d602011612e45575b81612e2c6020938361258e565b810103126101e25750612e3e90612c6c565b3880612e07565b3d9150612e1f565b604051903d90823e3d90fd5b92919233600052600160209460016020526040600020956001600160a01b0380941696876001600160a01b031982541617905581604051967ff05c04e100000000000000000000000000000000000000000000000000000000602089015260ff606489019116602489015260406044890152526084860194936000905b838210612f295750505050505090612efa81612f019303601f19810183528261258e565b8233612da7565b337f9452c8fb077c3ea8f28a77c87488af657b1e44d010ad9a5992d73870da040e94600080a3565b909192938380879884612f3c859a61224d565b168152019701959493920190612ed6565b903590601e19813603018212156105fd570180359067ffffffffffffffff82116105fd576020019181360383136105fd57565b6001600160a01b0390811660008181527fe90b7bceb6e7df5418fb78d8ee546e97c83a08bbccc01a0644d599ccd2a7c2e060205260408120549192909116612feb576040916001825260026020528282209082526020522060016001600160a01b0319825416179055565b60046040516329e42f3360e11b8152fd5b906001600160a01b0380911690811580156130bc575b6130a45760008281526020936002855260409280848420921691828452865280848420541661308d57600183526002865283832082845286528383205416948483526002815283832082845281528383206001600160a01b031996878254161790556001835260028152838320918352522091825416179055565b602485855190631034f46960e21b82526004820152fd5b60248260405190637c84ecfb60e01b82526004820152fd5b5060018214613012565b67ffffffffffffffff811161255c5760051b60200190565b906130e8826130c6565b6130f5604051918261258e565b8281528092613106601f19916130c6565b0190602036910137565b80511561299b5760200190565b805182101561299b5760209160051b010190565b60001981146131405760010190565b634e487b7160e01b600052601160045260246000fd5b906020828203126105fd57815167ffffffffffffffff81116105fd576124069201612c79565b90916060926060926001600160a01b03908181166131f5575b50811661319f5750565b6124069192506131e6906040519063d68f602560e01b602083015260131936013560601c6024830152346044830152606060648301526121598261053460848201366125b0565b60208082518301019101613156565b61323c9195506131e6906040519063d68f602560e01b602083015260131936013560601c6024830152346044830152606060648301526121598261053460848201366125b0565b9338613195565b929190926001600160a01b0391828216613299575b50508216613264575050565b612a1f9161329361053492604051938491630b9dfbed60e11b6020840152602060248401526044830190612384565b33612da7565b6132c89161329361053492604051938491630b9dfbed60e11b6020840152602060248401526044830190612384565b3880613258565b9082101561299b576122d29160051b810190612f4d565b9060009233845260016020526001600160a01b039160409183838720541680613400575b509061331891810190613480565b959160028110156133ec578015806133da575b15613393575050338152600560205282828220541680613363575033815260056020522091166001600160a01b031982541617905590565b6024908351907f741cbe030000000000000000000000000000000000000000000000000000000082526004820152fd5b6001036133ca5733825260066020526001600160e01b0319838320911682526020522091166001600160a01b031982541617905590565b60048351635691922f60e01b8152fd5b506001600160e01b031982161561332b565b602483634e487b7160e01b81526021600452fd5b803b15610ac5578660649185519283809263529562a160e01b8252336004830152898b166024830152600460448301525afa801561345b579061331893929161344c575b50909161330a565b61345590612548565b38613444565b84513d89823e3d90fd5b9080601f830112156105fd5781602061240693359101612aac565b916060838303126105fd57823560028110156105fd57926134a3602082016123a9565b92604082013567ffffffffffffffff81116105fd576124069201613465565b90600091338352602093600185526001600160a01b03936040918583832054168061366f575b508401956060858803126101b5576134ff856123a9565b9681860135956001600160f81b03198716870361028e57848101359067ffffffffffffffff8211612176579161353f916001600160e01b03199301613465565b9716907f6d61fe700000000000000000000000000000000000000000000000000000000082148015613646575b613616573383526004815283832082845281528684842054166135e657917fffffffffffffffffffffff000000000000000000000000000000000000000000939174ff00000000000000000000000000000000000000009333835260048152838320918352522094855493169360581c1691161717905590565b6024828551907f74420d150000000000000000000000000000000000000000000000000000000082526004820152fd5b6024828551907f79bd117b0000000000000000000000000000000000000000000000000000000082526004820152fd5b507f8a91b0e300000000000000000000000000000000000000000000000000000000821461356c565b803b15610292578260649185519283809263529562a160e01b82523360048301528b8a166024830152600360448301525afa80156136bb57156134e8576136b590612548565b386134e8565b84513d85823e3d90fd5b92916136d0846139b2565b60003381526003602052604094858220956001600160a01b038092169182158015613775575b61375e5782845287602052808285205416613747576124069697600185526020528184205416928281528181206001600160a01b031994858254161790556001815220918254161790553691612aac565b602483835190631034f46960e21b82526004820152fd5b602483835190637c84ecfb60e01b82526004820152fd5b50600183146136f6565b9291612cf56060916001600160a01b0360019416865260006020870152608060408701526080860190612384565b916137db9260209260006001600160a01b0360405180978196829563468721a760e01b84526004840161377f565b0393165af190811561291f576000916137f7575b5015612d6957565b90506020813d602011613829575b816138126020938361258e565b810103126105fd5761382390612c6c565b386137ef565b3d9150613805565b9190916040818403126105fd5780356001600160a01b03811681036105fd5792602082013567ffffffffffffffff81116105fd576124069201613465565b6001600160a01b0390929192169161389960405192839263468721a760e01b84526004840161377f565b03906020816000938185875af190811561392a5782916138f0575b50156138be575050565b7fb8bc84bd77f5eb08210b8eb20fd63b3ec6a7992d277ab94663bae0e066f792ac9160409182519182526020820152a1565b90506020813d602011613922575b8161390b6020938361258e565b810103126101b55761391c90612c6c565b386138b4565b3d91506138fe565b6040513d84823e3d90fd5b600033815260016020526001600160a01b0380604083205416928361395b575b50505050565b833b15610292579060648392604051958693849263529562a160e01b8452336004850152166024830152600160448301525afa908115612e4d57506139a3575b808080613955565b6139ac90612548565b3861399b565b600033815260016020526001600160a01b038060408320541692836139d75750505050565b833b15610292579060648392604051958693849263529562a160e01b8452336004850152166024830152600260448301525afa908115612e4d57506139a357808080613955565b604051613a2a81612572565b600181528060005b602080821015613a4d57906060602092828501015201613a32565b50505090565b90806014116105fd57813560601c92816034116105fd57601483013592603401916033190190565b6020928084830185845252604093604083019260408360051b8201019585600080935b868510613ab15750505050505050505090565b909192939495969798603f198282030189528935605e198536030181121561028e5787613b1860019387839401613b096060916001600160a01b03613af58261224d565b16845285810135868501528b81019061292b565b919092818c82015201916125d2565b9b0199019796950193929190613a9e565b9060609160003381526020906004825260408120916001600160e01b03198235169283835281526040822054926001600160f81b03196001600160a01b0385169460581b16908415613c2d57507ffe000000000000000000000000000000000000000000000000000000000000008114613bea5715613ba85750505050565b6124069495506121599160349185604051968793838501378201906bffffffffffffffffffffffff19601319360135169082015203601481018552018361258e565b506124069495506126a99160349185604051968793838501378201906bffffffffffffffffffffffff19601319360135169082015203601481018552018361258e565b602490604051907f48c9ceda0000000000000000000000000000000000000000000000000000000082526004820152fd5b906001600160a01b038091169182600114159283613c7c5750505090565b90919250600052602052604060002054161515388080613a4d565b906001600160a01b038091169182600114159283613cb55750505090565b9091925060005260026020528160406000209116600052602052604060002054161515388080613a4d565b6001600160a01b039093929193169060405193635229073f60e01b85528480613d1060009485946004840161377f565b038183865af18015613d505781948291613d30575b5093156138be575050565b9050613d479194503d8086833e610b8b818361258e565b93909338613d25565b50604051903d90823e3d90fd5b81601f820112156105fd57805191602091613d77846130c6565b93613d85604051958661258e565b808552838086019160051b830101928084116105fd57848301915b848310613db05750505050505090565b825167ffffffffffffffff81116105fd578691613dd284848094890101612c79565b815201920191613da0565b9091613e0e939260405192838092635229073f60e01b82526001600160a01b03826000998a9788946004840161377f565b0393165af1908115612d9c57838092612d7a5750509115612d695756fea2646970667358221220050e7aa8c5e5f3123211d15a3d12435c074d1cf032931ff300d7f1e833b6eada64736f6c6343000817003360808060405234610016576108a6908161001c8239f35b600080fdfe60406080604052600436101561001457600080fd5b6000803560e01c9182633f707e6b1461008d575050806350c890221461008857806361085573146100835780636a2216571461007e57806378272525146100795780639517e29f1461007457639abb6e171461006f57600080fd5b610624565b6104e9565b6103fc565b61031b565b610235565b61013d565b346100e75761009b366100eb565b839291925b8181106100ab578480f35b806100e060206100be60019486896106e6565b80356100c9816102b9565b6100d58883018361070d565b93909201359061080d565b50016100a0565b5080fd5b9060206003198301126101385760043567ffffffffffffffff9283821161013857806023830112156101385781600401359384116101385760248460051b83010111610138576024019190565b600080fd5b346101385761014b366100eb565b60009182915b808410610165576020836040519015158152f35b909150600161019d602061017a8685876106e6565b8035610185816102b9565b610192604083018361070d565b939092013590610846565b509301929190610151565b9080825180825260208092019180808360051b8601019501936000936000915b8483106101d9575050505050505090565b9091929394959684601f198084840301855289518051908185528a5b82811061022157505080840183018a9052601f01169091018101978101969594936001019201906101c8565b8181018501518682018601528994016101f5565b3461013857610243366100eb565b9061024d82610758565b9160005b818110610272576040516020808252819061026e908201876101a8565b0390f35b8061029d602061028560019486886106e6565b8035610290816102b9565b6100d5604083018361070d565b6102a782876107a2565b526102b281866107a2565b5001610251565b6001600160a01b0381160361013857565b634e487b7160e01b600052604160045260246000fd5b67ffffffffffffffff81116102f457604052565b6102ca565b90601f8019910116810190811067ffffffffffffffff8211176102f457604052565b3461013857604036600319011261013857600435610338816102b9565b6024359067ffffffffffffffff80831161013857366023840112156101385782600401359081116102f4576040519261037b601f8301601f1916602001856102f9565b8184523660248383010111610138578160009260246020930183870137840101526107b6565b90606060031983011261013857600435916024356103be816102b9565b9160443567ffffffffffffffff9283821161013857806023830112156101385781600401359384116101385760248483010111610138576024019190565b346101385761040a366103a1565b6001600160a01b038392931690813b156101385761045d93604051928380927f8a91b0e30000000000000000000000000000000000000000000000000000000082528160009889968793600484016107d9565b03925af180156104e4576104b3575b50604080519384526001600160a01b03909116602084015290917f341347516a9de374859dfda710fa4828b2d48cb57d4fbe4c1149612b8e02276e91819081015b0390a180f35b916104de7f341347516a9de374859dfda710fa4828b2d48cb57d4fbe4c1149612b8e02276e936102e0565b9161046c565b610801565b34610138576104f7366103a1565b6001600160a01b038392931690813b156101385761054a93604051928380927f6d61fe700000000000000000000000000000000000000000000000000000000082528160009889968793600484016107d9565b03925af180156104e45761059e575b50604080519384526001600160a01b03909116602084015290917fd21d0b289f126c4b473ea641963e766833c2f13866e4ff480abd787c100ef12391819081016104ad565b916105c97fd21d0b289f126c4b473ea641963e766833c2f13866e4ff480abd787c100ef123936102e0565b91610559565b9092916040820191604081528451809352606081019260208096019060005b81811061060e5750505061060b93945060208184039101526101a8565b90565b82511515865294870194918701916001016105ee565b3461013857610632366100eb565b61063b81610758565b9161064582610740565b91604061065560405194856102f9565b81845261066182610740565b60209290601f1901368685013760005b818110610687576040518061026e8989836105cf565b806106b085610699600194868a6106e6565b80356106a4816102b9565b6101928883018361070d565b6106ba838b6107a2565b526106c582896107a2565b901515905201610671565b634e487b7160e01b600052603260045260246000fd5b91908110156107085760051b81013590605e1981360301821215610138570190565b6106d0565b903590601e1981360301821215610138570180359067ffffffffffffffff82116101385760200191813603831361013857565b67ffffffffffffffff81116102f45760051b60200190565b9061076282610740565b61076f60405191826102f9565b8281528092610780601f1991610740565b019060005b82811061079157505050565b806060602080938501015201610785565b80518210156107085760209160051b010190565b906000809160405193602082519201905afa3d6000833e6107d5573d90fd5b3d90f35b90918060409360208452816020850152848401376000828201840152601f01601f1916010190565b6040513d6000823e3d90fd5b9092600092819594604051968792833738935af11561083c573d82523d6000602084013e60203d830101604052565b503d6000823e3d90fd5b906000928491604051958692833738935af115913d82523d6000602084013e60203d83010160405256fea2646970667358221220db816abffe00ec7bcdf42ef422b077938fa7d65d91086b933027768eba11f62b64736f6c63430008170033",
  "deployedBytecode": "0x6080604090808252600490813610156100a6575b505036156100a45760008035908160e01c9263bc197c81841463f23a6e6185141763150b7a0285141761009a57906100929133825260056020526001600160a01b03918282822054169460066020526001600160e01b031983832091168252602052205416610082818461317c565b9161008c36613b29565b94613243565b602081519101f35b836020526020603cf35b005b600091823560e01c9182630a664dba1461220a57508163112d3a7d146121eb5781631626ba7e1461219a57816319822f7c14611c5c578163540fb4f9146119825781636a5e15151461191b57816385571368146117ba5781639517e29f146114f65781639cfd7cff146113b6578163a71763a814610f32578163b0d691fe14610f07578163b875d5d814610eb9578163d03c791414610e99578163d691c9641461091a578163d828435d14610835578163e9ae5c5314610425578163ea5f61d014610296578163eab77e17146101e5578163f2dc691d146101b9575063f698da25146101925780610013565b90346101b557816003193601126101b5576020906101ae612b1e565b9051908152f35b5080fd5b8383346101e25760203660031901126101e257506101d960209235612ae3565b90519015158152f35b80fd5b8284346101b55760603660031901126101b55782356001600160a01b03811681036102925760243567ffffffffffffffff811161028e5761022990369086016122d6565b916044359360ff8516850361028a5760131936013560601c6f71727de22e5e9d8baf0edac6f37da0328114908115610280575b5015610271575061026e949550612e59565b80f35b869051635629665f60e11b8152fd5b905033148861025c565b8580fd5b8380fd5b8280fd5b8383346101e257816003193601126101e2576102b0612237565b91602435913381526020906003602052828120906001600160a01b03918287169360019760018614159081610413575b506103fd5786156103ee579087916102f7886130de565b9784966000528260205285886000205416995b610388575b50505050600182871614158061037f575b61033c575b5050906103389183525192839283612307565b0390f35b9194509060001985019085821161036c57508394955061035f906103389461311d565b5116929150838580610325565b80601188634e487b7160e01b6024945252fd5b50821515610320565b909192959885811690811515806103e4575b806103db575b156103d35750806103b18b8b61311d565b52600052828252856103c9868960002054169a613131565b969392919061030a565b99965061030f565b50828b106103a0565b508782141561039a565b88865163f725081760e01b8152fd5b60248986885191637c84ecfb60e01b8352820152fd5b61041e915083613c5e565b158a6102e0565b9050610430366123be565b9290338552602095600587526001600160a01b039687828820541692600682528288207fe9ae5c53000000000000000000000000000000000000000000000000000000008952825288838920541694610489868661317c565b989097601319908136013560601c6f71727de22e5e9d8baf0edac6f37da032811490811561082b575b501561081c576001600160f81b031990818160081b16801560001461066d5750811690600160f81b820361054d5750505050509161054261026e98999261053485610548963501948c5416935194827f3f707e6b0000000000000000000000000000000000000000000000000000000087948501528135910160248401613a7b565b03601f19810184528361258e565b336137ad565b613243565b9080929395949d50156000146106145750505061057e8a610572610596948694613a53565b96929491963691612aac565b8751958694859463468721a760e01b86528501612cc8565b03816000335af1918215610609576000926105ce575b5050156105bf575061026e949550613243565b869051632b3f6d1160e21b8152fd5b90809250813d8311610602575b6105e5818361258e565b810103126105fd576105f690612c6c565b38806105ac565b600080fd5b503d6105db565b83513d6000823e3d90fd5b90809395509b9395919a9b146000146106585750505081601411610654576106496105489261026e9836910160148401612aac565b903560601c336137ad565b8780fd5b602493505191632e5bf3f960e21b8352820152fd5b9190600160f81b9e98979695949d9e92838114600014610806575081169182036106eb575050505061026e9850610548939291610534826106e5933501948c5416935194827f50c890220000000000000000000000000000000000000000000000000000000087948501528135910160248401613a7b565b3361386f565b90809293959750156000146107cc57505050839161070f6107339a61071b93613a53565b9c9294919c3691612aac565b85519b8c94859463468721a760e01b86528501612cc8565b03818b335af180156107c257889061078c575b61026e975015610758575b5050613243565b7fb8bc84bd77f5eb08210b8eb20fd63b3ec6a7992d277ab94663bae0e066f792ac9188825191338352820152a13880610751565b508187813d83116107bb575b6107a2818361258e565b81010312610654576107b661026e97612c6c565b610746565b503d610798565b81513d8a823e3d90fd5b919a955091939082036106585750505081601411610654576107fb6105489261026e9836910160148401612aac565b903560601c3361386f565b856024918a51916308c3ee0360e11b8352820152fd5b838751635629665f60e11b8152fd5b90503314386104b2565b8284346101b557806003193601126101b55761084f612237565b6001600160a01b039360243585811681036105fd5777ffffffffffffffffffffffffffffffffffffffff00000000916020968551947f35567e1a0000000000000000000000000000000000000000000000000000000086521690840152851b16602482015283816044816f71727de22e5e9d8baf0edac6f37da0325afa92831561090f57926108e0575b5051908152f35b9091508281813d8311610908575b6108f8818361258e565b810103126105fd575190836108d9565b503d6108ee565b8251903d90823e3d90fd5b9050610925366123be565b909391601319918236013560601c953385526020966003885261094a818a8820613c5e565b15610e6a5750338552600587526001600160a01b039081898720541696600689528987207fd691c9640000000000000000000000000000000000000000000000000000000088528952828a88205416936109a4858a61317c565b9790966109b0336139b2565b6001600160f81b031990818160081b168015600014610c0e5750811690600160f81b8203610ac9575050505050610a2e91610a288261053493350191885416918b519384917f61085573000000000000000000000000000000000000000000000000000000008d8401528c8135910160248401613a7b565b33613ddd565b80518101878282031261028a57878201519067ffffffffffffffff8211610ac5579188610a669281610a6c9897969501920101613d5d565b95613243565b83519280840190808552835180925280868601968360051b870101940192955b828710610a995785850386f35b909192938280610ab5600193603f198a82030186528851612384565b9601920196019592919092610a8c565b8680fd5b9080929395949d9c9b965015600014610ba5575050506000610b25610af78c999897969594610b0d94613a53565b9b9293919590610b05613a1e565b9c3691612aac565b8d519586948594635229073f60e01b86528501612cc8565b038183335af1908115610b9a57600090600092610b74575b5015610b65578697989950610b55610a6c9697613110565b52610b5f87613110565b50613243565b898951632b3f6d1160e21b8152fd5b9050610b9391503d806000833e610b8b818361258e565b810190612c93565b9038610b3d565b89513d6000823e3d90fd5b819c929a9b9c94939414600014610bf857505080601411610ac557610a6c9594939291610be4610bef92610bd7613a1e565b9a36910160148401612aac565b903560601c33613ddd565b610b5588613110565b602492508b5191632e5bf3f960e21b8352820152fd5b959d9c9b9a9998979695600160f81b929190838103610e5357508116918203610d3c57505050505061053490610c888a610c8e9495969798999a9b350191885416918b519384917f9abb6e17000000000000000000000000000000000000000000000000000000008d8401528c8135910160248401613a7b565b33613ce0565b8051810190888189840193031261028a57878101519067ffffffffffffffff9182811161065457810183603f8201121561065457898101518b8b610cd1836130c6565b610cdd8351918261258e565b838152019160051b83010191858311610d38578c8c9101915b838310610d20575050505089810151918211610ac5579188610a6692610a6c979695940101613d5d565b8190610d2b84612c6c565b8152019101908b90610cf6565b8980fd5b90809293949a955015600014610e1357505050610d8e610d608792610d769c613a53565b9a9293919d90610d6e613a1e565b9b3691612aac565b8c519d8e948594635229073f60e01b86528501612cc8565b038183335af18015610e09578596979899610a6c96908892610dec575b5015610dba57610b5588613110565b7fb8bc84bd77f5eb08210b8eb20fd63b3ec6a7992d277ab94663bae0e066f792ac8a8051338152898c820152a1610bef565b9050610e0291503d8089833e610b8b818361258e565b9038610dab565b88513d87823e3d90fd5b819c949596979899929a9b9c14600014610bf857505080601411610ac557610a6c9594939291610e48610bef92610bd7613a1e565b903560601c33613ce0565b868f9160249251916308c3ee0360e11b8352820152fd5b866024918a51917fb927fe5e000000000000000000000000000000000000000000000000000000008352820152fd5b8383346101e25760203660031901126101e257506101d960209235612a21565b839150346102925760203660031901126102925735916001600160e01b031983168093036105fd57816001600160a01b03916020943382526006865282822090825285522054169051908152f35b8284346101b557816003193601126101b557602090516f71727de22e5e9d8baf0edac6f37da0328152f35b9050610f3d3661228f565b92909391338652602090600582526001600160a01b039283898920541693600684528989207fa71763a8000000000000000000000000000000000000000000000000000000008a528452808a8a20541695610f98878761317c565b99909860131936013560601c6f71727de22e5e9d8baf0edac6f37da03281149081156113ac575b501561139d57839291906001860361111a5790610fde91810190613831565b92169083861680158015611110575b6110fa5780858f611011866001600160a01b03166000526002602052604060002090565b336000528b526000205416036110e45750508a8561026e9c9d956106e59561054899956105349561105d637827252560e01b9b6001600160a01b03166000526002602052604060002090565b336000528852611087838b6000205416916001600160a01b03166000526002602052604060002090565b336000528852896000206001600160a01b031991828254161790556110bf856001600160a01b03166000526002602052604060002090565b33600052885289600020908154169055935b54169651978895860152602485016129c5565b602492508d5191637c84ecfb60e01b8352820152fd5b506024918d5191637c84ecfb60e01b8352820152fd5b5060018114610fed565b9250600285036111f9579061113e8493928e8e33815260038b522093810190613831565b93169184871691821580156111ef575b6111d857828f879086600052848c526000205416036111c15750958c9d956106e595610548999561026e9f949586637827252560e01b9b610534986000528952838b6000205416916000528a6000206001600160a01b0319928382541617905560005289600020908154169055936110d1565b90506024918e5191637c84ecfb60e01b8352820152fd5b60249150838f5191637c84ecfb60e01b8352820152fd5b506001831461114e565b9492909a9b93959160038714600014611289578c9086019385878603126101b557611223876123a9565b97848801359367ffffffffffffffff851161028e5761026e9e6105489a61125a6106e59961053498637827252560e01b9d01613465565b9133875288526001600160e01b03198a87209116865287528885206001600160a01b03198154169055936110d1565b8b87959d9c9397969294961460001461138757906112a991810190613480565b929091600281101561137457801580611362575b1561130057505050936105348a637827252560e01b9561026e9c9d956106e59561054899338552600587528885206001600160a01b031981541690555b936110d1565b60010361135457508a637827252560e01b9561026e9c9d956106e595610548999561053495338652600688526001600160e01b03198a87209116865287528885206001600160a01b031981541690556112fa565b8c51635691922f60e01b8152fd5b506001600160e01b03198316156112bd565b60248d602184634e487b7160e01b835252fd5b602483868f519163041c38b360e41b8352820152fd5b828d51635629665f60e11b8152fd5b9050331438610fbf565b8284346101b557816003193601126101b55781815180947fffa1ad7400000000000000000000000000000000000000000000000000000000825281335afa9182156114eb578092611492575b61033883836114806034825180947f736166652d000000000000000000000000000000000000000000000000000000602083015261144a815180926020602586019101612361565b81017f2e657263373537392e76302e302e310000000000000000000000000000000000602582015203601481018552018361258e565b51918291602083526020830190612384565b9091503d8082853e6114a4818561258e565b8301926020818503126101b55780519067ffffffffffffffff821161029257019083601f830112156101e25750610338928160206114e4935191016129ea565b9083611402565b9051903d90823e3d90fd5b82846115013661228f565b95929391909333865260056020526001600160a01b0392838188205416926006602052818820907f9517e29f0000000000000000000000000000000000000000000000000000000091828a5260205285838a20541695611561878761317c565b99909860131936013560601c6f71727de22e5e9d8baf0edac6f37da03281149081156117b0575b50156117a257600187036115e157508a83610548979695936115ca61026e9e9f94610534956115b961054299613935565b6115c38533612ffc565b3691612aac565b925b541695519687946020860152602485016129c5565b6002870361160e57508a836105489796959361160861026e9e9f61053495610542986136c5565b926115cc565b6003870361163557508a836105489796959361160861026e9e9f61053495610542986134c2565b86810361165b57508a836105489796959361160861026e9e9f61053495610542986132e6565b909b508561178c578b358c019b8c91602082013582019060208201913592888101350193358303611765579d91908d9e8f5b8435116116be57505050508a61026e9b9c506105429361054897969593611608610534943690602081359101612aac565b839f8082602060019360051b880101358381146000146117065750506116fb6116e88287876132cf565b6116f18c613935565b6115c38c33612ffc565b505b019f508f61168d565b6002810361172c57505061172561171e8287876132cf565b908b6136c5565b505b6116fd565b6003810361174b5750506117256117448287876132cf565b908b6134c2565b036117275761172561175e8287876132cf565b908b6132e6565b87517fb4fa3fb3000000000000000000000000000000000000000000000000000000008152fd5b6024908686519163041c38b360e41b8352820152fd5b8551635629665f60e11b8152fd5b905033148e611588565b8284346101b557806003193601126101b5576117d4612237565b90602435916001600160a01b038082169460019560018114158061190a575b6118f4575084156118e55785611808866130de565b9561182783956001600160a01b03166000526002602052604060002090565b903360005260209160205284876000205416985b611866575b505050600182871614158061037f5761033c575050906103389183525192839283612307565b90919497848116801515806118db575b806118d2575b156118ca57906118aa916118908b8b61311d565b526001600160a01b03166000526002602052604060002090565b336000528252846118c18588600020541699613131565b9592919061183b565b509794611840565b50828a1061187c565b5086811415611876565b86845163f725081760e01b8152fd5b87602491865191637c84ecfb60e01b8352820152fd5b506119158433613c97565b156117f3565b905060203660031901126101b55780359067ffffffffffffffff821161029257611947913691016122d6565b61195033612f80565b825b81811061195d578380f35b8061197c6119766119716001948688612979565b6129b1565b33612ffc565b01611952565b83915060031960a03682011261028e5767ffffffffffffffff91803583811161028a576119b290369083016122d6565b929094602435858111610654576119cc90369085016122d6565b604435878111610d38576119e390369087016122d6565b939094606435898111611c58576119fd90369089016122d6565b979099608435818111611c5457606081360394850112611c545780830135916001600160a01b03948584168403611c505760248301359060221901811215611c5057820184810135918211611c5057602401918160051b36038313611c5057604401359160ff83168303611c5057611a7493612e59565b60019a8b60005260209960028b5284600020336000528b528385600020541615600014611c19578c8e611aa633612f80565b828110611bdd57505050505b338c5260038952828c20918b600052828a52836000205416611bcf5750896000528752600020886001600160a01b031982541617905587895b828110611b9c575050505085875b828110611b695750505050845b818110611b365785337ff48581d8a62b775b74f2fb67f1d5806a9a356fbcc598040ab3071d3e37af40c28280a280f35b80611b62611b4687938588612979565b611b5c611b52826129b1565b9187810190612f4d565b916132e6565b5001611b06565b611b93611b77828587612979565b611b8d611b83826129b1565b9189810190612f4d565b916134c2565b50018690611af9565b611bc6611baa828587612979565b611bc0611bb6826129b1565b918b810190612f4d565b916136c5565b50018890611aeb565b82516329e42f3360e11b8152fd5b611c108d6115c3611c04611bf285888a612979565b611bfb816129b1565b93810190612f4d565b91909261197681613935565b50018d90611aa6565b905015611ab2576024908351907fd8e3ed1b0000000000000000000000000000000000000000000000000000000082523390820152fd5b8f80fd5b8d80fd5b8b80fd5b828460031960603682011261029257833567ffffffffffffffff9182821161217657610120828701918336030112612176576f71727de22e5e9d8baf0edac6f37da032917fffffffffffffffffffffffffffffffff8e8d821dd1a1627450f125390c825fce36601319013560601c0161218b5760248101358060601c8015801561217a575b156120435750611cf5610104830184612f4d565b919092826006116120295782600c1161202957600684013594611d1e6115c36044840183612f4d565b6020815191012091611d366115c36064830184612f4d565b602081519101209060848101356fffffffffffffffffffffffffffffffff92611d6b6115c360c48501359660e4860190612f4d565b60208151910120958d51978d6101c08a01908a82109082111761202d57928f926101c0999795928460a496611e5b9e9d9b9996527f84aa190356f56b8c87825f54884392a9907c23ee0f8e1ea86336b763faf021bd8b523360208c01528a01526060890152608088015283811660a088015260801c60c0870152013560e0850152811661010084015260801c610120830152610140820152843560d01c6101608201528560d01c610180820152866101a082015220611e69611e2b612b1e565b9189519485916020830194859091604292601960f81b8352600160f81b6001840152600283015260228201520190565b03601f19810185528461258e565b82519020333b1561202957918891611e9e8b948a51958694859463934f3a1160e01b8652600b190192600c8a019286016125f3565b0381335afa9081612016575b50611fdd579065ffffffffffff60a01b7fffffffffffff000000000000000000000000000000000000000000000000000060019335169160301c1617175b935b604435611efc575b6020858551908152f35b8351926020840190811184821017611fc85791611f499391602093865282528451938492839263468721a760e01b8452898401526044356024840152608060448401526084830190612384565b6000606483015203816000335af1908115611fbd57600091611f83575b5015611f7457828080611ef2565b905051632b3f6d1160e21b8152fd5b90506020813d602011611fb5575b81611f9e6020938361258e565b810103126105fd57611faf90612c6c565b84611f66565b3d9150611f91565b82513d6000823e3d90fd5b604187634e487b7160e01b6000525260246000fd5b7fffffffffffff000000000000000000000000000000000000000000000000000065ffffffffffff60a01b9135169160301c1617611ee8565b61202290979197612548565b9588611eaa565b8880fd5b50508f8f6041602492634e487b7160e01b835252fd5b906121599061214361215f959489519586937f970032030000000000000000000000000000000000000000000000000000000060208601528b60248601526001600160a01b036120928361224d565b16606486015260848501526121336120c36120b0604485018461292b565b61012060a48901526101848801916125d2565b916120e86120d4606486018361292b565b606319898703810160c48b015295916125d2565b608485013560e488015261212b6101049160a4870135838a015260c48701356101248a015261211a60e488018561292b565b90878b8403016101448c01526125d2565b94019061292b565b91858403016101648601526125d2565b602435604483015203601f19810184528361258e565b33612cfa565b602081805181010312612176576020015193611eea565b8480fd5b506121858133613c97565b15611ce1565b868551635629665f60e11b8152fd5b8383346101e257816003193601126101e2576024359067ffffffffffffffff82116101e257506121e36020936121dc6001600160e01b03199336908301612261565b913561261f565b915191168152f35b8284346101b5576020906101d96122013661228f565b929190916123ee565b839085346102925782600319360112610292576001600160a01b0390602093338152600585522054168152f35b600435906001600160a01b03821682036105fd57565b35906001600160a01b03821682036105fd57565b9181601f840112156105fd5782359167ffffffffffffffff83116105fd57602083818601950101116105fd57565b60606003198201126105fd57600435916024356001600160a01b03811681036105fd57916044359067ffffffffffffffff82116105fd576122d291600401612261565b9091565b9181601f840112156105fd5782359167ffffffffffffffff83116105fd576020808501948460051b0101116105fd57565b909291926040820190604083528051809252606083019160208092019160005b82811061234457505050506001600160a01b036020919416910152565b83516001600160a01b031685529381019392810192600101612327565b60005b8381106123745750506000910152565b8181015183820152602001612364565b9060209161239d81518092818552858086019101612361565b601f01601f1916010190565b35906001600160e01b0319821682036105fd57565b9060406003198301126105fd57600435916024359067ffffffffffffffff82116105fd576122d291600401612261565b90929060018103612409575050506124069033613c97565b90565b6002810361242b57505050612406903360005260036020526040600020613c5e565b6003810361247e575081602091810103126105fd57612449906123a9565b3360005260046020526001600160e01b0319604060002091166000526020526001600160a01b03806040600020541691161490565b9192916004036125405782604091810103126105fd5781359160028310156105fd5760206124ac91016123a9565b60009280158061252e575b61250e575b6001146124d6575b506001600160a01b0380911691161490565b9091503360005260066020526001600160e01b0319604060002091166000526020526001600160a01b036040600020541690386124c4565b336000908152600560205260409020546001600160a01b031693506124bc565b506001600160e01b03198216156124b7565b505050600090565b67ffffffffffffffff811161255c57604052565b634e487b7160e01b600052604160045260246000fd5b6040810190811067ffffffffffffffff82111761255c57604052565b90601f8019910116810190811067ffffffffffffffff82111761255c57604052565b90602091808252806000848401376000828201840152601f01601f1916010190565b908060209392818452848401376000828201840152601f01601f1916010190565b92906124069492612611918552606060208601526060850190612384565b9260408185039101526125d2565b918015806128a0575b61289257806014116105fd57813560601c9081158015612881575b6126d4576126af936105346126a9926013199560146040519788957ff551e2ee0000000000000000000000000000000000000000000000000000000060208801528136013560601c602488015260448701526060606487015260848601930191016125d2565b33612b99565b6020818051810103126105fd57602001516001600160e01b0319811681036105fd5790565b905060409182517ff698da250000000000000000000000000000000000000000000000000000000081526020948582600481335afa91821561287657600092612845575b506127d890855187810191825287815261273181612572565b51902085519087820190815287825261274982612572565b61279687805180936127878c8301967f60b3cbf8b4a223d68d641b3b6ddf9a298e7f33710cf3d3a9d1146b5a6150fbca885251809285850190612361565b8101038a81018452018261258e565b519020956127ca8651978892830194859091604292601960f81b8352600160f81b6001840152600283015260228201520190565b03601f19810187528661258e565b8451902091333b156105fd5761280e6014926000948651978895869563934f3a1160e01b875260131901930191600486016125f3565b0381335afa90811561283b575061282c575b50630b135d3f60e11b90565b61283590612548565b38612820565b513d6000823e3d90fd5b9091508581813d831161286f575b61285d818361258e565b810103126105fd5751906127d8612718565b503d612853565b85513d6000823e3d90fd5b5061288c8233613c97565b15612643565b505050630b135d3f60e11b90565b506040517f5ae6bd37000000000000000000000000000000000000000000000000000000008152836004820152602081602481335afa90811561291f576000916128ed575b501515612628565b90506020813d602011612917575b816129086020938361258e565b810103126105fd5751386128e5565b3d91506128fb565b6040513d6000823e3d90fd5b9035601e19823603018112156105fd57016020813591019167ffffffffffffffff82116105fd5781360383136105fd57565b67ffffffffffffffff811161255c57601f01601f191660200190565b919081101561299b5760051b81013590603e19813603018212156105fd570190565b634e487b7160e01b600052603260045260246000fd5b356001600160a01b03811681036105fd5790565b6001600160a01b03612406949360609383521660208201528160408201520190612384565b909291926129f78161295d565b91612a05604051938461258e565b8294828452828201116105fd576020612a1f930190612361565b565b8060081b6001600160f81b031980921682600160f81b91828114600014612a8c57505060019283925b8380612a82575b15612a5d575050505090565b83612a76575b505050600014612a705790565b50600090565b16149050388080612a63565b5081811615612a51565b80612a9d5750506001928392612a4a565b03612540576001928392612a4a565b929192612ab88261295d565b91612ac6604051938461258e565b8294818452818301116105fd578281602093846000960137010152565b60018103612af15750600190565b60028103612aff5750600190565b60038103612b0d5750600190565b600403612b1957600190565b600090565b60405160208101907f47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a794692188252466040820152306060820152606081526080810181811067ffffffffffffffff82111761255c5760405251902090565b6040906001600160a01b0361240694931681528160208201520190612384565b600090602092949394612bd96040519687927f6a221657000000000000000000000000000000000000000000000000000000008785015260248401612b79565b0394612bed601f199687810183528261258e565b612c35612c416001600160a01b0385541692604051928391888301957fb4faba0900000000000000000000000000000000000000000000000000000000875260248401612b79565b0388810183528261258e565b51915afa503d91604051928181850101604052016020833e60005115612c6357565b50602081519101fd5b519081151582036105fd57565b9080601f830112156105fd578151612406926020016129ea565b9190916040818403126105fd57612ca981612c6c565b92602082015167ffffffffffffffff81116105fd576124069201612c79565b9392612cf5906000936001600160a01b036060941687526020870152608060408701526080860190612384565b930152565b90612d45909392936001600160a01b0392839160405196879586948593635229073f60e01b855216600484015260009889968793846024840152608060448401526084830190612384565b8360648301520393165af1908115612d9c57838092612d7a575b50509115612d6957565b6004604051632b3f6d1160e21b8152fd5b909150612d929293503d8091833e610b8b818361258e565b9190913880612d5f565b6040513d85823e3d90fd5b612dee926020916001600160a01b03938492604051958694859363468721a760e01b8552166004840152826000988993846024840152608060448401526084830190612384565b8360648301520393165af1918215612e4d578092612e10575b505015612d6957565b9091506020823d602011612e45575b81612e2c6020938361258e565b810103126101e25750612e3e90612c6c565b3880612e07565b3d9150612e1f565b604051903d90823e3d90fd5b92919233600052600160209460016020526040600020956001600160a01b0380941696876001600160a01b031982541617905581604051967ff05c04e100000000000000000000000000000000000000000000000000000000602089015260ff606489019116602489015260406044890152526084860194936000905b838210612f295750505050505090612efa81612f019303601f19810183528261258e565b8233612da7565b337f9452c8fb077c3ea8f28a77c87488af657b1e44d010ad9a5992d73870da040e94600080a3565b909192938380879884612f3c859a61224d565b168152019701959493920190612ed6565b903590601e19813603018212156105fd570180359067ffffffffffffffff82116105fd576020019181360383136105fd57565b6001600160a01b0390811660008181527fe90b7bceb6e7df5418fb78d8ee546e97c83a08bbccc01a0644d599ccd2a7c2e060205260408120549192909116612feb576040916001825260026020528282209082526020522060016001600160a01b0319825416179055565b60046040516329e42f3360e11b8152fd5b906001600160a01b0380911690811580156130bc575b6130a45760008281526020936002855260409280848420921691828452865280848420541661308d57600183526002865283832082845286528383205416948483526002815283832082845281528383206001600160a01b031996878254161790556001835260028152838320918352522091825416179055565b602485855190631034f46960e21b82526004820152fd5b60248260405190637c84ecfb60e01b82526004820152fd5b5060018214613012565b67ffffffffffffffff811161255c5760051b60200190565b906130e8826130c6565b6130f5604051918261258e565b8281528092613106601f19916130c6565b0190602036910137565b80511561299b5760200190565b805182101561299b5760209160051b010190565b60001981146131405760010190565b634e487b7160e01b600052601160045260246000fd5b906020828203126105fd57815167ffffffffffffffff81116105fd576124069201612c79565b90916060926060926001600160a01b03908181166131f5575b50811661319f5750565b6124069192506131e6906040519063d68f602560e01b602083015260131936013560601c6024830152346044830152606060648301526121598261053460848201366125b0565b60208082518301019101613156565b61323c9195506131e6906040519063d68f602560e01b602083015260131936013560601c6024830152346044830152606060648301526121598261053460848201366125b0565b9338613195565b929190926001600160a01b0391828216613299575b50508216613264575050565b612a1f9161329361053492604051938491630b9dfbed60e11b6020840152602060248401526044830190612384565b33612da7565b6132c89161329361053492604051938491630b9dfbed60e11b6020840152602060248401526044830190612384565b3880613258565b9082101561299b576122d29160051b810190612f4d565b9060009233845260016020526001600160a01b039160409183838720541680613400575b509061331891810190613480565b959160028110156133ec578015806133da575b15613393575050338152600560205282828220541680613363575033815260056020522091166001600160a01b031982541617905590565b6024908351907f741cbe030000000000000000000000000000000000000000000000000000000082526004820152fd5b6001036133ca5733825260066020526001600160e01b0319838320911682526020522091166001600160a01b031982541617905590565b60048351635691922f60e01b8152fd5b506001600160e01b031982161561332b565b602483634e487b7160e01b81526021600452fd5b803b15610ac5578660649185519283809263529562a160e01b8252336004830152898b166024830152600460448301525afa801561345b579061331893929161344c575b50909161330a565b61345590612548565b38613444565b84513d89823e3d90fd5b9080601f830112156105fd5781602061240693359101612aac565b916060838303126105fd57823560028110156105fd57926134a3602082016123a9565b92604082013567ffffffffffffffff81116105fd576124069201613465565b90600091338352602093600185526001600160a01b03936040918583832054168061366f575b508401956060858803126101b5576134ff856123a9565b9681860135956001600160f81b03198716870361028e57848101359067ffffffffffffffff8211612176579161353f916001600160e01b03199301613465565b9716907f6d61fe700000000000000000000000000000000000000000000000000000000082148015613646575b613616573383526004815283832082845281528684842054166135e657917fffffffffffffffffffffff000000000000000000000000000000000000000000939174ff00000000000000000000000000000000000000009333835260048152838320918352522094855493169360581c1691161717905590565b6024828551907f74420d150000000000000000000000000000000000000000000000000000000082526004820152fd5b6024828551907f79bd117b0000000000000000000000000000000000000000000000000000000082526004820152fd5b507f8a91b0e300000000000000000000000000000000000000000000000000000000821461356c565b803b15610292578260649185519283809263529562a160e01b82523360048301528b8a166024830152600360448301525afa80156136bb57156134e8576136b590612548565b386134e8565b84513d85823e3d90fd5b92916136d0846139b2565b60003381526003602052604094858220956001600160a01b038092169182158015613775575b61375e5782845287602052808285205416613747576124069697600185526020528184205416928281528181206001600160a01b031994858254161790556001815220918254161790553691612aac565b602483835190631034f46960e21b82526004820152fd5b602483835190637c84ecfb60e01b82526004820152fd5b50600183146136f6565b9291612cf56060916001600160a01b0360019416865260006020870152608060408701526080860190612384565b916137db9260209260006001600160a01b0360405180978196829563468721a760e01b84526004840161377f565b0393165af190811561291f576000916137f7575b5015612d6957565b90506020813d602011613829575b816138126020938361258e565b810103126105fd5761382390612c6c565b386137ef565b3d9150613805565b9190916040818403126105fd5780356001600160a01b03811681036105fd5792602082013567ffffffffffffffff81116105fd576124069201613465565b6001600160a01b0390929192169161389960405192839263468721a760e01b84526004840161377f565b03906020816000938185875af190811561392a5782916138f0575b50156138be575050565b7fb8bc84bd77f5eb08210b8eb20fd63b3ec6a7992d277ab94663bae0e066f792ac9160409182519182526020820152a1565b90506020813d602011613922575b8161390b6020938361258e565b810103126101b55761391c90612c6c565b386138b4565b3d91506138fe565b6040513d84823e3d90fd5b600033815260016020526001600160a01b0380604083205416928361395b575b50505050565b833b15610292579060648392604051958693849263529562a160e01b8452336004850152166024830152600160448301525afa908115612e4d57506139a3575b808080613955565b6139ac90612548565b3861399b565b600033815260016020526001600160a01b038060408320541692836139d75750505050565b833b15610292579060648392604051958693849263529562a160e01b8452336004850152166024830152600260448301525afa908115612e4d57506139a357808080613955565b604051613a2a81612572565b600181528060005b602080821015613a4d57906060602092828501015201613a32565b50505090565b90806014116105fd57813560601c92816034116105fd57601483013592603401916033190190565b6020928084830185845252604093604083019260408360051b8201019585600080935b868510613ab15750505050505050505090565b909192939495969798603f198282030189528935605e198536030181121561028e5787613b1860019387839401613b096060916001600160a01b03613af58261224d565b16845285810135868501528b81019061292b565b919092818c82015201916125d2565b9b0199019796950193929190613a9e565b9060609160003381526020906004825260408120916001600160e01b03198235169283835281526040822054926001600160f81b03196001600160a01b0385169460581b16908415613c2d57507ffe000000000000000000000000000000000000000000000000000000000000008114613bea5715613ba85750505050565b6124069495506121599160349185604051968793838501378201906bffffffffffffffffffffffff19601319360135169082015203601481018552018361258e565b506124069495506126a99160349185604051968793838501378201906bffffffffffffffffffffffff19601319360135169082015203601481018552018361258e565b602490604051907f48c9ceda0000000000000000000000000000000000000000000000000000000082526004820152fd5b906001600160a01b038091169182600114159283613c7c5750505090565b90919250600052602052604060002054161515388080613a4d565b906001600160a01b038091169182600114159283613cb55750505090565b9091925060005260026020528160406000209116600052602052604060002054161515388080613a4d565b6001600160a01b039093929193169060405193635229073f60e01b85528480613d1060009485946004840161377f565b038183865af18015613d505781948291613d30575b5093156138be575050565b9050613d479194503d8086833e610b8b818361258e565b93909338613d25565b50604051903d90823e3d90fd5b81601f820112156105fd57805191602091613d77846130c6565b93613d85604051958661258e565b808552838086019160051b830101928084116105fd57848301915b848310613db05750505050505090565b825167ffffffffffffffff81116105fd578691613dd284848094890101612c79565b815201920191613da0565b9091613e0e939260405192838092635229073f60e01b82526001600160a01b03826000998a9788946004840161377f565b0393165af1908115612d9c57838092612d7a5750509115612d695756fea2646970667358221220050e7aa8c5e5f3123211d15a3d12435c074d1cf032931ff300d7f1e833b6eada64736f6c63430008170033",
  "devdoc": {
    "author": "rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)",
    "details": "This contract is a Safe account implementation that supports ERC7579 operations.    In order to facilitate full ERC7579 compliance, the contract implements the IERC7579Account    interface. This contract is an implementation of a Safe account supporting ERC7579 operations and complying with the IERC7579Account interface. It serves as a Safe FallbackHandler and module for Safe accounts, incorporating complex hacks to ensure ERC7579 compliance and requiring interactions and event emissions to be done via the SafeProxy as msg.sender using Safe's \"executeTransactionFromModule\" features.",
    "kind": "dev",
    "methods": {
      "accountId()": {
        "details": "Returns the account id of the smart account",
        "returns": {
          "accountImplementationId": "the account id of the smart account the accountId should be structured like so:        \"vendorname.accountname.semver\""
        }
      },
      "execute(bytes32,bytes)": {
        "details": "Executes a transaction on behalf of the Safe account.         This function is intended to be called by ERC-4337 EntryPoint.solIf a global hook and/or selector hook is set, it will be calledAccessControl: only Self of Entrypoint can install modules Safe7579 supports the following feature set:    CallTypes:             - CALLTYPE_SINGLE             - CALLTYPE_BATCH             - CALLTYPE_DELEGATECALL    ExecTypes:             - EXECTYPE_DEFAULT (revert if not successful)             - EXECTYPE_TRY    If a different mode is selected, this function will revert",
        "params": {
          "executionCalldata": "The encoded execution call data",
          "mode": "The encoded execution mode of the transaction. See ModeLib.sol for details"
        }
      },
      "executeFromExecutor(bytes32,bytes)": {
        "details": "Executes a transaction on behalf of the Safe account.         This function is intended to be called by executor modulesIf a global hook and/or selector hook is set, it will be calledAccessControl: only enabled executor modules Safe7579 supports the following feature set:    CallTypes:             - CALLTYPE_SINGLE             - CALLTYPE_BATCH             - CALLTYPE_DELEGATECALL    ExecTypes:             - EXECTYPE_DEFAULT (revert if not successful)             - EXECTYPE_TRY    If a different mode is selected, this function will revert",
        "params": {
          "executionCalldata": "The encoded execution call data",
          "mode": "The encoded execution mode of the transaction. See ModeLib.sol for details"
        }
      },
      "getNonce(address,address)": {
        "params": {
          "safe": "address of safe account",
          "validator": "ERC7579 validator to encode"
        }
      },
      "initializeAccount((address,bytes)[],(address,bytes)[],(address,bytes)[],(address,bytes)[],(address,address[],uint8))": {
        "params": {
          "executors": "executor modules and initData",
          "fallbacks": "fallback modules and initData",
          "hooks": "hook module and initData",
          "registryInit": "(OPTIONAL) registry, attesters and threshold for IERC7484 Registry                    If not provided, the registry will be set to the zero address, and no                    registry checks will be performed",
          "validators": "validator modules and initData"
        }
      },
      "installModule(uint256,address,bytes)": {
        "details": "The module has to be initialized from msg.sender == SafeProxy, we thus use a    delegatecall to DCUtil, which calls the onInstall/onUninstall function on the ERC7579    module and emits the ModuleInstall/ModuleUnintall eventsAccessControl: only Self of Entrypoint can install modulesIf the safe set a registry, ERC7484 registry will be queried before installingIf a global hook and/or selector hook is set, it will be called",
        "params": {
          "initData": "arbitrary data that may be required on the module during `onInstall` initialization.",
          "module": "the module address",
          "moduleType": "the module type ID according the ERC-7579 spec                   Note: MULTITYPE_MODULE (uint(0)) is a special type to install a module with                         multiple types"
        }
      },
      "isModuleInstalled(uint256,address,bytes)": {
        "params": {
          "additionalContext": "additional context data that the smart account may interpret to                          identifiy conditions under which the module is installed.                          usually this is not necessary, but for some special hooks that                          are stored in mappings, this param might be needed",
          "module": "the module address",
          "moduleType": "the module type ID according the ERC-7579 spec      Note: keep in mind that some contracts can be multiple module types at the same time. It            thus may be necessary to query multiple module types"
        }
      },
      "isValidSignature(bytes32,bytes)": {
        "params": {
          "data": "abi.encodePacked(address validationModule, bytes signatures)",
          "hash": "message hash of ERC1271 request"
        }
      },
      "launchpadValidators((address,bytes)[])": {
        "details": "it will initialize the SentinelList4337 list for validators, and sstore all validatorsSince this function has to be 4337 compliant (storage access), only validator storage is  acccessNote: this function DOES NOT call onInstall() on the validator modules or emit ModuleInstalled events. this has to be done by the launchpad"
      },
      "supportsExecutionMode(bytes32)": {
        "params": {
          "encodedMode": "the encoded mode"
        }
      },
      "supportsModule(uint256)": {
        "params": {
          "moduleTypeId": "the module type ID according the ERC-7579 spec"
        }
      },
      "uninstallModule(uint256,address,bytes)": {
        "details": "The module has to be initialized from msg.sender == SafeProxy, we thus use a    delegatecall to DCUtil, which calls the onInstall/onUninstall function on the ERC7579    module and emits the ModuleInstall/ModuleUnintall eventsAccessControl: only Self of Entrypoint can install modulesIf a global hook and/or selector hook is set, it will be called",
        "params": {
          "deInitData": "arbitrary data that may be required on the module during `onUninstall` de-initialization.",
          "module": "the module address",
          "moduleType": "the module type ID according the ERC-7579 spec"
        }
      },
      "validateUserOp((address,uint256,bytes,bytes,bytes32,uint256,bytes32,bytes,bytes),bytes32,uint256)": {
        "details": "expects that a ERC7579 validator module is encoded within the UserOp nonce.         if no validator module is provided, it will fallback to validate the transaction with         Safe's signers"
      }
    },
    "title": "ERC7579 Adapter for Safe accounts. creates full ERC7579 compliance to Safe accounts",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "domainSeparator()": {
        "notice": "Domain Separator for EIP-712."
      },
      "getNonce(address,address)": {
        "notice": "Safe7579 is using validator selection encoding in the userop nonce. to make it easier for SDKs / devs to integrate, this function can be called to get the next nonce for a specific validator"
      },
      "getValidatorPaginated(address,uint256)": {
        "notice": "Get paginated list of installed validators"
      },
      "initializeAccount((address,bytes)[],(address,bytes)[],(address,bytes)[],(address,bytes)[],(address,address[],uint8))": {
        "notice": "This function can be called by the Launchpad.initSafe7579() or by already existing Safes that want to use Safe7579 if this is called by the Launchpad, it is expected that launchpadValidators() was called previously, and the param validators is empty"
      },
      "installModule(uint256,address,bytes)": {
        "notice": "Installs a 7579 Module of a certain type on the smart account"
      },
      "isModuleInstalled(uint256,address,bytes)": {
        "notice": "Function to check if the account has a certain module installed"
      },
      "isValidSignature(bytes32,bytes)": {
        "notice": "Will use Safe's signed messages or checkSignatures features or ERC7579 validation modules if no signature is provided, it makes use of Safe's signedMessages if address(0) or a non-installed validator module is provided, it will use Safe's checkSignatures if a valid validator module is provided, it will use the module's validateUserOp function"
      },
      "launchpadValidators((address,bytes)[])": {
        "notice": "This function is intended to be called by Launchpad.validateUserOp()"
      },
      "setRegistry(address,address[],uint8)": {
        "notice": "TODO:"
      },
      "supportsExecutionMode(bytes32)": {
        "notice": "Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)"
      },
      "supportsModule(uint256)": {
        "notice": "Function to check if the account supports installation of a certain module type Id"
      },
      "uninstallModule(uint256,address,bytes)": {
        "notice": "Uninstalls a Module of a certain type on the smart account."
      },
      "validateUserOp((address,uint256,bytes,bytes,bytes32,uint256,bytes32,bytes,bytes),bytes32,uint256)": {
        "notice": "ERC4337 v0.7 validation function"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 4815,
        "contract": "contracts/safe7579/Safe7579.sol:Safe7579",
        "label": "UTIL",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 4711,
        "contract": "contracts/safe7579/Safe7579.sol:Safe7579",
        "label": "$registry",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_contract(IERC7484)4956)"
      },
      {
        "astId": 3553,
        "contract": "contracts/safe7579/Safe7579.sol:Safe7579",
        "label": "$validators",
        "offset": 0,
        "slot": "2",
        "type": "t_struct(SentinelList)17461_storage"
      },
      {
        "astId": 3660,
        "contract": "contracts/safe7579/Safe7579.sol:Safe7579",
        "label": "$executorStorage",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_struct(SentinelList)17086_storage)"
      },
      {
        "astId": 3810,
        "contract": "contracts/safe7579/Safe7579.sol:Safe7579",
        "label": "$fallbackStorage",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_address,t_mapping(t_bytes4,t_struct(FallbackHandler)954_storage))"
      },
      {
        "astId": 4098,
        "contract": "contracts/safe7579/Safe7579.sol:Safe7579",
        "label": "$globalHook",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_address,t_address)"
      },
      {
        "astId": 4104,
        "contract": "contracts/safe7579/Safe7579.sol:Safe7579",
        "label": "$hookManager",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_address,t_mapping(t_bytes4,t_address))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bytes4": {
        "encoding": "inplace",
        "label": "bytes4",
        "numberOfBytes": "4"
      },
      "t_contract(IERC7484)4956": {
        "encoding": "inplace",
        "label": "contract IERC7484",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_address)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_address,t_contract(IERC7484)4956)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => contract IERC7484)",
        "numberOfBytes": "32",
        "value": "t_contract(IERC7484)4956"
      },
      "t_mapping(t_address,t_mapping(t_address,t_address))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => address))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_address)"
      },
      "t_mapping(t_address,t_mapping(t_bytes4,t_address))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(bytes4 => address))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes4,t_address)"
      },
      "t_mapping(t_address,t_mapping(t_bytes4,t_struct(FallbackHandler)954_storage))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(bytes4 => struct FallbackHandler))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_bytes4,t_struct(FallbackHandler)954_storage)"
      },
      "t_mapping(t_address,t_struct(SentinelList)17086_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct SentinelListLib.SentinelList)",
        "numberOfBytes": "32",
        "value": "t_struct(SentinelList)17086_storage"
      },
      "t_mapping(t_bytes4,t_address)": {
        "encoding": "mapping",
        "key": "t_bytes4",
        "label": "mapping(bytes4 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_bytes4,t_struct(FallbackHandler)954_storage)": {
        "encoding": "mapping",
        "key": "t_bytes4",
        "label": "mapping(bytes4 => struct FallbackHandler)",
        "numberOfBytes": "32",
        "value": "t_struct(FallbackHandler)954_storage"
      },
      "t_struct(FallbackHandler)954_storage": {
        "encoding": "inplace",
        "label": "struct FallbackHandler",
        "members": [
          {
            "astId": 950,
            "contract": "contracts/safe7579/Safe7579.sol:Safe7579",
            "label": "handler",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 953,
            "contract": "contracts/safe7579/Safe7579.sol:Safe7579",
            "label": "calltype",
            "offset": 20,
            "slot": "0",
            "type": "t_userDefinedValueType(CallType)5459"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(SentinelList)17086_storage": {
        "encoding": "inplace",
        "label": "struct SentinelListLib.SentinelList",
        "members": [
          {
            "astId": 17085,
            "contract": "contracts/safe7579/Safe7579.sol:Safe7579",
            "label": "entries",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_address,t_address)"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(SentinelList)17461_storage": {
        "encoding": "inplace",
        "label": "struct SentinelList4337Lib.SentinelList",
        "members": [
          {
            "astId": 17460,
            "contract": "contracts/safe7579/Safe7579.sol:Safe7579",
            "label": "entries",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_address,t_mapping(t_address,t_address))"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_userDefinedValueType(CallType)5459": {
        "encoding": "inplace",
        "label": "CallType",
        "numberOfBytes": "1"
      }
    }
  }
}