{
  "address": "0xa128f9A221c8A0fC13eC23525511ee1448402eBf",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "smartAccount",
          "type": "address"
        }
      ],
      "name": "AlreadyInitialized",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ExecutionFailed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "smartAccount",
          "type": "address"
        }
      ],
      "name": "NotInitialized",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "session",
          "type": "address"
        }
      ],
      "name": "SessionKeyDoesNotExist",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "sessionKey",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "SessionKeyActive",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "sessionKey",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "SessionKeyAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "sessionKey",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "SessionKeyDisabled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "sessionKey",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "SessionKeyInactive",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_session",
          "type": "address"
        }
      ],
      "name": "disableSessionKey",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sessionKey",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "target",
              "type": "address"
            },
            {
              "internalType": "bytes4",
              "name": "funcSelector",
              "type": "bytes4"
            },
            {
              "internalType": "uint48",
              "name": "validAfter",
              "type": "uint48"
            },
            {
              "internalType": "uint48",
              "name": "validUntil",
              "type": "uint48"
            },
            {
              "internalType": "bool",
              "name": "active",
              "type": "bool"
            }
          ],
          "internalType": "struct SessionValidator.SessionData",
          "name": "sessionData",
          "type": "tuple"
        }
      ],
      "name": "enableSessionKey",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sessionKey",
          "type": "address"
        }
      ],
      "name": "getSessionData",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "target",
              "type": "address"
            },
            {
              "internalType": "bytes4",
              "name": "funcSelector",
              "type": "bytes4"
            },
            {
              "internalType": "uint48",
              "name": "validAfter",
              "type": "uint48"
            },
            {
              "internalType": "uint48",
              "name": "validUntil",
              "type": "uint48"
            },
            {
              "internalType": "bool",
              "name": "active",
              "type": "bool"
            }
          ],
          "internalType": "struct SessionValidator.SessionData",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "smartAccount",
          "type": "address"
        }
      ],
      "name": "isInitialized",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "typeID",
          "type": "uint256"
        }
      ],
      "name": "isModuleType",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_sessionKey",
          "type": "address"
        }
      ],
      "name": "isSessionKeyActive",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "hash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "isValidSignatureWithSender",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "onInstall",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "onUninstall",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "sessionKeyData",
      "outputs": [
        {
          "internalType": "address",
          "name": "target",
          "type": "address"
        },
        {
          "internalType": "bytes4",
          "name": "funcSelector",
          "type": "bytes4"
        },
        {
          "internalType": "uint48",
          "name": "validAfter",
          "type": "uint48"
        },
        {
          "internalType": "uint48",
          "name": "validUntil",
          "type": "uint48"
        },
        {
          "internalType": "bool",
          "name": "active",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "sessionKeyList",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_sessionKey",
          "type": "address"
        }
      ],
      "name": "toggleSessionKeyActive",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_sessionKey",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "initCode",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callData",
              "type": "bytes"
            },
            {
              "internalType": "bytes32",
              "name": "accountGasLimits",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "preVerificationGas",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "gasFees",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "paymasterAndData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct PackedUserOperation",
          "name": "userOp",
          "type": "tuple"
        }
      ],
      "name": "validateSessionKeyParams",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "initCode",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "callData",
              "type": "bytes"
            },
            {
              "internalType": "bytes32",
              "name": "accountGasLimits",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "preVerificationGas",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "gasFees",
              "type": "bytes32"
            },
            {
              "internalType": "bytes",
              "name": "paymasterAndData",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "signature",
              "type": "bytes"
            }
          ],
          "internalType": "struct PackedUserOperation",
          "name": "userOp",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "userOpHash",
          "type": "bytes32"
        }
      ],
      "name": "validateUserOp",
      "outputs": [
        {
          "internalType": "ERC7579ValidatorBase.ValidationData",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "version",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x8cc631598ca6ab12726fa453714d8df45d31e8515af58e113f9e36552d2b58cb",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": null,
    "transactionIndex": 0,
    "gasUsed": "886591",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x7997d6dda32d5221eb0ac47e304ef7584337f1ba150846c152d9f24bd3a2bfe5",
    "transactionHash": "0x8cc631598ca6ab12726fa453714d8df45d31e8515af58e113f9e36552d2b58cb",
    "logs": [],
    "blockNumber": 62855561,
    "cumulativeGasUsed": "886591",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "2396308e43d96a238747fc9a1ffc6a35",
  "metadata": "{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartAccount\",\"type\":\"address\"}],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExecutionFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartAccount\",\"type\":\"address\"}],\"name\":\"NotInitialized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"session\",\"type\":\"address\"}],\"name\":\"SessionKeyDoesNotExist\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sessionKey\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"SessionKeyActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sessionKey\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"SessionKeyAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sessionKey\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"SessionKeyDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sessionKey\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"SessionKeyInactive\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_session\",\"type\":\"address\"}],\"name\":\"disableSessionKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sessionKey\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"funcSelector\",\"type\":\"bytes4\"},{\"internalType\":\"uint48\",\"name\":\"validAfter\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"validUntil\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"internalType\":\"struct SessionValidator.SessionData\",\"name\":\"sessionData\",\"type\":\"tuple\"}],\"name\":\"enableSessionKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sessionKey\",\"type\":\"address\"}],\"name\":\"getSessionData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"funcSelector\",\"type\":\"bytes4\"},{\"internalType\":\"uint48\",\"name\":\"validAfter\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"validUntil\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"internalType\":\"struct SessionValidator.SessionData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartAccount\",\"type\":\"address\"}],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"typeID\",\"type\":\"uint256\"}],\"name\":\"isModuleType\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sessionKey\",\"type\":\"address\"}],\"name\":\"isSessionKeyActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"isValidSignatureWithSender\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onInstall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onUninstall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"sessionKeyData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"funcSelector\",\"type\":\"bytes4\"},{\"internalType\":\"uint48\",\"name\":\"validAfter\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"validUntil\",\"type\":\"uint48\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sessionKeyList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sessionKey\",\"type\":\"address\"}],\"name\":\"toggleSessionKeyActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sessionKey\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"accountGasLimits\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"gasFees\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct PackedUserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"}],\"name\":\"validateSessionKeyParams\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"accountGasLimits\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"preVerificationGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"gasFees\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"paymasterAndData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct PackedUserOperation\",\"name\":\"userOp\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"userOpHash\",\"type\":\"bytes32\"}],\"name\":\"validateUserOp\",\"outputs\":[{\"internalType\":\"ERC7579ValidatorBase.ValidationData\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"enableSessionKey(address,(address,bytes4,uint48,uint48,bool))\":{\"details\":\"Adds a session key to the mapping.\"},\"isInitialized(address)\":{\"details\":\"Returns if the module was already initialized for a provided smartaccount\"},\"onInstall(bytes)\":{\"details\":\"This function is called by the smart account during installation of the module\",\"params\":{\"data\":\"arbitrary data that may be required on the module during `onInstall` initialization MUST revert on error (i.e. if module is already enabled)\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/validator/SessionValidator.sol\":\"SessionValidator\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@account-abstraction/contracts/core/Helpers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable no-inline-assembly */\\n\\n\\n /*\\n  * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\\n  * must return this value in case of signature failure, instead of revert.\\n  */\\nuint256 constant SIG_VALIDATION_FAILED = 1;\\n\\n\\n/*\\n * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\\n * return this value on success.\\n */\\nuint256 constant SIG_VALIDATION_SUCCESS = 0;\\n\\n\\n/**\\n * Returned data from validateUserOp.\\n * validateUserOp returns a uint256, which is created by `_packedValidationData` and\\n * parsed by `_parseValidationData`.\\n * @param aggregator  - address(0) - The account validated the signature by itself.\\n *                      address(1) - The account failed to validate the signature.\\n *                      otherwise - This is an address of a signature aggregator that must\\n *                                  be used to validate the signature.\\n * @param validAfter  - This UserOp is valid only after this timestamp.\\n * @param validaUntil - This UserOp is valid only up to this timestamp.\\n */\\nstruct ValidationData {\\n    address aggregator;\\n    uint48 validAfter;\\n    uint48 validUntil;\\n}\\n\\n/**\\n * Extract sigFailed, validAfter, validUntil.\\n * Also convert zero validUntil to type(uint48).max.\\n * @param validationData - The packed validation data.\\n */\\nfunction _parseValidationData(\\n    uint256 validationData\\n) pure returns (ValidationData memory data) {\\n    address aggregator = address(uint160(validationData));\\n    uint48 validUntil = uint48(validationData >> 160);\\n    if (validUntil == 0) {\\n        validUntil = type(uint48).max;\\n    }\\n    uint48 validAfter = uint48(validationData >> (48 + 160));\\n    return ValidationData(aggregator, validAfter, validUntil);\\n}\\n\\n/**\\n * Helper to pack the return value for validateUserOp.\\n * @param data - The ValidationData to pack.\\n */\\nfunction _packValidationData(\\n    ValidationData memory data\\n) pure returns (uint256) {\\n    return\\n        uint160(data.aggregator) |\\n        (uint256(data.validUntil) << 160) |\\n        (uint256(data.validAfter) << (160 + 48));\\n}\\n\\n/**\\n * Helper to pack the return value for validateUserOp, when not using an aggregator.\\n * @param sigFailed  - True for signature failure, false for success.\\n * @param validUntil - Last timestamp this UserOperation is valid (or zero for infinite).\\n * @param validAfter - First timestamp this UserOperation is valid.\\n */\\nfunction _packValidationData(\\n    bool sigFailed,\\n    uint48 validUntil,\\n    uint48 validAfter\\n) pure returns (uint256) {\\n    return\\n        (sigFailed ? 1 : 0) |\\n        (uint256(validUntil) << 160) |\\n        (uint256(validAfter) << (160 + 48));\\n}\\n\\n/**\\n * keccak function over calldata.\\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\\n */\\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\\n        assembly (\\\"memory-safe\\\") {\\n            let mem := mload(0x40)\\n            let len := data.length\\n            calldatacopy(mem, data.offset, len)\\n            ret := keccak256(mem, len)\\n        }\\n    }\\n\\n\\n/**\\n * The minimum of two numbers.\\n * @param a - First number.\\n * @param b - Second number.\\n */\\n    function min(uint256 a, uint256 b) pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\",\"keccak256\":\"0x6247e011a6cb0b263b3aa098822977181674d91b62e5bdfe04c6e66f72da25d6\",\"license\":\"GPL-3.0\"},\"@account-abstraction/contracts/core/UserOperationLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable no-inline-assembly */\\n\\nimport \\\"../interfaces/PackedUserOperation.sol\\\";\\nimport {calldataKeccak, min} from \\\"./Helpers.sol\\\";\\n\\n/**\\n * Utility functions helpful when working with UserOperation structs.\\n */\\nlibrary UserOperationLib {\\n\\n    uint256 public constant PAYMASTER_VALIDATION_GAS_OFFSET = 20;\\n    uint256 public constant PAYMASTER_POSTOP_GAS_OFFSET = 36;\\n    uint256 public constant PAYMASTER_DATA_OFFSET = 52;\\n    /**\\n     * Get sender from user operation data.\\n     * @param userOp - The user operation data.\\n     */\\n    function getSender(\\n        PackedUserOperation calldata userOp\\n    ) internal pure returns (address) {\\n        address data;\\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\\n        assembly {\\n            data := calldataload(userOp)\\n        }\\n        return address(uint160(data));\\n    }\\n\\n    /**\\n     * Relayer/block builder might submit the TX with higher priorityFee,\\n     * but the user should not pay above what he signed for.\\n     * @param userOp - The user operation data.\\n     */\\n    function gasPrice(\\n        PackedUserOperation calldata userOp\\n    ) internal view returns (uint256) {\\n        unchecked {\\n            (uint256 maxPriorityFeePerGas, uint256 maxFeePerGas) = unpackUints(userOp.gasFees);\\n            if (maxFeePerGas == maxPriorityFeePerGas) {\\n                //legacy mode (for networks that don't support basefee opcode)\\n                return maxFeePerGas;\\n            }\\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\\n        }\\n    }\\n\\n    /**\\n     * Pack the user operation data into bytes for hashing.\\n     * @param userOp - The user operation data.\\n     */\\n    function encode(\\n        PackedUserOperation calldata userOp\\n    ) internal pure returns (bytes memory ret) {\\n        address sender = getSender(userOp);\\n        uint256 nonce = userOp.nonce;\\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\\n        bytes32 accountGasLimits = userOp.accountGasLimits;\\n        uint256 preVerificationGas = userOp.preVerificationGas;\\n        bytes32 gasFees = userOp.gasFees;\\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\\n\\n        return abi.encode(\\n            sender, nonce,\\n            hashInitCode, hashCallData,\\n            accountGasLimits, preVerificationGas, gasFees,\\n            hashPaymasterAndData\\n        );\\n    }\\n\\n    function unpackUints(\\n        bytes32 packed\\n    ) internal pure returns (uint256 high128, uint256 low128) {\\n        return (uint128(bytes16(packed)), uint128(uint256(packed)));\\n    }\\n\\n    //unpack just the high 128-bits from a packed value\\n    function unpackHigh128(bytes32 packed) internal pure returns (uint256) {\\n        return uint256(packed) >> 128;\\n    }\\n\\n    // unpack just the low 128-bits from a packed value\\n    function unpackLow128(bytes32 packed) internal pure returns (uint256) {\\n        return uint128(uint256(packed));\\n    }\\n\\n    function unpackMaxPriorityFeePerGas(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackHigh128(userOp.gasFees);\\n    }\\n\\n    function unpackMaxFeePerGas(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackLow128(userOp.gasFees);\\n    }\\n\\n    function unpackVerificationGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackHigh128(userOp.accountGasLimits);\\n    }\\n\\n    function unpackCallGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return unpackLow128(userOp.accountGasLimits);\\n    }\\n\\n    function unpackPaymasterVerificationGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET]));\\n    }\\n\\n    function unpackPostOpGasLimit(PackedUserOperation calldata userOp)\\n    internal pure returns (uint256) {\\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]));\\n    }\\n\\n    function unpackPaymasterStaticFields(\\n        bytes calldata paymasterAndData\\n    ) internal pure returns (address paymaster, uint256 validationGasLimit, uint256 postOpGasLimit) {\\n        return (\\n            address(bytes20(paymasterAndData[: PAYMASTER_VALIDATION_GAS_OFFSET])),\\n            uint128(bytes16(paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET])),\\n            uint128(bytes16(paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]))\\n        );\\n    }\\n\\n    /**\\n     * Hash the user operation data.\\n     * @param userOp - The user operation data.\\n     */\\n    function hash(\\n        PackedUserOperation calldata userOp\\n    ) internal pure returns (bytes32) {\\n        return keccak256(encode(userOp));\\n    }\\n}\\n\",\"keccak256\":\"0x9d50ece985d35f82e33e5da417595c86fac10449e3d10895d08363d33aad454b\",\"license\":\"GPL-3.0\"},\"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.7.5;\\n\\n/**\\n * User Operation struct\\n * @param sender                - The sender account of this request.\\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\\n * @param initCode              - If set, the account contract will be created by this constructor/\\n * @param callData              - The method call to execute on this account.\\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\\n *                                Covers batch overhead.\\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\\n *                                The paymaster will pay for the transaction instead of the sender.\\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n */\\nstruct PackedUserOperation {\\n    address sender;\\n    uint256 nonce;\\n    bytes initCode;\\n    bytes callData;\\n    bytes32 accountGasLimits;\\n    uint256 preVerificationGas;\\n    bytes32 gasFees;\\n    bytes paymasterAndData;\\n    bytes signature;\\n}\\n\",\"keccak256\":\"0x1129b46381db68eddbc5cb49e50664667b66b03c480453858e7b25eabe444359\",\"license\":\"GPL-3.0\"},\"account-abstraction/interfaces/PackedUserOperation.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.7.5;\\n\\n/**\\n * User Operation struct\\n * @param sender                - The sender account of this request.\\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\\n * @param initCode              - If set, the account contract will be created by this constructor/\\n * @param callData              - The method call to execute on this account.\\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\\n *                                Covers batch overhead.\\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\\n *                                The paymaster will pay for the transaction instead of the sender.\\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n */\\nstruct PackedUserOperation {\\n    address sender;\\n    uint256 nonce;\\n    bytes initCode;\\n    bytes callData;\\n    bytes32 accountGasLimits;\\n    uint256 preVerificationGas;\\n    bytes32 gasFees;\\n    bytes paymasterAndData;\\n    bytes signature;\\n}\\n\",\"keccak256\":\"0x1129b46381db68eddbc5cb49e50664667b66b03c480453858e7b25eabe444359\",\"license\":\"GPL-3.0\"},\"contracts/integrations/ISwapRouter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.4;\\npragma abicoder v2;\\n\\nimport { IUniswapV3SwapCallback } from \\\"./IUniswapV3SwapCallback.sol\\\";\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter is IUniswapV3SwapCallback {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        // uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in\\n    /// calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified\\n    /// path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams`\\n    /// in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in\\n    /// calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the\\n    /// specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as\\n    /// `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params)\\n        external\\n        payable\\n        returns (uint256 amountIn);\\n}\",\"keccak256\":\"0x74a348742d19702da8927a34f4e86231b6eeabe534cb22d9ed3952b13000fff9\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/IUniswapV3SwapCallback.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical\\n    /// UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received\\n    /// (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received\\n    /// (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    )\\n        external;\\n}\",\"keccak256\":\"0xa2c3808fc38c61788f6358f40bdbc98bc0789a0428f94825ab737659d78a8249\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/SwapRouterConfigLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nlibrary SwapRouterConfigLibrary {\\n    struct RouterConfig {\\n        address payable routerAddress;\\n        uint24 fee;\\n    }\\n\\n    // Define configurations inside a pure function\\n    function getSwapRouterConfig(uint256 chainId) internal pure returns (RouterConfig memory) {\\n        if (chainId == 1) { // Ethereum Mainnet\\n            return RouterConfig(payable(0xE592427A0AEce92De3Edee1F18E0157C05861564), 3000);\\n        } else if (chainId == 137) { // Polygon\\n            return RouterConfig(payable(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45), 3000);\\n        } else if (chainId == 42161) { // Arbitrum\\n            return RouterConfig(payable(0xE592427A0AEce92De3Edee1F18E0157C05861564), 500);\\n        } else if (chainId == 8453) { // Base\\n            return RouterConfig(payable(0x2626664c2603336E57B271c5C0b26F421741e481), 3000);\\n        } else {\\n            return RouterConfig(payable(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45), 3000);\\n        }\\n    }\\n}\",\"keccak256\":\"0x5a1acf8ffb0f0b1c4ee1a1310a8349549af8876e1344a4dc49e9e7c34788dd3d\",\"license\":\"MIT\"},\"contracts/integrations/Uniswap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport \\\"./SwapRouterConfigLibrary.sol\\\";\\nimport { ISwapRouter } from \\\"./ISwapRouter.sol\\\";\\nimport { IERC20 } from \\\"forge-std/interfaces/IERC20.sol\\\";\\nimport { ERC20Integration } from \\\"modulekit/Integrations.sol\\\";\\nimport { Execution } from \\\"modulekit/Accounts.sol\\\";\\n\\n/// @author zeroknots\\nlibrary UniswapV3Integration {\\n    using ERC20Integration for IERC20;\\n    using SwapRouterConfigLibrary for uint256;\\n\\n\\n    function approveAndSwap(\\n        address smartAccount,\\n        IERC20 tokenIn,\\n        IERC20 tokenOut,\\n        uint256 amountIn,\\n        uint160 sqrtPriceLimitX96\\n    )\\n        internal\\n        view\\n        returns (Execution[] memory exec)\\n    {\\n        SwapRouterConfigLibrary.RouterConfig memory config = block.chainid.getSwapRouterConfig();\\n\\n        exec = new Execution[](3);\\n        (exec[0], exec[1]) = ERC20Integration.safeApprove(tokenIn, config.routerAddress, amountIn);\\n        exec[2] = swapExactInputSingle(smartAccount, tokenIn, tokenOut, amountIn, sqrtPriceLimitX96, config.routerAddress, config.fee);\\n    }\\n\\n    function swapExactInputSingle(\\n        address smartAccount,\\n        IERC20 tokenIn,\\n        IERC20 tokenOut,\\n        uint256 amountIn,\\n        uint160 sqrtPriceLimitX96,\\n        address payable swapRouter,\\n        uint24 fee\\n    )\\n        internal\\n        view\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: swapRouter,\\n            value: 0,\\n            callData: abi.encodeCall(\\n                ISwapRouter.exactInputSingle,\\n                (\\n                    ISwapRouter.ExactInputSingleParams({\\n                        tokenIn: address(tokenIn),\\n                        tokenOut: address(tokenOut),\\n                        fee: fee,\\n                        recipient: smartAccount,\\n                        // deadline: block.timestamp,\\n                        amountIn: amountIn,\\n                        amountOutMinimum: 0,\\n                        sqrtPriceLimitX96: sqrtPriceLimitX96\\n                    })\\n                )\\n            )\\n        });\\n    }\\n\\n    function swapExactOutputSingle(\\n        address smartAccount,\\n        IERC20 tokenIn,\\n        IERC20 tokenOut,\\n        uint256 amountOut,\\n        uint256 amountInMaximum,\\n        address payable swapRouter,\\n        uint24 fee\\n    )\\n        internal\\n        view\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: swapRouter,\\n            value: 0,\\n            callData: abi.encodeCall(\\n                ISwapRouter.exactOutputSingle,\\n                (\\n                    ISwapRouter.ExactOutputSingleParams({\\n                        tokenIn: address(tokenIn),\\n                        tokenOut: address(tokenOut),\\n                        fee: fee,\\n                        recipient: smartAccount,\\n                        deadline: block.timestamp,\\n                        amountOut: amountOut,\\n                        amountInMaximum: amountInMaximum,\\n                        sqrtPriceLimitX96: 0\\n                    })\\n                )\\n            )\\n        });\\n    }\\n}\",\"keccak256\":\"0x7fea04ef95697b1e557af1feaddd485fc16421bed198b08e9dd49befd583404c\",\"license\":\"MIT\"},\"contracts/module-bases/ERC7579ExecutorBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport \\\"../safe7579/external/ERC7579.sol\\\";\\nimport { ERC7579ModuleBase } from \\\"./ERC7579ModuleBase.sol\\\";\\n\\nabstract contract ERC7579ExecutorBase is IERC7579Executor, ERC7579ModuleBase {\\n    function _execute(\\n        address account,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    )\\n        internal\\n        returns (bytes memory result)\\n    {\\n        ModeCode modeCode = ERC7579ModeLib.encode({\\n            callType: CALLTYPE_SINGLE,\\n            execType: EXECTYPE_DEFAULT,\\n            mode: MODE_DEFAULT,\\n            payload: ModePayload.wrap(bytes22(0))\\n        });\\n\\n        return IERC7579Account(account).executeFromExecutor(\\n            modeCode, ERC7579ExecutionLib.encodeSingle(to, value, data)\\n        )[0];\\n    }\\n\\n    function _execute(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    )\\n        internal\\n        returns (bytes memory result)\\n    {\\n        return _execute(msg.sender, to, value, data);\\n    }\\n\\n    function _execute(\\n        address account,\\n        Execution[] memory execs\\n    )\\n        internal\\n        returns (bytes[] memory results)\\n    {\\n        ModeCode modeCode = ERC7579ModeLib.encode({\\n            callType: CALLTYPE_BATCH,\\n            execType: EXECTYPE_DEFAULT,\\n            mode: MODE_DEFAULT,\\n            payload: ModePayload.wrap(bytes22(0))\\n        });\\n        results = IERC7579Account(account).executeFromExecutor(\\n            modeCode, ERC7579ExecutionLib.encodeBatch(execs)\\n        );\\n    }\\n\\n    function _execute(Execution[] memory execs) internal returns (bytes[] memory results) {\\n        return _execute(msg.sender, execs);\\n    }\\n\\n    // Note: Not every account will support delegatecalls\\n    function _executeDelegateCall(\\n        address account,\\n        address delegateTarget,\\n        bytes memory callData\\n    )\\n        internal\\n        returns (bytes[] memory results)\\n    {\\n        ModeCode modeCode = ERC7579ModeLib.encode({\\n            callType: CALLTYPE_DELEGATECALL,\\n            execType: EXECTYPE_DEFAULT,\\n            mode: MODE_DEFAULT,\\n            payload: ModePayload.wrap(bytes22(0))\\n        });\\n        results = IERC7579Account(account).executeFromExecutor(\\n            modeCode, abi.encodePacked(delegateTarget, callData)\\n        );\\n    }\\n\\n    // Note: Not every account will support delegatecalls\\n    function _executeDelegateCall(\\n        address delegateTarget,\\n        bytes memory callData\\n    )\\n        internal\\n        returns (bytes[] memory results)\\n    {\\n        return _executeDelegateCall(msg.sender, delegateTarget, callData);\\n    }\\n}\",\"keccak256\":\"0xa4729b5793bfae51db97ecd2706ce1cb652cd0ff43fd9ba1fe6793438b1301f2\",\"license\":\"MIT\"},\"contracts/module-bases/ERC7579ModuleBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { IERC7579Module } from \\\"../safe7579/external/ERC7579.sol\\\";\\n\\nabstract contract ERC7579ModuleBase is IERC7579Module {\\n    uint256 constant TYPE_VALIDATOR = 1;\\n    uint256 constant TYPE_EXECUTOR = 2;\\n    uint256 constant TYPE_FALLBACK = 3;\\n    uint256 constant TYPE_HOOK = 4;\\n}\",\"keccak256\":\"0x44e42a9254211dc12fc684d8d3a18363368244007ac4348f24e270376521cf9c\",\"license\":\"MIT\"},\"contracts/module-bases/ERC7579ValidatorBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport {PackedUserOperation} from \\\"@account-abstraction/contracts/interfaces/PackedUserOperation.sol\\\";\\nimport {_packValidationData as _packValidationData4337} from \\\"@account-abstraction/contracts/core/Helpers.sol\\\";\\nimport { ERC7579ModuleBase } from \\\"./ERC7579ModuleBase.sol\\\";\\n\\nabstract contract ERC7579ValidatorBase is ERC7579ModuleBase {\\n    type ValidationData is uint256;\\n\\n    ValidationData internal constant VALIDATION_SUCCESS = ValidationData.wrap(0);\\n    ValidationData internal constant VALIDATION_FAILED = ValidationData.wrap(1);\\n    bytes4 internal constant EIP1271_SUCCESS = 0x1626ba7e;\\n    bytes4 internal constant EIP1271_FAILED = 0xFFFFFFFF;\\n\\n    /**\\n     * Helper to pack the return value for validateUserOp, when not using an aggregator.\\n     * @param sigFailed  - True for signature failure, false for success.\\n     * @param validUntil - Last timestamp this UserOperation is valid (or zero for\\n     * infinite).\\n     * @param validAfter - First timestamp this UserOperation is valid.\\n     */\\n    function _packValidationData(\\n        bool sigFailed,\\n        uint48 validUntil,\\n        uint48 validAfter\\n    )\\n        internal\\n        pure\\n        returns (ValidationData)\\n    {\\n        return ValidationData.wrap(_packValidationData4337(sigFailed, validUntil, validAfter));\\n    }\\n\\n    function _unpackValidationData(ValidationData _packedData)\\n        internal\\n        pure\\n        returns (bool sigFailed, uint48 validUntil, uint48 validAfter)\\n    {\\n        uint256 packedData = ValidationData.unwrap(_packedData);\\n        sigFailed = (packedData & 1) == 1;\\n        validUntil = uint48((packedData >> 160) & ((1 << 48) - 1));\\n        validAfter = uint48((packedData >> (160 + 48)) & ((1 << 48) - 1));\\n    }\\n\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash\\n    )\\n        external\\n        virtual\\n        returns (ValidationData);\\n\\n    function isValidSignatureWithSender(\\n        address sender,\\n        bytes32 hash,\\n        bytes calldata data\\n    )\\n        external\\n        view\\n        virtual\\n        returns (bytes4);\\n}\",\"keccak256\":\"0x4ea546f37886f86f2639297a82224dea7132aa2264bc7907fb7e200e58a6965a\",\"license\":\"MIT\"},\"contracts/safe7579/external/ERC7579.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable no-unused-import */\\nimport { MSAFactory as ERC7579AccountFactory } from \\\"erc7579/MSAFactory.sol\\\";\\nimport { MSAAdvanced as ERC7579Account } from \\\"erc7579/MSAAdvanced.sol\\\";\\nimport { Execution, IERC7579Account } from \\\"erc7579/interfaces/IERC7579Account.sol\\\";\\nimport {\\n    IModule as IERC7579Module,\\n    IValidator as IERC7579Validator,\\n    IExecutor as IERC7579Executor,\\n    IHook as IERC7579Hook,\\n    IFallback as IERC7579Fallback,\\n    MODULE_TYPE_VALIDATOR,\\n    MODULE_TYPE_EXECUTOR,\\n    MODULE_TYPE_HOOK,\\n    MODULE_TYPE_FALLBACK\\n} from \\\"erc7579/interfaces/IERC7579Module.sol\\\";\\n\\nimport {\\n    ModeLib as ERC7579ModeLib,\\n    ModeCode,\\n    CallType,\\n    ExecType,\\n    ModePayload,\\n    CALLTYPE_SINGLE,\\n    CALLTYPE_BATCH,\\n    CALLTYPE_DELEGATECALL,\\n    EXECTYPE_DEFAULT,\\n    MODE_DEFAULT\\n} from \\\"erc7579/lib/ModeLib.sol\\\";\\nimport { Execution, ExecutionLib as ERC7579ExecutionLib } from \\\"erc7579/lib/ExecutionLib.sol\\\";\\n\\nimport {\\n    Bootstrap as ERC7579Bootstrap,\\n    BootstrapConfig as ERC7579BootstrapConfig\\n} from \\\"erc7579/utils/Bootstrap.sol\\\";\\n/* solhint-enable no-unused-import */\",\"keccak256\":\"0x1b7b6abd1abcb25b27f79008941523c83f0965817c0d9384419c2423acc1fac0\",\"license\":\"MIT\"},\"contracts/safe7579/interfaces/IERC7579Account.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { CallType, ExecType, ModeCode } from \\\"../lib/ModeLib.sol\\\";\\n\\nstruct Execution {\\n    address target;\\n    uint256 value;\\n    bytes callData;\\n}\\n\\ninterface IERC7579AccountEvents {\\n    event ModuleInstalled(uint256 moduleTypeId, address module);\\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\\n}\\n\\ninterface IERC7579Account is IERC7579AccountEvents {\\n    // Error thrown when an unsupported ModuleType is requested\\n    error UnsupportedModuleType(uint256 moduleTypeId);\\n    // Error thrown when an execution with an unsupported CallType was made\\n    error UnsupportedCallType(CallType callType);\\n    // Error thrown when an execution with an unsupported ExecType was made\\n    error UnsupportedExecType(ExecType execType);\\n    // Error thrown when account initialization fails\\n    error AccountInitializationFailed();\\n    /**\\n     * @dev Executes a transaction on behalf of the account.\\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * If a mode is requested that is not supported by the Account, it MUST revert\\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\\n     * @param executionCalldata The encoded execution call data\\n     */\\n\\n    function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\\n\\n    /**\\n     * @dev Executes a transaction on behalf of the account.\\n     *         This function is intended to be called by Executor Modules\\n     * @dev Ensure adequate authorization control: i.e. onlyExecutorModule\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * If a mode is requested that is not supported by the Account, it MUST revert\\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\\n     * @param executionCalldata The encoded execution call data\\n     */\\n    function executeFromExecutor(\\n        ModeCode mode,\\n        bytes calldata executionCalldata\\n    )\\n        external\\n        payable\\n        returns (bytes[] memory returnData);\\n\\n    /**\\n     * @dev ERC-1271 isValidSignature\\n     *         This function is intended to be used to validate a smart account signature\\n     * and may forward the call to a validator module\\n     *\\n     * @param hash The hash of the data that is signed\\n     * @param data The data that is signed\\n     */\\n    function isValidSignature(bytes32 hash, bytes calldata data) external returns (bytes4);\\n\\n    /**\\n     * @dev installs a Module of a certain type on the smart account\\n     * @dev Implement Authorization control of your chosing\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     * @param module the module address\\n     * @param initData arbitrary data that may be required on the module during `onInstall`\\n     * initialization.\\n     */\\n    function installModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata initData\\n    )\\n        external\\n        payable;\\n\\n    /**\\n     * @dev uninstalls a Module of a certain type on the smart account\\n     * @dev Implement Authorization control of your chosing\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     * @param module the module address\\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\\n     * de-initialization.\\n     */\\n    function uninstallModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata deInitData\\n    )\\n        external\\n        payable;\\n\\n    /**\\n     * Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\\n     * @param encodedMode the encoded mode\\n     */\\n    function supportsExecutionMode(ModeCode encodedMode) external view returns (bool);\\n\\n    /**\\n     * Function to check if the account supports installation of a certain module type Id\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     */\\n    function supportsModule(uint256 moduleTypeId) external view returns (bool);\\n\\n    /**\\n     * Function to check if the account has a certain module installed\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\\n     *            thus may be necessary to query multiple module types\\n     * @param module the module address\\n     * @param additionalContext additional context data that the smart account may interpret to\\n     *                          identifiy conditions under which the module is installed.\\n     *                          usually this is not necessary, but for some special hooks that\\n     *                          are stored in mappings, this param might be needed\\n     */\\n    function isModuleInstalled(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata additionalContext\\n    )\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the account id of the smart account\\n     * @return accountImplementationId the account id of the smart account\\n     * the accountId should be structured like so:\\n     *        \\\"vendorname.accountname.semver\\\"\\n     */\\n    function accountId() external view returns (string memory accountImplementationId);\\n}\\n\",\"keccak256\":\"0x55c67ffa09b0087e97322a0881494dd497250af4586904403181c536baadb164\",\"license\":\"MIT\"},\"contracts/safe7579/lib/ExecutionLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { Execution } from \\\"../interfaces/IERC7579Account.sol\\\";\\n\\n/**\\n * Helper Library for decoding Execution calldata\\n * malloc for memory allocation is bad for gas. use this assembly instead\\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\\n */\\nlibrary ExecutionLib {\\n    function decodeBatch(bytes calldata callData)\\n        internal\\n        pure\\n        returns (Execution[] calldata executionBatch)\\n    {\\n        /*\\n         * Batch Call Calldata Layout\\n         * Offset (in bytes)    | Length (in bytes) | Contents\\n         * 0x0                  | 0x4               | bytes4 function selector\\n        *  0x4                  | -                 |\\n        abi.encode(IERC7579Execution.Execution[])\\n         */\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            let dataPointer := add(callData.offset, calldataload(callData.offset))\\n\\n            // Extract the ERC7579 Executions\\n            executionBatch.offset := add(dataPointer, 32)\\n            executionBatch.length := calldataload(dataPointer)\\n        }\\n    }\\n\\n    function encodeBatch(Execution[] memory executions)\\n        internal\\n        pure\\n        returns (bytes memory callData)\\n    {\\n        callData = abi.encode(executions);\\n    }\\n\\n    function decodeSingle(bytes calldata executionCalldata)\\n        internal\\n        pure\\n        returns (address target, uint256 value, bytes calldata callData)\\n    {\\n        target = address(bytes20(executionCalldata[0:20]));\\n        value = uint256(bytes32(executionCalldata[20:52]));\\n        callData = executionCalldata[52:];\\n    }\\n\\n    function encodeSingle(\\n        address target,\\n        uint256 value,\\n        bytes memory callData\\n    )\\n        internal\\n        pure\\n        returns (bytes memory userOpCalldata)\\n    {\\n        userOpCalldata = abi.encodePacked(target, value, callData);\\n    }\\n}\\n\",\"keccak256\":\"0x5852404ef72dbe607a5402af160494067e7d9e6bf1fbf9460ff309e53b4db399\",\"license\":\"MIT\"},\"contracts/safe7579/lib/ModeLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/**\\n * @title ModeLib\\n * @author rhinestone | zeroknots.eth, Konrad Kopp (@kopy-kat)\\n * To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\\n * encoding is used.\\n *    Function Signature of execute function:\\n *           function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\\n * This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\\n * context.\\n * NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\\n * implement\\n * more complex execution modes may use the entire bytes32.\\n *\\n * |--------------------------------------------------------------------|\\n * | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\\n * |--------------------------------------------------------------------|\\n * | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\\n * |--------------------------------------------------------------------|\\n *\\n * CALLTYPE: 1 byte\\n * CallType is used to determine how the executeCalldata paramter of the execute function has to be\\n * decoded.\\n * It can be either single, batch or delegatecall. In the future different calls could be added.\\n * CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\\n *\\n * EXECTYPE: 1 byte\\n * ExecType is used to determine how the account should handle the execution.\\n * It can indicate if the execution should revert on failure or continue execution.\\n * In the future more execution modes may be added.\\n * Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\\n * a batch fails, the entire batch is reverted\\n *\\n * UNUSED: 4 bytes\\n * Unused bytes are reserved for future use.\\n *\\n * ModeSelector: bytes4\\n * The \\\"optional\\\" mode selector can be used by account vendors, to implement custom behavior in\\n * their accounts.\\n * the way a ModeSelector is to be calculated is bytes4(keccak256(\\\"vendorname.featurename\\\"))\\n * this is to prevent collisions between different vendors, while allowing innovation and the\\n * development of new features without coordination between ERC-7579 implementing accounts\\n *\\n * ModePayload: 22 bytes\\n * Mode payload is used to pass additional data to the smart account execution, this may be\\n * interpreted depending on the ModeSelector\\n *\\n * ExecutionCallData: n bytes\\n * single, delegatecall or batch exec abi.encoded as bytes\\n */\\n\\n// Custom type for improved developer experience\\ntype ModeCode is bytes32;\\n\\ntype CallType is bytes1;\\n\\ntype ExecType is bytes1;\\n\\ntype ModeSelector is bytes4;\\n\\ntype ModePayload is bytes22;\\n\\n// Default CallType\\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\\n// Batched CallType\\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\\n// @dev Implementing delegatecall is OPTIONAL!\\n// implement delegatecall with extreme care.\\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\\n\\n// @dev default behavior is to revert on failure\\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\\n// Since this is value 0x00, no additional encoding is required for simple accounts\\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\\n// @dev account may elect to change execution behavior. For example \\\"try exec\\\" / \\\"allow fail\\\"\\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\\n\\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\\n// Example declaration of a custom mode selector\\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\\\"default.mode.offset\\\")));\\n\\n/**\\n * @dev ModeLib is a helper library to encode/decode ModeCodes\\n */\\nlibrary ModeLib {\\n    function decode(ModeCode mode)\\n        internal\\n        pure\\n        returns (\\n            CallType _calltype,\\n            ExecType _execType,\\n            ModeSelector _modeSelector,\\n            ModePayload _modePayload\\n        )\\n    {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            _calltype := mode\\n            _execType := shl(8, mode)\\n            _modeSelector := shl(48, mode)\\n            _modePayload := shl(80, mode)\\n        }\\n    }\\n\\n    function encode(\\n        CallType callType,\\n        ExecType execType,\\n        ModeSelector mode,\\n        ModePayload payload\\n    )\\n        internal\\n        pure\\n        returns (ModeCode)\\n    {\\n        return ModeCode.wrap(\\n            bytes32(\\n                abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)\\n            )\\n        );\\n    }\\n\\n    function encodeSimpleBatch() internal pure returns (ModeCode mode) {\\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\\n    }\\n\\n    function encodeSimpleSingle() internal pure returns (ModeCode mode) {\\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\\n    }\\n\\n    function getCallType(ModeCode mode) internal pure returns (CallType calltype) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            calltype := mode\\n        }\\n    }\\n}\\n\\nusing { eqModeSelector as == } for ModeSelector global;\\nusing { eqCallType as == } for CallType global;\\nusing { eqExecType as == } for ExecType global;\\n\\nfunction eqCallType(CallType a, CallType b) pure returns (bool) {\\n    return CallType.unwrap(a) == CallType.unwrap(b);\\n}\\n\\nfunction eqExecType(ExecType a, ExecType b) pure returns (bool) {\\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\\n}\\n\\nfunction eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\\n}\\n\",\"keccak256\":\"0xcfd7f705b61c9e23c6847c964719b7ccd62773692777a4be9b473cf5209c89fd\",\"license\":\"MIT\"},\"contracts/validator/SessionValidator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.23;\\n\\nimport {\\n    ERC20Integration, ERC4626Integration\\n} from \\\"modulekit/Integrations.sol\\\";\\nimport { UniswapV3Integration } from \\\"../integrations/Uniswap.sol\\\";\\n\\nimport { IERC20 } from \\\"forge-std/interfaces/IERC20.sol\\\";\\nimport { IERC4626 } from \\\"forge-std/interfaces/IERC4626.sol\\\";\\n\\nimport { ERC7579ValidatorBase } from \\\"../module-bases/ERC7579ValidatorBase.sol\\\";\\nimport \\\"../safe7579/interfaces/IERC7579Account.sol\\\";\\n\\nimport { PackedUserOperation } from\\n    \\\"@account-abstraction/contracts/core/UserOperationLib.sol\\\";\\n\\nimport { SignatureCheckerLib } from \\\"solady/utils/SignatureCheckerLib.sol\\\";\\nimport { ECDSA } from \\\"solady/utils/ECDSA.sol\\\";\\nimport { ExecutionLib } from \\\"../safe7579/lib/ExecutionLib.sol\\\";\\nimport   \\\"../safe7579/lib/ModeLib.sol\\\";\\n\\n\\nimport { ERC7579ExecutorBase } from \\\"../module-bases/ERC7579ExecutorBase.sol\\\";\\n\\n\\ncontract SessionValidator is ERC7579ValidatorBase, ERC7579ExecutorBase {\\n    using SignatureCheckerLib for address;\\n    using ModeLib for ModeCode;\\n    using ExecutionLib for bytes;\\n    \\n\\n    event SessionKeyAdded(address indexed sessionKey, address indexed account);\\n    event SessionKeyDisabled(address indexed sessionKey, address indexed account);\\n    event SessionKeyActive(address indexed sessionKey, address indexed account);\\n    event SessionKeyInactive(address indexed sessionKey, address indexed account);\\n\\n\\n    error ExecutionFailed();\\n    error SessionKeyDoesNotExist(address session);\\n\\n    // account => sessionKeys\\n    mapping(address => address[]) public sessionKeyList;\\n\\n    // sessionKey => account=> SessionData\\n    mapping(address =>  mapping(address => SessionData)) public sessionKeyData;\\n\\n    \\n    struct SessionData {\\n\\n        address target;\\n        bytes4 funcSelector; \\n\\n        uint48 validAfter;\\n        uint48 validUntil;\\n        bool active;\\n    }\\n\\n\\n    // function onInstall(bytes calldata data) external override {\\n    // }\\n\\n    function onInstall(bytes calldata data) external override {\\n\\n    if (data.length == 0) return;\\n    \\n    (address sessionKey, SessionData memory sessionData) = abi.decode(data, (address, SessionData));\\n\\n    enableSessionKey(sessionKey, sessionData);\\n    \\n    }\\n\\n    function onUninstall(bytes calldata) external override {\\n\\n        // delete the Safe account sessions\\n    }\\n\\n\\n    // @inheritdoc IERC20SessionKeyValidator\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash\\n    ) external override returns (ValidationData) {\\n        address sessionKeySigner = ECDSA.tryRecover(\\n            ECDSA.toEthSignedMessageHash(userOpHash),\\n            userOp.signature\\n        );\\n        if (!validateSessionKeyParams(sessionKeySigner, userOp))\\n            return VALIDATION_FAILED;\\n        SessionData memory sd = sessionKeyData[sessionKeySigner][msg.sender];\\n        return _packValidationData(false, type(uint48).max, 0);\\n    }\\n\\n\\n    function toggleSessionKeyActive(address _sessionKey) external {\\n        SessionData storage sd = sessionKeyData[_sessionKey][msg.sender];\\n        if (sd.validUntil == 0)\\n            revert SessionKeyDoesNotExist(_sessionKey);\\n        if (sd.active) {\\n            sd.active = false;\\n            emit SessionKeyActive(_sessionKey, msg.sender);\\n        } else {\\n            sd.active = true;\\n            emit SessionKeyInactive(_sessionKey, msg.sender);\\n        }\\n    }\\n\\n    function isSessionKeyActive(address _sessionKey) public view returns (bool) {\\n        return sessionKeyData[_sessionKey][msg.sender].active;\\n    }\\n\\n    // @inheritdoc IERC20SessionKeyValidator\\n    function validateSessionKeyParams(\\n        address _sessionKey,\\n        PackedUserOperation calldata userOp\\n    ) public view returns (bool) {\\n        SessionData memory sd = sessionKeyData[_sessionKey][msg.sender];\\n        if (isSessionKeyActive(_sessionKey) == false) {\\n            return false;\\n        }\\n        address target;\\n        bytes calldata callData = userOp.callData;\\n        bytes4 sel = bytes4(callData[:4]);\\n        if (sel == IERC7579Account.execute.selector) {\\n            ModeCode mode = ModeCode.wrap(bytes32(callData[4:36]));\\n            (CallType calltype, , , ) = ModeLib.decode(mode);\\n            if (calltype == CALLTYPE_SINGLE) {\\n                bytes calldata execData;\\n                // 0x00 ~ 0x04 : selector\\n                // 0x04 ~ 0x24 : mode code\\n                // 0x24 ~ 0x44 : execution target\\n                // 0x44 ~0x64 : execution value\\n                // 0x64 ~ : execution calldata\\n                (target, , execData) = ExecutionLib.decodeSingle(\\n                    callData[100:]\\n                );\\n                \\n                bytes4 selector = bytes4(execData[0:4]);\\n\\n                if (target != sd.target) return false;\\n                if (selector != sd.funcSelector) return false;\\n                return true;\\n\\n            }\\n            if (calltype == CALLTYPE_BATCH) {\\n                Execution[] calldata execs = ExecutionLib.decodeBatch(\\n                    callData[100:]\\n                );\\n                for (uint256 i; i < execs.length; i++) {\\n                    target = execs[i].target;\\n                    bytes4 selector = bytes4(execs[i].callData[0:4]);\\n\\n                    if (target != sd.target) return false;\\n                    if (selector != sd.funcSelector) return false;\\n                }\\n                return true;\\n            } else {\\n                return false;\\n            }\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n\\n    function isValidSignatureWithSender(\\n        address,\\n        bytes32 hash,\\n        bytes calldata data\\n    )\\n        external\\n        view\\n        override\\n        returns (bytes4)\\n    {\\n\\n        //Implement the session key sig validation\\n\\n        // return SignatureCheckerLib.isValidSignatureNowCalldata(owner, hash, data)\\n        //     ? EIP1271_SUCCESS\\n        //     : EIP1271_FAILED;\\n    }\\n\\n\\n    /**\\n     * @dev Adds a session key to the mapping.\\n     */\\n    // Add a session key to the mapping\\n    function enableSessionKey(address sessionKey, SessionData memory sessionData) public {\\n\\n        sessionKeyData[sessionKey][msg.sender] = sessionData;\\n        emit SessionKeyAdded(sessionKey, msg.sender);\\n    }\\n\\n    function disableSessionKey(address _session) public {\\n        if (sessionKeyData[_session][msg.sender].validUntil == 0)\\n            revert SessionKeyDoesNotExist(_session);\\n        delete sessionKeyData[_session][msg.sender];\\n        emit SessionKeyDisabled(_session, msg.sender);\\n    }\\n\\n\\n\\n    // Function to get the array of SessionData for a specific address\\n    function getSessionData(address sessionKey) public view returns (SessionData memory) {\\n        return sessionKeyData[sessionKey][msg.sender];\\n    }\\n\\n\\n    function name() external pure returns (string memory) {\\n        return \\\"AutoDCASessionModule\\\";\\n    }\\n\\n    function version() external pure returns (string memory) {\\n        return \\\"0.0.1\\\";\\n    }\\n\\n    function isModuleType(uint256 typeID) external pure override returns (bool) {\\n        return typeID == TYPE_VALIDATOR || typeID == TYPE_EXECUTOR;\\n    }\\n\\n    function isInitialized(address smartAccount) external view returns (bool) { }\\n}\",\"keccak256\":\"0xc5321b809ec47cdf2cd46f07d094d0d9769d6ec58c943ac648f4dbf1101b5683\",\"license\":\"GPL-3.0\"},\"erc7579/MSAAdvanced.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport \\\"./lib/ModeLib.sol\\\";\\nimport { ExecutionLib } from \\\"./lib/ExecutionLib.sol\\\";\\nimport { ExecutionHelper } from \\\"./core/ExecutionHelper.sol\\\";\\nimport { PackedUserOperation } from \\\"account-abstraction/interfaces/PackedUserOperation.sol\\\";\\nimport \\\"./interfaces/IERC7579Module.sol\\\";\\nimport { IERC7579Account } from \\\"./interfaces/IERC7579Account.sol\\\";\\nimport { IMSA } from \\\"./interfaces/IMSA.sol\\\";\\nimport { ModuleManager } from \\\"./core/ModuleManager.sol\\\";\\nimport { HookManager } from \\\"./core/HookManager.sol\\\";\\n\\n/**\\n * @author zeroknots.eth | rhinestone.wtf\\n * Reference implementation of a very simple ERC7579 Account.\\n * This account implements CallType: SINGLE, BATCH and DELEGATECALL.\\n * This account implements ExecType: DEFAULT and TRY.\\n * Hook support is implemented\\n */\\ncontract MSAAdvanced is IMSA, ExecutionHelper, ModuleManager, HookManager {\\n    using ExecutionLib for bytes;\\n    using ModeLib for ModeCode;\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     * @dev this function is only callable by the entry point or the account itself\\n     * @dev this function demonstrates how to implement\\n     * CallType SINGLE and BATCH and ExecType DEFAULT and TRY\\n     * @dev this function demonstrates how to implement hook support (modifier)\\n     */\\n    function execute(\\n        ModeCode mode,\\n        bytes calldata executionCalldata\\n    )\\n        external\\n        payable\\n        onlyEntryPointOrSelf\\n        withHook\\n    {\\n        (CallType callType, ExecType execType,,) = mode.decode();\\n\\n        // check if calltype is batch or single\\n        if (callType == CALLTYPE_BATCH) {\\n            // destructure executionCallData according to batched exec\\n            Execution[] calldata executions = executionCalldata.decodeBatch();\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) _execute(executions);\\n            else if (execType == EXECTYPE_TRY) _tryExecute(executions);\\n            else revert UnsupportedExecType(execType);\\n        } else if (callType == CALLTYPE_SINGLE) {\\n            // destructure executionCallData according to single exec\\n            (address target, uint256 value, bytes calldata callData) =\\n                executionCalldata.decodeSingle();\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) _execute(target, value, callData);\\n            // TODO: implement event emission for tryExecute singleCall\\n            else if (execType == EXECTYPE_TRY) _tryExecute(target, value, callData);\\n            else revert UnsupportedExecType(execType);\\n        } else if (callType == CALLTYPE_DELEGATECALL) {\\n            // destructure executionCallData according to single exec\\n            address delegate = address(uint160(bytes20(executionCalldata[0:20])));\\n            bytes calldata callData = executionCalldata[20:];\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) _executeDelegatecall(delegate, callData);\\n            else if (execType == EXECTYPE_TRY) _tryExecuteDelegatecall(delegate, callData);\\n            else revert UnsupportedExecType(execType);\\n        } else {\\n            revert UnsupportedCallType(callType);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     * @dev this function is only callable by an installed executor module\\n     * @dev this function demonstrates how to implement\\n     * CallType SINGLE and BATCH and ExecType DEFAULT and TRY\\n     * @dev this function demonstrates how to implement hook support (modifier)\\n     */\\n    function executeFromExecutor(\\n        ModeCode mode,\\n        bytes calldata executionCalldata\\n    )\\n        external\\n        payable\\n        onlyExecutorModule\\n        withHook\\n        returns (\\n            bytes[] memory returnData // TODO returnData is not used\\n        )\\n    {\\n        (CallType callType, ExecType execType,,) = mode.decode();\\n\\n        // check if calltype is batch or single\\n        if (callType == CALLTYPE_BATCH) {\\n            // destructure executionCallData according to batched exec\\n            Execution[] calldata executions = executionCalldata.decodeBatch();\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) returnData = _execute(executions);\\n            else if (execType == EXECTYPE_TRY) returnData = _tryExecute(executions);\\n            else revert UnsupportedExecType(execType);\\n        } else if (callType == CALLTYPE_SINGLE) {\\n            // destructure executionCallData according to single exec\\n            (address target, uint256 value, bytes calldata callData) =\\n                executionCalldata.decodeSingle();\\n            returnData = new bytes[](1);\\n            bool success;\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) {\\n                returnData[0] = _execute(target, value, callData);\\n            }\\n            // TODO: implement event emission for tryExecute singleCall\\n            else if (execType == EXECTYPE_TRY) {\\n                (success, returnData[0]) = _tryExecute(target, value, callData);\\n                if (!success) emit TryExecuteUnsuccessful(0, returnData[0]);\\n            } else {\\n                revert UnsupportedExecType(execType);\\n            }\\n        } else if (callType == CALLTYPE_DELEGATECALL) {\\n            // destructure executionCallData according to single exec\\n            address delegate = address(uint160(bytes20(executionCalldata[0:20])));\\n            bytes calldata callData = executionCalldata[20:];\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) _executeDelegatecall(delegate, callData);\\n            else if (execType == EXECTYPE_TRY) _tryExecuteDelegatecall(delegate, callData);\\n            else revert UnsupportedExecType(execType);\\n        } else {\\n            revert UnsupportedCallType(callType);\\n        }\\n    }\\n\\n    /**\\n     * @dev ERC-4337 executeUserOp according to ERC-4337 v0.7\\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\\n     *      The implementation of the function is OPTIONAL\\n     *\\n     * @param userOp PackedUserOperation struct (see ERC-4337 v0.7+)\\n     */\\n    function executeUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash\\n    )\\n        external\\n        payable\\n        onlyEntryPoint\\n    {\\n        bytes calldata callData = userOp.callData[4:];\\n        (bool success,) = address(this).delegatecall(callData);\\n        if (!success) revert ExecutionFailed();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function installModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata initData\\n    )\\n        external\\n        payable\\n        onlyEntryPointOrSelf\\n        withHook\\n    {\\n        if (!IModule(module).isModuleType(moduleTypeId)) revert MismatchModuleTypeId(moduleTypeId);\\n\\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) _installValidator(module, initData);\\n        else if (moduleTypeId == MODULE_TYPE_EXECUTOR) _installExecutor(module, initData);\\n        else if (moduleTypeId == MODULE_TYPE_FALLBACK) _installFallbackHandler(module, initData);\\n        else if (moduleTypeId == MODULE_TYPE_HOOK) _installHook(module, initData);\\n        else revert UnsupportedModuleType(moduleTypeId);\\n        emit ModuleInstalled(moduleTypeId, module);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function uninstallModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata deInitData\\n    )\\n        external\\n        payable\\n        onlyEntryPointOrSelf\\n        withHook\\n    {\\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\\n            _uninstallValidator(module, deInitData);\\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\\n            _uninstallExecutor(module, deInitData);\\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\\n            _uninstallFallbackHandler(module, deInitData);\\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\\n            _uninstallHook(module, deInitData);\\n        } else {\\n            revert UnsupportedModuleType(moduleTypeId);\\n        }\\n        emit ModuleUninstalled(moduleTypeId, module);\\n    }\\n\\n    /**\\n     * @dev ERC-4337 validateUserOp according to ERC-4337 v0.7\\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\\n     * this validation function should decode / sload the validator module to validate the userOp\\n     * and call it.\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * @param userOp PackedUserOperation struct (see ERC-4337 v0.7+)\\n     */\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 missingAccountFunds\\n    )\\n        external\\n        payable\\n        virtual\\n        onlyEntryPoint\\n        payPrefund(missingAccountFunds)\\n        returns (uint256 validSignature)\\n    {\\n        address validator;\\n        // @notice validator encoding in nonce is just an example!\\n        // @notice this is not part of the standard!\\n        // Account Vendors may choose any other way to implement validator selection\\n        uint256 nonce = userOp.nonce;\\n        assembly {\\n            validator := shr(96, nonce)\\n        }\\n\\n        // check if validator is enabled. If not terminate the validation phase.\\n        if (!_isValidatorInstalled(validator)) return VALIDATION_FAILED;\\n\\n        // bubble up the return value of the validator module\\n        validSignature = IValidator(validator).validateUserOp(userOp, userOpHash);\\n    }\\n\\n    /**\\n     * @dev ERC-1271 isValidSignature\\n     *         This function is intended to be used to validate a smart account signature\\n     * and may forward the call to a validator module\\n     *\\n     * @param hash The hash of the data that is signed\\n     * @param data The data that is signed\\n     */\\n    function isValidSignature(\\n        bytes32 hash,\\n        bytes calldata data\\n    )\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bytes4)\\n    {\\n        address validator = address(bytes20(data[0:20]));\\n        if (!_isValidatorInstalled(validator)) revert InvalidModule(validator);\\n        return IValidator(validator).isValidSignatureWithSender(msg.sender, hash, data[20:]);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function isModuleInstalled(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata additionalContext\\n    )\\n        external\\n        view\\n        override\\n        returns (bool)\\n    {\\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\\n            return _isValidatorInstalled(module);\\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\\n            return _isExecutorInstalled(module);\\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\\n            return _isFallbackHandlerInstalled(abi.decode(additionalContext, (bytes4)), module);\\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\\n            return _isHookInstalled(module);\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function accountId() external view virtual override returns (string memory) {\\n        // vendor.flavour.SemVer\\n        return \\\"uMSA.advanced/withHook.v0.1\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function supportsExecutionMode(ModeCode mode)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bool isSupported)\\n    {\\n        (CallType callType, ExecType execType,,) = mode.decode();\\n        if (callType == CALLTYPE_BATCH) isSupported = true;\\n        else if (callType == CALLTYPE_SINGLE) isSupported = true;\\n        else if (callType == CALLTYPE_DELEGATECALL) isSupported = true;\\n        // if callType is not single, batch or delegatecall return false\\n        else return false;\\n\\n        if (execType == EXECTYPE_DEFAULT) isSupported = true;\\n        else if (execType == EXECTYPE_TRY) isSupported = true;\\n        // if execType is not default or try, return false\\n        else return false;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function supportsModule(uint256 modulTypeId) external view virtual override returns (bool) {\\n        if (modulTypeId == MODULE_TYPE_VALIDATOR) return true;\\n        else if (modulTypeId == MODULE_TYPE_EXECUTOR) return true;\\n        else if (modulTypeId == MODULE_TYPE_FALLBACK) return true;\\n        else if (modulTypeId == MODULE_TYPE_HOOK) return true;\\n        else return false;\\n    }\\n\\n    /**\\n     * @dev Initializes the account. Function might be called directly, or by a Factory\\n     * @param data. encoded data that can be used during the initialization phase\\n     */\\n    function initializeAccount(bytes calldata data) public payable virtual {\\n        // checks if already initialized and reverts before setting the state to initialized\\n        _initModuleManager();\\n\\n        // this is just implemented for demonstration purposes. You can use any other initialization\\n        // logic here.\\n        (address bootstrap, bytes memory bootstrapCall) = abi.decode(data, (address, bytes));\\n        (bool success,) = bootstrap.delegatecall(bootstrapCall);\\n        if (!success) revert();\\n    }\\n}\\n\",\"keccak256\":\"0x4e9527aaf0860dcb4e97c73f282795236672c807b6c3b25f6fa1773071d01ff4\",\"license\":\"MIT\"},\"erc7579/MSAFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { LibClone } from \\\"solady/utils/LibClone.sol\\\";\\nimport { IMSA } from \\\"./interfaces/IMSA.sol\\\";\\n\\ncontract MSAFactory {\\n    address public immutable implementation;\\n\\n    constructor(address _msaImplementation) {\\n        implementation = _msaImplementation;\\n    }\\n\\n    function createAccount(\\n        bytes32 salt,\\n        bytes calldata initCode\\n    )\\n        public\\n        payable\\n        virtual\\n        returns (address)\\n    {\\n        bytes32 _salt = _getSalt(salt, initCode);\\n        (bool alreadyDeployed, address account) =\\n            LibClone.createDeterministicERC1967(msg.value, implementation, _salt);\\n\\n        if (!alreadyDeployed) {\\n            IMSA(account).initializeAccount(initCode);\\n        }\\n        return account;\\n    }\\n\\n    function getAddress(\\n        bytes32 salt,\\n        bytes calldata initcode\\n    )\\n        public\\n        view\\n        virtual\\n        returns (address)\\n    {\\n        bytes32 _salt = _getSalt(salt, initcode);\\n        return LibClone.predictDeterministicAddressERC1967(implementation, _salt, address(this));\\n    }\\n\\n    function _getSalt(\\n        bytes32 _salt,\\n        bytes calldata initCode\\n    )\\n        public\\n        pure\\n        virtual\\n        returns (bytes32 salt)\\n    {\\n        salt = keccak256(abi.encodePacked(_salt, initCode));\\n    }\\n}\\n\",\"keccak256\":\"0x59cf4ab16a3c0ce97f3b619be9521292628d21539783ed1b057d45f08c488dd6\",\"license\":\"MIT\"},\"erc7579/core/AccountBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\n/**\\n * @title reference implementation of the minimal modular smart account with Hook Extension\\n * @author zeroknots.eth | rhinestone.wtf\\n */\\ncontract AccountBase {\\n    error AccountAccessUnauthorized();\\n\\n    /////////////////////////////////////////////////////\\n    // Access Control\\n    ////////////////////////////////////////////////////\\n\\n    modifier onlyEntryPointOrSelf() virtual {\\n        if (!(msg.sender == entryPoint() || msg.sender == address(this))) {\\n            revert AccountAccessUnauthorized();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyEntryPoint() virtual {\\n        if (msg.sender != entryPoint()) {\\n            revert AccountAccessUnauthorized();\\n        }\\n        _;\\n    }\\n\\n    function entryPoint() public view virtual returns (address) {\\n        return 0x0000000071727De22E5E9d8BAf0edAc6f37da032;\\n    }\\n\\n    /// @dev Sends to the EntryPoint (i.e. `msg.sender`) the missing funds for this transaction.\\n    /// Subclass MAY override this modifier for better funds management.\\n    /// (e.g. send to the EntryPoint more than the minimum required, so that in future transactions\\n    /// it will not be required to send again)\\n    ///\\n    /// `missingAccountFunds` is the minimum value this modifier should send the EntryPoint,\\n    /// which MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\\n    modifier payPrefund(uint256 missingAccountFunds) virtual {\\n        _;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if missingAccountFunds {\\n                // Ignore failure (it's EntryPoint's job to verify, not the account's).\\n                pop(call(gas(), caller(), missingAccountFunds, codesize(), 0x00, codesize(), 0x00))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x11805c609cfd00250d52f440983ea54daaddc2d2bd0da83676ffef6192fecb82\",\"license\":\"MIT\"},\"erc7579/core/ExecutionHelper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { Execution } from \\\"../interfaces/IERC7579Account.sol\\\";\\n\\n/**\\n * @title Execution\\n * @dev This contract executes calls in the context of this contract.\\n * @author zeroknots.eth | rhinestone.wtf\\n * shoutout to solady (vectorized, ross) for this code\\n * https://github.com/Vectorized/solady/blob/main/src/accounts/ERC4337.sol\\n */\\ncontract ExecutionHelper {\\n    error ExecutionFailed();\\n\\n    event TryExecuteUnsuccessful(uint256 batchExecutionindex, bytes result);\\n\\n    function _execute(Execution[] calldata executions) internal returns (bytes[] memory result) {\\n        uint256 length = executions.length;\\n        result = new bytes[](length);\\n\\n        for (uint256 i; i < length; i++) {\\n            Execution calldata _exec = executions[i];\\n            result[i] = _execute(_exec.target, _exec.value, _exec.callData);\\n        }\\n    }\\n\\n    function _tryExecute(Execution[] calldata executions)\\n        internal\\n        returns (bytes[] memory result)\\n    {\\n        uint256 length = executions.length;\\n        result = new bytes[](length);\\n\\n        for (uint256 i; i < length; i++) {\\n            Execution calldata _exec = executions[i];\\n            bool success;\\n            (success, result[i]) = _tryExecute(_exec.target, _exec.value, _exec.callData);\\n            if (!success) emit TryExecuteUnsuccessful(i, result[i]);\\n        }\\n    }\\n\\n    function _execute(\\n        address target,\\n        uint256 value,\\n        bytes calldata callData\\n    )\\n        internal\\n        virtual\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, callData.offset, callData.length)\\n            if iszero(call(gas(), target, value, result, callData.length, codesize(), 0x00)) {\\n                // Bubble up the revert if the call reverts.\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n\\n    function _tryExecute(\\n        address target,\\n        uint256 value,\\n        bytes calldata callData\\n    )\\n        internal\\n        virtual\\n        returns (bool success, bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, callData.offset, callData.length)\\n            success := call(gas(), target, value, result, callData.length, codesize(), 0x00)\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Execute a delegatecall with `delegate` on this account.\\n    function _executeDelegatecall(\\n        address delegate,\\n        bytes calldata callData\\n    )\\n        internal\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, callData.offset, callData.length)\\n            // Forwards the `data` to `delegate` via delegatecall.\\n            if iszero(delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)) {\\n                // Bubble up the revert if the call reverts.\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Execute a delegatecall with `delegate` on this account and catch reverts.\\n    function _tryExecuteDelegatecall(\\n        address delegate,\\n        bytes calldata callData\\n    )\\n        internal\\n        returns (bool success, bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, callData.offset, callData.length)\\n            // Forwards the `data` to `delegate` via delegatecall.\\n            success := delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa8ccc4cdddbcbb51594644a6a3b96657bae861da6461a149ca8e4c2678da0b20\",\"license\":\"MIT\"},\"erc7579/core/HookManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport \\\"./ModuleManager.sol\\\";\\nimport \\\"../interfaces/IERC7579Account.sol\\\";\\nimport \\\"../interfaces/IERC7579Module.sol\\\";\\n\\n/**\\n * @title reference implementation of HookManager\\n * @author zeroknots.eth | rhinestone.wtf\\n */\\nabstract contract HookManager {\\n    /// @custom:storage-location erc7201:hookmanager.storage.msa\\n    struct HookManagerStorage {\\n        IHook _hook;\\n    }\\n\\n    // keccak256(\\\"hookmanager.storage.msa\\\");\\n    bytes32 constant HOOKMANAGER_STORAGE_LOCATION =\\n        0x36e05829dd1b9a4411d96a3549582172d7f071c1c0db5c573fcf94eb28431608;\\n\\n    error HookPostCheckFailed();\\n    error HookAlreadyInstalled(address currentHook);\\n\\n    modifier withHook() {\\n        address hook = _getHook();\\n        if (hook == address(0)) {\\n            _;\\n        } else {\\n            bytes memory hookData = IHook(hook).preCheck(msg.sender, msg.value, msg.data);\\n            _;\\n            IHook(hook).postCheck(hookData);\\n        }\\n    }\\n\\n    function _setHook(address hook) internal virtual {\\n        bytes32 slot = HOOKMANAGER_STORAGE_LOCATION;\\n        assembly {\\n            sstore(slot, hook)\\n        }\\n    }\\n\\n    function _installHook(address hook, bytes calldata data) internal virtual {\\n        address currentHook = _getHook();\\n        if (currentHook != address(0)) {\\n            revert HookAlreadyInstalled(currentHook);\\n        }\\n        _setHook(hook);\\n        IHook(hook).onInstall(data);\\n    }\\n\\n    function _uninstallHook(address hook, bytes calldata data) internal virtual {\\n        _setHook(address(0));\\n        IHook(hook).onUninstall(data);\\n    }\\n\\n    function _getHook() internal view returns (address _hook) {\\n        bytes32 slot = HOOKMANAGER_STORAGE_LOCATION;\\n        assembly {\\n            _hook := sload(slot)\\n        }\\n    }\\n\\n    function _isHookInstalled(address module) internal view returns (bool) {\\n        return _getHook() == module;\\n    }\\n\\n    function getActiveHook() external view returns (address hook) {\\n        return _getHook();\\n    }\\n}\\n\",\"keccak256\":\"0xea44de4892ede553b9642b7bbcfe35745e5129d5a02bd04c90cfa2e15c5ece77\",\"license\":\"MIT\"},\"erc7579/core/ModuleManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { SentinelListLib, SENTINEL } from \\\"sentinellist/SentinelList.sol\\\";\\nimport {\\n    CallType, CALLTYPE_SINGLE, CALLTYPE_DELEGATECALL, CALLTYPE_STATIC\\n} from \\\"../lib/ModeLib.sol\\\";\\nimport { AccountBase } from \\\"./AccountBase.sol\\\";\\nimport \\\"../interfaces/IERC7579Module.sol\\\";\\nimport \\\"forge-std/interfaces/IERC165.sol\\\";\\nimport \\\"./Receiver.sol\\\";\\n\\n/**\\n * @title ModuleManager\\n * @author zeroknots.eth | rhinestone.wtf\\n * @dev This contract manages Validator, Executor and Fallback modules for the MSA\\n * @dev it uses SentinelList to manage the linked list of modules\\n * NOTE: the linked list is just an example. accounts may implement this differently\\n */\\nabstract contract ModuleManager is AccountBase, Receiver {\\n    using SentinelListLib for SentinelListLib.SentinelList;\\n\\n    error InvalidModule(address module);\\n    error NoFallbackHandler(bytes4 selector);\\n    error CannotRemoveLastValidator();\\n\\n    // keccak256(\\\"modulemanager.storage.msa\\\");\\n    bytes32 internal constant MODULEMANAGER_STORAGE_LOCATION =\\n        0xf88ce1fdb7fb1cbd3282e49729100fa3f2d6ee9f797961fe4fb1871cea89ea02;\\n\\n    struct FallbackHandler {\\n        address handler;\\n        CallType calltype;\\n    }\\n\\n    /// @custom:storage-location erc7201:modulemanager.storage.msa\\n    struct ModuleManagerStorage {\\n        // linked list of validators. List is initialized by initializeAccount()\\n        SentinelListLib.SentinelList $valdiators;\\n        // linked list of executors. List is initialized by initializeAccount()\\n        SentinelListLib.SentinelList $executors;\\n        // single fallback handler for all fallbacks\\n        // account vendors may implement this differently. This is just a reference implementation\\n        mapping(bytes4 selector => FallbackHandler fallbackHandler) $fallbacks;\\n    }\\n\\n    function $moduleManager() internal pure virtual returns (ModuleManagerStorage storage $ims) {\\n        bytes32 position = MODULEMANAGER_STORAGE_LOCATION;\\n        assembly {\\n            $ims.slot := position\\n        }\\n    }\\n\\n    modifier onlyExecutorModule() {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\\n        if (!$executors.contains(msg.sender)) revert InvalidModule(msg.sender);\\n        _;\\n    }\\n\\n    modifier onlyValidatorModule(address validator) {\\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\\n        if (!$valdiators.contains(validator)) revert InvalidModule(validator);\\n        _;\\n    }\\n\\n    function _initModuleManager() internal virtual {\\n        ModuleManagerStorage storage $ims = $moduleManager();\\n        $ims.$executors.init();\\n        $ims.$valdiators.init();\\n    }\\n\\n    function isAlreadyInitialized() internal view virtual returns (bool) {\\n        ModuleManagerStorage storage $ims = $moduleManager();\\n        return $ims.$valdiators.alreadyInitialized();\\n    }\\n\\n    /////////////////////////////////////////////////////\\n    //  Manage Validators\\n    ////////////////////////////////////////////////////\\n    function _installValidator(address validator, bytes calldata data) internal virtual {\\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\\n        $valdiators.push(validator);\\n        IValidator(validator).onInstall(data);\\n    }\\n\\n    function _uninstallValidator(address validator, bytes calldata data) internal {\\n        // TODO: check if its the last validator. this might brick the account\\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\\n        (address prev, bytes memory disableModuleData) = abi.decode(data, (address, bytes));\\n        $valdiators.pop(prev, validator);\\n        IValidator(validator).onUninstall(disableModuleData);\\n    }\\n\\n    function _isValidatorInstalled(address validator) internal view virtual returns (bool) {\\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\\n        return $valdiators.contains(validator);\\n    }\\n\\n    /**\\n     * THIS IS NOT PART OF THE STANDARD\\n     * Helper Function to access linked list\\n     */\\n    function getValidatorPaginated(\\n        address cursor,\\n        uint256 size\\n    )\\n        external\\n        view\\n        virtual\\n        returns (address[] memory array, address next)\\n    {\\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\\n        return $valdiators.getEntriesPaginated(cursor, size);\\n    }\\n\\n    /////////////////////////////////////////////////////\\n    //  Manage Executors\\n    ////////////////////////////////////////////////////\\n\\n    function _installExecutor(address executor, bytes calldata data) internal {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\\n        $executors.push(executor);\\n        IExecutor(executor).onInstall(data);\\n    }\\n\\n    function _uninstallExecutor(address executor, bytes calldata data) internal {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\\n        (address prev, bytes memory disableModuleData) = abi.decode(data, (address, bytes));\\n        $executors.pop(prev, executor);\\n        IExecutor(executor).onUninstall(disableModuleData);\\n    }\\n\\n    function _isExecutorInstalled(address executor) internal view virtual returns (bool) {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\\n        return $executors.contains(executor);\\n    }\\n\\n    /**\\n     * THIS IS NOT PART OF THE STANDARD\\n     * Helper Function to access linked list\\n     */\\n    function getExecutorsPaginated(\\n        address cursor,\\n        uint256 size\\n    )\\n        external\\n        view\\n        virtual\\n        returns (address[] memory array, address next)\\n    {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\\n        return $executors.getEntriesPaginated(cursor, size);\\n    }\\n\\n    /////////////////////////////////////////////////////\\n    //  Manage Fallback\\n    ////////////////////////////////////////////////////\\n\\n    function _installFallbackHandler(address handler, bytes calldata params) internal virtual {\\n        bytes4 selector = bytes4(params[0:4]);\\n        CallType calltype = CallType.wrap(bytes1(params[4]));\\n        bytes memory initData = params[5:];\\n\\n        if (_isFallbackHandlerInstalled(selector)) {\\n            revert(\\\"Function selector already used\\\");\\n        }\\n        $moduleManager().$fallbacks[selector] = FallbackHandler(handler, calltype);\\n        IFallback(handler).onInstall(initData);\\n    }\\n\\n    function _uninstallFallbackHandler(\\n        address handler,\\n        bytes calldata deInitData\\n    )\\n        internal\\n        virtual\\n    {\\n        bytes4 selector = bytes4(deInitData[0:4]);\\n        bytes memory _deInitData = deInitData[4:];\\n\\n        if (!_isFallbackHandlerInstalled(selector)) {\\n            revert(\\\"Function selector not used\\\");\\n        }\\n\\n        FallbackHandler memory activeFallback = $moduleManager().$fallbacks[selector];\\n\\n        if (activeFallback.handler != handler) {\\n            revert(\\\"Function selector not used by this handler\\\");\\n        }\\n\\n        CallType callType = activeFallback.calltype;\\n\\n        $moduleManager().$fallbacks[selector] = FallbackHandler(address(0), CallType.wrap(0x00));\\n\\n        IFallback(handler).onUninstall(_deInitData);\\n    }\\n\\n    function _isFallbackHandlerInstalled(bytes4 functionSig) internal view virtual returns (bool) {\\n        FallbackHandler storage $fallback = $moduleManager().$fallbacks[functionSig];\\n        return $fallback.handler != address(0);\\n    }\\n\\n    function _isFallbackHandlerInstalled(\\n        bytes4 functionSig,\\n        address _handler\\n    )\\n        internal\\n        view\\n        virtual\\n        returns (bool)\\n    {\\n        FallbackHandler storage $fallback = $moduleManager().$fallbacks[functionSig];\\n        return $fallback.handler == _handler;\\n    }\\n\\n    function getActiveFallbackHandler(bytes4 functionSig)\\n        external\\n        view\\n        virtual\\n        returns (FallbackHandler memory)\\n    {\\n        return $moduleManager().$fallbacks[functionSig];\\n    }\\n\\n    // FALLBACK\\n    fallback() external payable override(Receiver) receiverFallback {\\n        FallbackHandler storage $fallbackHandler = $moduleManager().$fallbacks[msg.sig];\\n        address handler = $fallbackHandler.handler;\\n        CallType calltype = $fallbackHandler.calltype;\\n        if (handler == address(0)) revert NoFallbackHandler(msg.sig);\\n\\n        if (calltype == CALLTYPE_STATIC) {\\n            assembly {\\n                function allocate(length) -> pos {\\n                    pos := mload(0x40)\\n                    mstore(0x40, add(pos, length))\\n                }\\n\\n                let calldataPtr := allocate(calldatasize())\\n                calldatacopy(calldataPtr, 0, calldatasize())\\n\\n                // The msg.sender address is shifted to the left by 12 bytes to remove the padding\\n                // Then the address without padding is stored right after the calldata\\n                let senderPtr := allocate(20)\\n                mstore(senderPtr, shl(96, caller()))\\n\\n                // Add 20 bytes for the address appended add the end\\n                let success :=\\n                    staticcall(gas(), handler, calldataPtr, add(calldatasize(), 20), 0, 0)\\n\\n                let returnDataPtr := allocate(returndatasize())\\n                returndatacopy(returnDataPtr, 0, returndatasize())\\n                if iszero(success) { revert(returnDataPtr, returndatasize()) }\\n                return(returnDataPtr, returndatasize())\\n            }\\n        }\\n        if (calltype == CALLTYPE_SINGLE) {\\n            assembly {\\n                function allocate(length) -> pos {\\n                    pos := mload(0x40)\\n                    mstore(0x40, add(pos, length))\\n                }\\n\\n                let calldataPtr := allocate(calldatasize())\\n                calldatacopy(calldataPtr, 0, calldatasize())\\n\\n                // The msg.sender address is shifted to the left by 12 bytes to remove the padding\\n                // Then the address without padding is stored right after the calldata\\n                let senderPtr := allocate(20)\\n                mstore(senderPtr, shl(96, caller()))\\n\\n                // Add 20 bytes for the address appended add the end\\n                let success := call(gas(), handler, 0, calldataPtr, add(calldatasize(), 20), 0, 0)\\n\\n                let returnDataPtr := allocate(returndatasize())\\n                returndatacopy(returnDataPtr, 0, returndatasize())\\n                if iszero(success) { revert(returnDataPtr, returndatasize()) }\\n                return(returnDataPtr, returndatasize())\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe74e93d4912692c5fc816e8706030eb8401ec8b862c98c3566230dfd3ed8791f\",\"license\":\"MIT\"},\"erc7579/core/Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/**\\n * @title Receiver\\n * @dev This contract receives safe-transferred ERC721 and ERC1155 tokens.\\n * @author Modified from Solady\\n * (https://github.com/Vectorized/solady/blob/main/src/accounts/Receiver.sol)\\n */\\nabstract contract Receiver {\\n    /// @dev For receiving ETH.\\n    receive() external payable virtual { }\\n\\n    /// @dev Fallback function with the `receiverFallback` modifier.\\n    fallback() external payable virtual receiverFallback { }\\n\\n    /// @dev Modifier for the fallback function to handle token callbacks.\\n    modifier receiverFallback() virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := shr(224, calldataload(0))\\n            // 0x150b7a02: `onERC721Received(address,address,uint256,bytes)`.\\n            // 0xf23a6e61: `onERC1155Received(address,address,uint256,uint256,bytes)`.\\n            // 0xbc197c81: `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\\n            if or(eq(s, 0x150b7a02), or(eq(s, 0xf23a6e61), eq(s, 0xbc197c81))) {\\n                mstore(0x20, s) // Store `msg.sig`.\\n                return(0x3c, 0x20) // Return `msg.sig`.\\n            }\\n        }\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x42d41b30a6582d95d737fd75122b621a8af1ec3123782d91a29385b67612b9e4\",\"license\":\"MIT\"},\"erc7579/interfaces/IERC4337Account.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { PackedUserOperation } from \\\"account-abstraction/interfaces/PackedUserOperation.sol\\\";\\n\\ninterface IERC4337Account {\\n    /**\\n     * Validate user's signature and nonce\\n     * the entryPoint will make the call to the recipient only if this validation call returns\\n     * successfully.\\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\\n     * This allows making a \\\"simulation call\\\" without a valid signature\\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to\\n     * signal failure.\\n     *\\n     * @dev Must validate caller is the entryPoint.\\n     *      Must validate the signature and nonce\\n     * @param userOp              - The operation that is about to be executed.\\n     * @param userOpHash          - Hash of the user's request data. can be used as the basis for\\n     * signature.\\n     * @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\\n     *                              This is the minimum amount to transfer to the sender(entryPoint)\\n     * to be\\n     *                              able to make the call. The excess is left as a deposit in the\\n     * entrypoint\\n     *                              for future calls. Can be withdrawn anytime using\\n     * \\\"entryPoint.withdrawTo()\\\".\\n     *                              In case there is a paymaster in the request (or the current\\n     * deposit is high\\n     *                              enough), this value will be zero.\\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData`\\n     * and\\n     *                              `_unpackValidationData` to encode and decode.\\n     *                              <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark\\n     * signature failure,\\n     *                                 otherwise, an address of an \\\"authorizer\\\" contract.\\n     *                              <6-byte> validUntil - Last timestamp this operation is valid. 0\\n     * for \\\"indefinite\\\"\\n     *                              <6-byte> validAfter - First timestamp this operation is valid\\n     *                                                    If an account doesn't use time-range, it\\n     * is enough to\\n     *                                                    return SIG_VALIDATION_FAILED value (1) for\\n     * signature failure.\\n     *                              Note that the validation code cannot use block.timestamp (or\\n     * block.number) directly.\\n     */\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 missingAccountFunds\\n    )\\n        external\\n        payable\\n        returns (uint256 validationData);\\n\\n    /**\\n     * Account may implement this execute method.\\n     * passing this methodSig at the beginning of callData will cause the entryPoint to pass the\\n     * full UserOp (and hash)\\n     * to the account.\\n     * The account should skip the methodSig, and use the callData (and optionally, other UserOp\\n     * fields)\\n     *\\n     * @param userOp              - The operation that was just validated.\\n     * @param userOpHash          - Hash of the user's request data.\\n     */\\n    function executeUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash\\n    )\\n        external\\n        payable;\\n}\\n\",\"keccak256\":\"0x55f4a9fe65535a8b3f6db727c764aad1eb237a22828f2565941d0c079e9b7e3e\",\"license\":\"MIT\"},\"erc7579/interfaces/IERC7579Account.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { CallType, ExecType, ModeCode } from \\\"../lib/ModeLib.sol\\\";\\n\\nstruct Execution {\\n    address target;\\n    uint256 value;\\n    bytes callData;\\n}\\n\\ninterface IERC7579Account {\\n    event ModuleInstalled(uint256 moduleTypeId, address module);\\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\\n\\n    /**\\n     * @dev Executes a transaction on behalf of the account.\\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * If a mode is requested that is not supported by the Account, it MUST revert\\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\\n     * @param executionCalldata The encoded execution call data\\n     */\\n    function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\\n\\n    /**\\n     * @dev Executes a transaction on behalf of the account.\\n     *         This function is intended to be called by Executor Modules\\n     * @dev Ensure adequate authorization control: i.e. onlyExecutorModule\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * If a mode is requested that is not supported by the Account, it MUST revert\\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\\n     * @param executionCalldata The encoded execution call data\\n     */\\n    function executeFromExecutor(\\n        ModeCode mode,\\n        bytes calldata executionCalldata\\n    )\\n        external\\n        payable\\n        returns (bytes[] memory returnData);\\n\\n    /**\\n     * @dev ERC-1271 isValidSignature\\n     *         This function is intended to be used to validate a smart account signature\\n     * and may forward the call to a validator module\\n     *\\n     * @param hash The hash of the data that is signed\\n     * @param data The data that is signed\\n     */\\n    function isValidSignature(bytes32 hash, bytes calldata data) external view returns (bytes4);\\n\\n    /**\\n     * @dev installs a Module of a certain type on the smart account\\n     * @dev Implement Authorization control of your chosing\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     * @param module the module address\\n     * @param initData arbitrary data that may be required on the module during `onInstall`\\n     * initialization.\\n     */\\n    function installModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata initData\\n    )\\n        external\\n        payable;\\n\\n    /**\\n     * @dev uninstalls a Module of a certain type on the smart account\\n     * @dev Implement Authorization control of your chosing\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     * @param module the module address\\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\\n     * de-initialization.\\n     */\\n    function uninstallModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata deInitData\\n    )\\n        external\\n        payable;\\n\\n    /**\\n     * Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\\n     * @param encodedMode the encoded mode\\n     */\\n    function supportsExecutionMode(ModeCode encodedMode) external view returns (bool);\\n\\n    /**\\n     * Function to check if the account supports installation of a certain module type Id\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     */\\n    function supportsModule(uint256 moduleTypeId) external view returns (bool);\\n\\n    /**\\n     * Function to check if the account has a certain module installed\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\\n     *            thus may be necessary to query multiple module types\\n     * @param module the module address\\n     * @param additionalContext additional context data that the smart account may interpret to\\n     *                          identifiy conditions under which the module is installed.\\n     *                          usually this is not necessary, but for some special hooks that\\n     *                          are stored in mappings, this param might be needed\\n     */\\n    function isModuleInstalled(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata additionalContext\\n    )\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the account id of the smart account\\n     * @return accountImplementationId the account id of the smart account\\n     * the accountId should be structured like so:\\n     *        \\\"vendorname.accountname.semver\\\"\\n     */\\n    function accountId() external view returns (string memory accountImplementationId);\\n}\\n\",\"keccak256\":\"0x08368aba5f1bb83eb57e9f8d31a04edee4be69159b4844a6443f65100917011c\",\"license\":\"MIT\"},\"erc7579/interfaces/IERC7579Module.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { PackedUserOperation } from \\\"account-abstraction/interfaces/PackedUserOperation.sol\\\";\\n\\nuint256 constant VALIDATION_SUCCESS = 0;\\nuint256 constant VALIDATION_FAILED = 1;\\n\\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\\nuint256 constant MODULE_TYPE_FALLBACK = 3;\\nuint256 constant MODULE_TYPE_HOOK = 4;\\n\\ninterface IModule {\\n    error AlreadyInitialized(address smartAccount);\\n    error NotInitialized(address smartAccount);\\n\\n    /**\\n     * @dev This function is called by the smart account during installation of the module\\n     * @param data arbitrary data that may be required on the module during `onInstall`\\n     * initialization\\n     *\\n     * MUST revert on error (i.e. if module is already enabled)\\n     */\\n    function onInstall(bytes calldata data) external;\\n\\n    /**\\n     * @dev This function is called by the smart account during uninstallation of the module\\n     * @param data arbitrary data that may be required on the module during `onUninstall`\\n     * de-initialization\\n     *\\n     * MUST revert on error\\n     */\\n    function onUninstall(bytes calldata data) external;\\n\\n    /**\\n     * @dev Returns boolean value if module is a certain type\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     *\\n     * MUST return true if the module is of the given type and false otherwise\\n     */\\n    function isModuleType(uint256 moduleTypeId) external view returns (bool);\\n\\n    /**\\n     * @dev Returns if the module was already initialized for a provided smartaccount\\n     */\\n    function isInitialized(address smartAccount) external view returns (bool);\\n}\\n\\ninterface IValidator is IModule {\\n    error InvalidTargetAddress(address target);\\n\\n    /**\\n     * @dev Validates a transaction on behalf of the account.\\n     *         This function is intended to be called by the MSA during the ERC-4337 validaton phase\\n     *         Note: solely relying on bytes32 hash and signature is not suffcient for some\\n     * validation implementations (i.e. SessionKeys often need access to userOp.calldata)\\n     * @param userOp The user operation to be validated. The userOp MUST NOT contain any metadata.\\n     * The MSA MUST clean up the userOp before sending it to the validator.\\n     * @param userOpHash The hash of the user operation to be validated\\n     * @return return value according to ERC-4337\\n     */\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash\\n    )\\n        external\\n        returns (uint256);\\n\\n    /**\\n     * Validator can be used for ERC-1271 validation\\n     */\\n    function isValidSignatureWithSender(\\n        address sender,\\n        bytes32 hash,\\n        bytes calldata data\\n    )\\n        external\\n        view\\n        returns (bytes4);\\n}\\n\\ninterface IExecutor is IModule { }\\n\\ninterface IHook is IModule {\\n    function preCheck(\\n        address msgSender,\\n        uint256 msgValue,\\n        bytes calldata msgData\\n    )\\n        external\\n        returns (bytes memory hookData);\\n\\n    function postCheck(bytes calldata hookData) external;\\n}\\n\\ninterface IFallback is IModule { }\\n\",\"keccak256\":\"0x78ab984fc364972382a73a0d793c558f52800999d5e0e69c4df326a1de840604\",\"license\":\"MIT\"},\"erc7579/interfaces/IMSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { IERC7579Account } from \\\"./IERC7579Account.sol\\\";\\nimport { IERC4337Account } from \\\"./IERC4337Account.sol\\\";\\n\\nimport { CallType, ExecType, ModeCode } from \\\"../lib/ModeLib.sol\\\";\\n\\ninterface IMSA is IERC7579Account, IERC4337Account {\\n    // Error thrown when an unsupported ModuleType is requested\\n    error UnsupportedModuleType(uint256 moduleTypeId);\\n    // Error thrown when an execution with an unsupported CallType was made\\n    error UnsupportedCallType(CallType callType);\\n    // Error thrown when an execution with an unsupported ExecType was made\\n    error UnsupportedExecType(ExecType execType);\\n    // Error thrown when account initialization fails\\n    error AccountInitializationFailed();\\n    // Error thrown when account installs/unistalls module with mismatched input `moduleTypeId`\\n    error MismatchModuleTypeId(uint256 moduleTypeId);\\n\\n    /**\\n     * @dev Initializes the account. Function might be called directly, or by a Factory\\n     * @param data. encoded data that can be used during the initialization phase\\n     */\\n    function initializeAccount(bytes calldata data) external payable;\\n}\\n\",\"keccak256\":\"0x649ef44dfc5ba9b485b31cda765335e96f35aa6e595fd8d86c28a62aa8982cbe\",\"license\":\"MIT\"},\"erc7579/lib/ExecutionLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { Execution } from \\\"../interfaces/IERC7579Account.sol\\\";\\n\\n/**\\n * Helper Library for decoding Execution calldata\\n * malloc for memory allocation is bad for gas. use this assembly instead\\n */\\nlibrary ExecutionLib {\\n    function decodeBatch(bytes calldata callData)\\n        internal\\n        pure\\n        returns (Execution[] calldata executionBatch)\\n    {\\n        /*\\n         * Batch Call Calldata Layout\\n         * Offset (in bytes)    | Length (in bytes) | Contents\\n         * 0x0                  | 0x4               | bytes4 function selector\\n        *  0x4                  | -                 |\\n        abi.encode(IERC7579Execution.Execution[])\\n         */\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            let dataPointer := add(callData.offset, calldataload(callData.offset))\\n\\n            // Extract the ERC7579 Executions\\n            executionBatch.offset := add(dataPointer, 32)\\n            executionBatch.length := calldataload(dataPointer)\\n        }\\n    }\\n\\n    function encodeBatch(Execution[] memory executions)\\n        internal\\n        pure\\n        returns (bytes memory callData)\\n    {\\n        callData = abi.encode(executions);\\n    }\\n\\n    function decodeSingle(bytes calldata executionCalldata)\\n        internal\\n        pure\\n        returns (address target, uint256 value, bytes calldata callData)\\n    {\\n        target = address(bytes20(executionCalldata[0:20]));\\n        value = uint256(bytes32(executionCalldata[20:52]));\\n        callData = executionCalldata[52:];\\n    }\\n\\n    function encodeSingle(\\n        address target,\\n        uint256 value,\\n        bytes memory callData\\n    )\\n        internal\\n        pure\\n        returns (bytes memory userOpCalldata)\\n    {\\n        userOpCalldata = abi.encodePacked(target, value, callData);\\n    }\\n}\\n\",\"keccak256\":\"0xa6d41aa7532a4bff83a8c335a8050ebe0c7a73c456d70594d2123dc293892c5c\",\"license\":\"MIT\"},\"erc7579/lib/ModeLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/**\\n * @title ModeLib\\n * To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\\n * encoding is used.\\n *    Function Signature of execute function:\\n *           function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\\n * This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\\n * context.\\n * NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\\n * implement\\n * more complex execution modes may use the entire bytes32.\\n *\\n * |--------------------------------------------------------------------|\\n * | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\\n * |--------------------------------------------------------------------|\\n * | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\\n * |--------------------------------------------------------------------|\\n *\\n * CALLTYPE: 1 byte\\n * CallType is used to determine how the executeCalldata paramter of the execute function has to be\\n * decoded.\\n * It can be either single, batch or delegatecall. In the future different calls could be added.\\n * CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\\n *\\n * EXECTYPE: 1 byte\\n * ExecType is used to determine how the account should handle the execution.\\n * It can indicate if the execution should revert on failure or continue execution.\\n * In the future more execution modes may be added.\\n * Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\\n * a batch fails, the entire batch is reverted\\n *\\n * UNUSED: 4 bytes\\n * Unused bytes are reserved for future use.\\n *\\n * ModeSelector: bytes4\\n * The \\\"optional\\\" mode selector can be used by account vendors, to implement custom behavior in\\n * their accounts.\\n * the way a ModeSelector is to be calculated is bytes4(keccak256(\\\"vendorname.featurename\\\"))\\n * this is to prevent collisions between different vendors, while allowing innovation and the\\n * development of new features without coordination between ERC-7579 implementing accounts\\n *\\n * ModePayload: 22 bytes\\n * Mode payload is used to pass additional data to the smart account execution, this may be\\n * interpreted depending on the ModeSelector\\n *\\n * ExecutionCallData: n bytes\\n * single, delegatecall or batch exec abi.encoded as bytes\\n */\\nimport { Execution } from \\\"../interfaces/IERC7579Account.sol\\\";\\n\\n// Custom type for improved developer experience\\ntype ModeCode is bytes32;\\n\\ntype CallType is bytes1;\\n\\ntype ExecType is bytes1;\\n\\ntype ModeSelector is bytes4;\\n\\ntype ModePayload is bytes22;\\n\\n// Default CallType\\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\\n// Batched CallType\\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\\n// @dev Implementing delegatecall is OPTIONAL!\\n// implement delegatecall with extreme care.\\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\\n\\n// @dev default behavior is to revert on failure\\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\\n// Since this is value 0x00, no additional encoding is required for simple accounts\\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\\n// @dev account may elect to change execution behavior. For example \\\"try exec\\\" / \\\"allow fail\\\"\\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\\n\\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\\n// Example declaration of a custom mode selector\\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\\\"default.mode.offset\\\")));\\n\\n/**\\n * @dev ModeLib is a helper library to encode/decode ModeCodes\\n */\\nlibrary ModeLib {\\n    function decode(ModeCode mode)\\n        internal\\n        pure\\n        returns (\\n            CallType _calltype,\\n            ExecType _execType,\\n            ModeSelector _modeSelector,\\n            ModePayload _modePayload\\n        )\\n    {\\n        assembly {\\n            _calltype := mode\\n            _execType := shl(8, mode)\\n            _modeSelector := shl(48, mode)\\n            _modePayload := shl(80, mode)\\n        }\\n    }\\n\\n    function encode(\\n        CallType callType,\\n        ExecType execType,\\n        ModeSelector mode,\\n        ModePayload payload\\n    )\\n        internal\\n        pure\\n        returns (ModeCode)\\n    {\\n        return ModeCode.wrap(\\n            bytes32(\\n                abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)\\n            )\\n        );\\n    }\\n\\n    function encodeSimpleBatch() internal pure returns (ModeCode mode) {\\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\\n    }\\n\\n    function encodeSimpleSingle() internal pure returns (ModeCode mode) {\\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\\n    }\\n\\n    function getCallType(ModeCode mode) internal pure returns (CallType calltype) {\\n        assembly {\\n            calltype := mode\\n        }\\n    }\\n}\\n\\nusing { eqModeSelector as == } for ModeSelector global;\\nusing { eqCallType as == } for CallType global;\\nusing { eqExecType as == } for ExecType global;\\n\\nfunction eqCallType(CallType a, CallType b) pure returns (bool) {\\n    return CallType.unwrap(a) == CallType.unwrap(b);\\n}\\n\\nfunction eqExecType(ExecType a, ExecType b) pure returns (bool) {\\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\\n}\\n\\nfunction eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\\n}\\n\",\"keccak256\":\"0x02ce0fc8805d1427841f32e2335157e3fae18e99d5c49ba46d53e12fcd1a5185\",\"license\":\"MIT\"},\"erc7579/utils/Bootstrap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport \\\"../core/ModuleManager.sol\\\";\\nimport \\\"../core/HookManager.sol\\\";\\n\\nimport \\\"../interfaces/IERC7579Module.sol\\\";\\n\\nstruct BootstrapConfig {\\n    address module;\\n    bytes data;\\n}\\n\\ncontract Bootstrap is ModuleManager, HookManager {\\n    function singleInitMSA(IModule validator, bytes calldata data) external {\\n        // init validator\\n        _installValidator(address(validator), data);\\n    }\\n\\n    /**\\n     * This function is intended to be called by the MSA with a delegatecall.\\n     * Make sure that the MSA already initilazed the linked lists in the ModuleManager prior to\\n     * calling this function\\n     */\\n    function initMSA(\\n        BootstrapConfig[] calldata $valdiators,\\n        BootstrapConfig[] calldata $executors,\\n        BootstrapConfig calldata _hook,\\n        BootstrapConfig[] calldata _fallbacks\\n    )\\n        external\\n    {\\n        // init validators\\n        for (uint256 i; i < $valdiators.length; i++) {\\n            _installValidator($valdiators[i].module, $valdiators[i].data);\\n        }\\n\\n        // init executors\\n        for (uint256 i; i < $executors.length; i++) {\\n            if ($executors[i].module == address(0)) continue;\\n            _installExecutor($executors[i].module, $executors[i].data);\\n        }\\n\\n        // init hook\\n        if (_hook.module != address(0)) {\\n            _installHook(_hook.module, _hook.data);\\n        }\\n\\n        // init fallback\\n        for (uint256 i; i < _fallbacks.length; i++) {\\n            if (_fallbacks[i].module == address(0)) continue;\\n            _installFallbackHandler(_fallbacks[i].module, _fallbacks[i].data);\\n        }\\n    }\\n\\n    function _getInitMSACalldata(\\n        BootstrapConfig[] calldata $valdiators,\\n        BootstrapConfig[] calldata $executors,\\n        BootstrapConfig calldata _hook,\\n        BootstrapConfig[] calldata _fallbacks\\n    )\\n        external\\n        view\\n        returns (bytes memory init)\\n    {\\n        init = abi.encode(\\n            address(this),\\n            abi.encodeCall(this.initMSA, ($valdiators, $executors, _hook, _fallbacks))\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x0f1474b9f03cc19e781766784dc28d701036d2a06145c16fb3b88e7746249ef3\",\"license\":\"MIT\"},\"forge-std/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    /// uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x414b2861b1acbf816ccb7346d3f16cf6c1e002e9e5e40d2f1f26fa5ddc2ea600\",\"license\":\"MIT\"},\"forge-std/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\n/// @dev Interface of the ERC20 standard as defined in the EIP.\\n/// @dev This includes the optional name, symbol, and decimals metadata.\\ninterface IERC20 {\\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\\n    /// is the new allowance.\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice Returns the amount of tokens in existence.\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Returns the amount of tokens owned by `account`.\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\\n    /// to spend on behalf of `owner`\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\\n    /// `amount` is then deducted from the caller's allowance.\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Returns the name of the token.\\n    function name() external view returns (string memory);\\n\\n    /// @notice Returns the symbol of the token.\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Returns the decimals places of the token.\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x4cab887298790f908c27de107e4e2907ca5413aee482ef776f8d2f353c5ef947\",\"license\":\"MIT\"},\"forge-std/interfaces/IERC4626.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/// @dev Interface of the ERC4626 \\\"Tokenized Vault Standard\\\", as defined in\\n/// https://eips.ethereum.org/EIPS/eip-4626\\ninterface IERC4626 is IERC20 {\\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\\n    );\\n\\n    /// @notice Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\\n    /// @dev\\n    /// - MUST be an ERC-20 token contract.\\n    /// - MUST NOT revert.\\n    function asset() external view returns (address assetTokenAddress);\\n\\n    /// @notice Returns the total amount of the underlying asset that is \\u201cmanaged\\u201d by Vault.\\n    /// @dev\\n    /// - SHOULD include any compounding that occurs from yield.\\n    /// - MUST be inclusive of any fees that are charged against assets in the Vault.\\n    /// - MUST NOT revert.\\n    function totalAssets() external view returns (uint256 totalManagedAssets);\\n\\n    /// @notice Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\\n    /// scenario where all the conditions are met.\\n    /// @dev\\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n    /// - MUST NOT show any variations depending on the caller.\\n    /// - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: This calculation MAY NOT reflect the \\u201cper-user\\u201d price-per-share, and instead should reflect the\\n    /// \\u201caverage-user\\u2019s\\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n    /// from.\\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\\n\\n    /// @notice Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\\n    /// scenario where all the conditions are met.\\n    /// @dev\\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n    /// - MUST NOT show any variations depending on the caller.\\n    /// - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: This calculation MAY NOT reflect the \\u201cper-user\\u201d price-per-share, and instead should reflect the\\n    /// \\u201caverage-user\\u2019s\\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n    /// from.\\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n\\n    /// @notice Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\\n    /// through a deposit call.\\n    /// @dev\\n    /// - MUST return a limited value if receiver is subject to some deposit limit.\\n    /// - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\\n    /// - MUST NOT revert.\\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\\n\\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\\n    /// current on-chain conditions.\\n    /// @dev\\n    /// - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\\n    ///   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\\n    ///   in the same transaction.\\n    /// - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\\n    ///   deposit would be accepted, regardless if the user has enough tokens approved, etc.\\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\\n    /// share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\\n\\n    /// @notice Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\\n    /// @dev\\n    /// - MUST emit the Deposit event.\\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n    ///   deposit execution, and are accounted for during deposit.\\n    /// - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\\n    ///   approving enough underlying tokens to the Vault contract, etc).\\n    ///\\n    /// NOTE: most implementations will require pre-approval of the Vault with the Vault\\u2019s underlying asset token.\\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\\n\\n    /// @notice Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\\n    /// @dev\\n    /// - MUST return a limited value if receiver is subject to some mint limit.\\n    /// - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\\n    /// - MUST NOT revert.\\n    function maxMint(address receiver) external view returns (uint256 maxShares);\\n\\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\\n    /// current on-chain conditions.\\n    /// @dev\\n    /// - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\\n    ///   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\\n    ///   same transaction.\\n    /// - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\\n    ///   would be accepted, regardless if the user has enough tokens approved, etc.\\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\\n    /// share price or some other type of condition, meaning the depositor will lose assets by minting.\\n    function previewMint(uint256 shares) external view returns (uint256 assets);\\n\\n    /// @notice Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\\n    /// @dev\\n    /// - MUST emit the Deposit event.\\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\\n    ///   execution, and are accounted for during mint.\\n    /// - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\\n    ///   approving enough underlying tokens to the Vault contract, etc).\\n    ///\\n    /// NOTE: most implementations will require pre-approval of the Vault with the Vault\\u2019s underlying asset token.\\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\\n\\n    /// @notice Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\\n    /// Vault, through a withdraw call.\\n    /// @dev\\n    /// - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n    /// - MUST NOT revert.\\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\\n\\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\\n    /// given current on-chain conditions.\\n    /// @dev\\n    /// - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\\n    ///   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\\n    ///   called\\n    ///   in the same transaction.\\n    /// - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\\n    ///   the withdrawal would be accepted, regardless if the user has enough shares, etc.\\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\\n    /// share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\\n\\n    /// @notice Burns shares from owner and sends exactly assets of underlying tokens to receiver.\\n    /// @dev\\n    /// - MUST emit the Withdraw event.\\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n    ///   withdraw execution, and are accounted for during withdraw.\\n    /// - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\\n    ///   not having enough shares, etc).\\n    ///\\n    /// Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n    /// Those methods should be performed separately.\\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\\n\\n    /// @notice Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\\n    /// through a redeem call.\\n    /// @dev\\n    /// - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n    /// - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\\n    /// - MUST NOT revert.\\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\\n\\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\\n    /// given current on-chain conditions.\\n    /// @dev\\n    /// - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\\n    ///   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\\n    ///   same transaction.\\n    /// - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\\n    ///   redemption would be accepted, regardless if the user has enough shares, etc.\\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\\n    /// share price or some other type of condition, meaning the depositor will lose assets by redeeming.\\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\\n\\n    /// @notice Burns exactly shares from owner and sends assets of underlying tokens to receiver.\\n    /// @dev\\n    /// - MUST emit the Withdraw event.\\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n    ///   redeem execution, and are accounted for during redeem.\\n    /// - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\\n    ///   not having enough shares, etc).\\n    ///\\n    /// NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n    /// Those methods should be performed separately.\\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\\n}\\n\",\"keccak256\":\"0x324b43bdb94d78fe11220102056ba27362b7083fbc394fddc86dd68f75c0e46e\",\"license\":\"MIT\"},\"forge-std/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/// @title ERC-721 Non-Fungible Token Standard\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// Note: the ERC-165 identifier for this interface is 0x80ac58cd.\\ninterface IERC721 is IERC165 {\\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\\n    /// This event emits when NFTs are created (`from` == 0) and destroyed\\n    /// (`to` == 0). Exception: during contract creation, any number of NFTs\\n    /// may be created and assigned without emitting Transfer. At the time of\\n    /// any transfer, the approved address for that NFT (if any) is reset to none.\\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\\n\\n    /// @dev This emits when the approved address for an NFT is changed or\\n    /// reaffirmed. The zero address indicates there is no approved address.\\n    /// When a Transfer event emits, this also indicates that the approved\\n    /// address for that NFT (if any) is reset to none.\\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\\n\\n    /// @dev This emits when an operator is enabled or disabled for an owner.\\n    /// The operator can manage all NFTs of the owner.\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n    /// @notice Count all NFTs assigned to an owner\\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\\n    /// function throws for queries about the zero address.\\n    /// @param _owner An address for whom to query the balance\\n    /// @return The number of NFTs owned by `_owner`, possibly zero\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    /// @notice Find the owner of an NFT\\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\\n    /// about them do throw.\\n    /// @param _tokenId The identifier for an NFT\\n    /// @return The address of the owner of the NFT\\n    function ownerOf(uint256 _tokenId) external view returns (address);\\n\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n    /// operator, or the approved address for this NFT. Throws if `_from` is\\n    /// not the current owner. Throws if `_to` is the zero address. Throws if\\n    /// `_tokenId` is not a valid NFT. When transfer is complete, this function\\n    /// checks if `_to` is a smart contract (code size > 0). If so, it calls\\n    /// `onERC721Received` on `_to` and throws if the return value is not\\n    /// `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    /// @param data Additional data with no specified format, sent in call to `_to`\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\\n\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\n    /// @dev This works identically to the other function with an extra data parameter,\\n    /// except this function just sets data to \\\"\\\".\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\\n\\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\n    /// TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\n    /// THEY MAY BE PERMANENTLY LOST\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n    /// operator, or the approved address for this NFT. Throws if `_from` is\\n    /// not the current owner. Throws if `_to` is the zero address. Throws if\\n    /// `_tokenId` is not a valid NFT.\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\\n\\n    /// @notice Change or reaffirm the approved address for an NFT\\n    /// @dev The zero address indicates there is no approved address.\\n    /// Throws unless `msg.sender` is the current NFT owner, or an authorized\\n    /// operator of the current owner.\\n    /// @param _approved The new approved NFT controller\\n    /// @param _tokenId The NFT to approve\\n    function approve(address _approved, uint256 _tokenId) external payable;\\n\\n    /// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\n    /// all of `msg.sender`'s assets\\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\\n    /// multiple operators per owner.\\n    /// @param _operator Address to add to the set of authorized operators\\n    /// @param _approved True if the operator is approved, false to revoke approval\\n    function setApprovalForAll(address _operator, bool _approved) external;\\n\\n    /// @notice Get the approved address for a single NFT\\n    /// @dev Throws if `_tokenId` is not a valid NFT.\\n    /// @param _tokenId The NFT to find the approved address for\\n    /// @return The approved address for this NFT, or the zero address if there is none\\n    function getApproved(uint256 _tokenId) external view returns (address);\\n\\n    /// @notice Query if an address is an authorized operator for another address\\n    /// @param _owner The address that owns the NFTs\\n    /// @param _operator The address that acts on behalf of the owner\\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\\n}\\n\\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\\ninterface IERC721TokenReceiver {\\n    /// @notice Handle the receipt of an NFT\\n    /// @dev The ERC721 smart contract calls this function on the recipient\\n    /// after a `transfer`. This function MAY throw to revert and reject the\\n    /// transfer. Return of other than the magic value MUST result in the\\n    /// transaction being reverted.\\n    /// Note: the contract address is always the message sender.\\n    /// @param _operator The address which called `safeTransferFrom` function\\n    /// @param _from The address which previously owned the token\\n    /// @param _tokenId The NFT identifier which is being transferred\\n    /// @param _data Additional data with no specified format\\n    /// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    ///  unless throwing\\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data)\\n        external\\n        returns (bytes4);\\n}\\n\\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// Note: the ERC-165 identifier for this interface is 0x5b5e139f.\\ninterface IERC721Metadata is IERC721 {\\n    /// @notice A descriptive name for a collection of NFTs in this contract\\n    function name() external view returns (string memory _name);\\n\\n    /// @notice An abbreviated name for NFTs in this contract\\n    function symbol() external view returns (string memory _symbol);\\n\\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\\n    /// 3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\n    /// Metadata JSON Schema\\\".\\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\\n}\\n\\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// Note: the ERC-165 identifier for this interface is 0x780e9d63.\\ninterface IERC721Enumerable is IERC721 {\\n    /// @notice Count NFTs tracked by this contract\\n    /// @return A count of valid NFTs tracked by this contract, where each one of\\n    /// them has an assigned and queryable owner not equal to the zero address\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Enumerate valid NFTs\\n    /// @dev Throws if `_index` >= `totalSupply()`.\\n    /// @param _index A counter less than `totalSupply()`\\n    /// @return The token identifier for the `_index`th NFT,\\n    /// (sort order not specified)\\n    function tokenByIndex(uint256 _index) external view returns (uint256);\\n\\n    /// @notice Enumerate NFTs assigned to an owner\\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\\n    /// `_owner` is the zero address, representing invalid NFTs.\\n    /// @param _owner An address where we are interested in NFTs owned by them\\n    /// @param _index A counter less than `balanceOf(_owner)`\\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\\n    /// (sort order not specified)\\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xf069262a264fdb69f8f37a10d2df7374649e9ba73f8414c9c8a3b51184625f15\",\"license\":\"MIT\"},\"modulekit/Accounts.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable no-unused-import */\\nimport { Execution, IERC7579Account } from \\\"./external/ERC7579.sol\\\";\\n\",\"keccak256\":\"0xbebda0e48bf4fe679dedb8a413cce6591b671a165d7ed534ca1a4a10e5e1e169\",\"license\":\"MIT\"},\"modulekit/Integrations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable no-unused-import */\\nimport { ERC20Integration } from \\\"./integrations/ERC20.sol\\\";\\nimport { ERC721Integration } from \\\"./integrations/ERC721.sol\\\";\\nimport { ERC4626Integration } from \\\"./integrations/ERC4626.sol\\\";\\nimport { UniswapV3Integration, SWAPROUTER_ADDRESS } from \\\"./integrations/uniswap/v3/Uniswap.sol\\\";\\n\",\"keccak256\":\"0x88dc1c5c76d3e00df19a173bd71632240bfcac5d2edaff628d1ac38f8e1af9bb\",\"license\":\"MIT\"},\"modulekit/external/ERC7579.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable no-unused-import */\\nimport { MSAFactory as ERC7579AccountFactory } from \\\"erc7579/MSAFactory.sol\\\";\\nimport { MSAAdvanced as ERC7579Account } from \\\"erc7579/MSAAdvanced.sol\\\";\\nimport { Execution, IERC7579Account } from \\\"erc7579/interfaces/IERC7579Account.sol\\\";\\nimport { IMSA } from \\\"erc7579/interfaces/IMSA.sol\\\";\\nimport {\\n    IModule as IERC7579Module,\\n    IValidator as IERC7579Validator,\\n    IExecutor as IERC7579Executor,\\n    IHook as IERC7579Hook,\\n    IFallback as IERC7579Fallback,\\n    MODULE_TYPE_VALIDATOR,\\n    MODULE_TYPE_EXECUTOR,\\n    MODULE_TYPE_HOOK,\\n    MODULE_TYPE_FALLBACK\\n} from \\\"erc7579/interfaces/IERC7579Module.sol\\\";\\n\\nimport {\\n    ModeLib as ERC7579ModeLib,\\n    ModeCode,\\n    CallType,\\n    ExecType,\\n    ModePayload,\\n    CALLTYPE_SINGLE,\\n    CALLTYPE_BATCH,\\n    CALLTYPE_DELEGATECALL,\\n    EXECTYPE_DEFAULT,\\n    MODE_DEFAULT,\\n    CALLTYPE_STATIC\\n} from \\\"erc7579/lib/ModeLib.sol\\\";\\nimport { Execution, ExecutionLib as ERC7579ExecutionLib } from \\\"erc7579/lib/ExecutionLib.sol\\\";\\n\\nimport {\\n    Bootstrap as ERC7579Bootstrap,\\n    BootstrapConfig as ERC7579BootstrapConfig\\n} from \\\"erc7579/utils/Bootstrap.sol\\\";\\n/* solhint-enable no-unused-import */\\n\",\"keccak256\":\"0x485f6b18d331a6a77ea7ae61d4a100e2bd4c3575e1acc46b83c9a512a7135f00\",\"license\":\"MIT\"},\"modulekit/integrations/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { IERC20 } from \\\"forge-std/interfaces/IERC20.sol\\\";\\nimport { Execution } from \\\"../Accounts.sol\\\";\\nimport { ERC7579Exec } from \\\"./ERC7579Exec.sol\\\";\\n\\nlibrary ERC20Integration {\\n    using ERC7579Exec for address;\\n\\n    error SafeERC20TransferFailed();\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 amount\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec0, Execution memory exec1)\\n    {\\n        exec0 = Execution({\\n            target: address(token),\\n            value: 0,\\n            callData: abi.encodeCall(IERC20.approve, (spender, 0))\\n        });\\n        exec1 = Execution({\\n            target: address(token),\\n            value: 0,\\n            callData: abi.encodeCall(IERC20.approve, (spender, amount))\\n        });\\n    }\\n\\n    function approve(\\n        IERC20 token,\\n        address spender,\\n        uint256 amount\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(token),\\n            value: 0,\\n            callData: abi.encodeCall(IERC20.approve, (spender, amount))\\n        });\\n    }\\n\\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\\n        safeTransfer(token, msg.sender, to, amount);\\n    }\\n\\n    function safeTransfer(IERC20 token, address account, address to, uint256 amount) internal {\\n        bytes memory ret = account.exec7579({\\n            to: address(token),\\n            value: 0,\\n            data: abi.encodeCall(IERC20.transfer, (to, amount))\\n        });\\n        if (ret.length != 0) {\\n            bool success = abi.decode(ret, (bool));\\n            if (!success) revert SafeERC20TransferFailed();\\n        }\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\\n        safeTransferFrom(token, msg.sender, from, to, amount);\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address account,\\n        address from,\\n        address to,\\n        uint256 amount\\n    )\\n        internal\\n    {\\n        bytes memory ret = account.exec7579({\\n            to: address(token),\\n            value: 0,\\n            data: abi.encodeCall(IERC20.transferFrom, (from, to, amount))\\n        });\\n\\n        bytes[] memory retValues = abi.decode(ret, (bytes[]));\\n        if (retValues[0].length != 0) {\\n            bool success = abi.decode(retValues[0], (bool));\\n            if (!success) revert SafeERC20TransferFailed();\\n        }\\n    }\\n\\n    function transfer(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(token),\\n            value: 0,\\n            callData: abi.encodeCall(IERC20.transfer, (to, amount))\\n        });\\n    }\\n\\n    function transferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(token),\\n            value: 0,\\n            callData: abi.encodeCall(IERC20.transferFrom, (from, to, amount))\\n        });\\n    }\\n}\\n\",\"keccak256\":\"0x9d7b52e2e6ec3a1a3490c33da159d6c8a3da811f74934dbc78373bebd8303279\",\"license\":\"MIT\"},\"modulekit/integrations/ERC4626.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { IERC4626 } from \\\"forge-std/interfaces/IERC4626.sol\\\";\\nimport { Execution } from \\\"../Accounts.sol\\\";\\n\\nlibrary ERC4626Integration {\\n    function deposit(\\n        IERC4626 vault,\\n        uint256 assets,\\n        address receiver\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(vault),\\n            value: 0,\\n            callData: abi.encodeCall(IERC4626.deposit, (assets, receiver))\\n        });\\n    }\\n\\n    function mint(\\n        IERC4626 vault,\\n        uint256 shares,\\n        address receiver\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(vault),\\n            value: 0,\\n            callData: abi.encodeCall(IERC4626.mint, (shares, receiver))\\n        });\\n    }\\n\\n    function withdraw(\\n        IERC4626 vault,\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(vault),\\n            value: 0,\\n            callData: abi.encodeCall(IERC4626.withdraw, (assets, receiver, owner))\\n        });\\n    }\\n\\n    function redeem(\\n        IERC4626 vault,\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(vault),\\n            value: 0,\\n            callData: abi.encodeCall(IERC4626.redeem, (shares, receiver, owner))\\n        });\\n    }\\n}\\n\",\"keccak256\":\"0xb6abc217507eb5400a9a3442a6dfc590f17828484409c011736165ddefff9d11\",\"license\":\"MIT\"},\"modulekit/integrations/ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { IERC721 } from \\\"forge-std/interfaces/IERC721.sol\\\";\\nimport { Execution } from \\\"../Accounts.sol\\\";\\n\\nlibrary ERC721Integration {\\n    function approve(\\n        IERC721 token,\\n        address spender,\\n        uint256 tokenId\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(token),\\n            value: 0,\\n            callData: abi.encodeCall(IERC721.approve, (spender, tokenId))\\n        });\\n    }\\n\\n    function transferFrom(\\n        IERC721 token,\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(token),\\n            value: 0,\\n            callData: abi.encodeCall(IERC721.transferFrom, (from, to, tokenId))\\n        });\\n    }\\n}\\n\",\"keccak256\":\"0x8df645b376135530e56438175589ed57396a9f4495c2360685ead1cf5da39b76\",\"license\":\"MIT\"},\"modulekit/integrations/ERC7579Exec.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.25;\\n\\nimport \\\"../external/ERC7579.sol\\\";\\n\\nlibrary ERC7579Exec {\\n    function exec7579(\\n        address account,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    )\\n        internal\\n        returns (bytes memory result)\\n    {\\n        ModeCode modeCode = ERC7579ModeLib.encode({\\n            callType: CALLTYPE_SINGLE,\\n            execType: EXECTYPE_DEFAULT,\\n            mode: MODE_DEFAULT,\\n            payload: ModePayload.wrap(bytes22(0))\\n        });\\n\\n        return IERC7579Account(account).executeFromExecutor(\\n            modeCode, ERC7579ExecutionLib.encodeSingle(to, value, data)\\n        )[0];\\n    }\\n\\n    function exec7579(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    )\\n        internal\\n        returns (bytes memory result)\\n    {\\n        return exec7579(msg.sender, to, value, data);\\n    }\\n\\n    function exec7579(\\n        address account,\\n        Execution[] memory execs\\n    )\\n        internal\\n        returns (bytes[] memory results)\\n    {\\n        ModeCode modeCode = ERC7579ModeLib.encode({\\n            callType: CALLTYPE_BATCH,\\n            execType: EXECTYPE_DEFAULT,\\n            mode: MODE_DEFAULT,\\n            payload: ModePayload.wrap(bytes22(0))\\n        });\\n        results = IERC7579Account(account).executeFromExecutor(\\n            modeCode, ERC7579ExecutionLib.encodeBatch(execs)\\n        );\\n    }\\n\\n    function exec7579(Execution[] memory execs) internal returns (bytes[] memory results) {\\n        return exec7579(msg.sender, execs);\\n    }\\n\\n    // Note: Not every account will support delegatecalls\\n    function exec7579(\\n        address account,\\n        address delegateTarget,\\n        bytes memory callData\\n    )\\n        internal\\n        returns (bytes[] memory results)\\n    {\\n        ModeCode modeCode = ERC7579ModeLib.encode({\\n            callType: CALLTYPE_DELEGATECALL,\\n            execType: EXECTYPE_DEFAULT,\\n            mode: MODE_DEFAULT,\\n            payload: ModePayload.wrap(bytes22(0))\\n        });\\n        results = IERC7579Account(account).executeFromExecutor(\\n            modeCode, abi.encodePacked(delegateTarget, callData)\\n        );\\n    }\\n\\n    // Note: Not every account will support delegatecalls\\n    function exec7579(\\n        address delegateTarget,\\n        bytes memory callData\\n    )\\n        internal\\n        returns (bytes[] memory results)\\n    {\\n        return exec7579(msg.sender, delegateTarget, callData);\\n    }\\n}\\n\",\"keccak256\":\"0x4105e4d8e78e8ed28c92d70dcb551ae68a5763822e9a990164a2adc4f4d23143\",\"license\":\"AGPL-3.0-only\"},\"modulekit/integrations/interfaces/uniswap/v3/ISwapRouter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.4;\\npragma abicoder v2;\\n\\nimport { IUniswapV3SwapCallback } from \\\"./IUniswapV3SwapCallback.sol\\\";\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter is IUniswapV3SwapCallback {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in\\n    /// calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(\\n        ExactInputSingleParams calldata params\\n    )\\n        external\\n        payable\\n        returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified\\n    /// path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams`\\n    /// in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(\\n        ExactInputParams calldata params\\n    )\\n        external\\n        payable\\n        returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in\\n    /// calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(\\n        ExactOutputSingleParams calldata params\\n    )\\n        external\\n        payable\\n        returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the\\n    /// specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as\\n    /// `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(\\n        ExactOutputParams calldata params\\n    )\\n        external\\n        payable\\n        returns (uint256 amountIn);\\n}\\n\",\"keccak256\":\"0x69e1bac2845466d8117eb5855c84ee730c571c3a93d3066fb5c22755f50b6d5c\",\"license\":\"GPL-2.0-or-later\"},\"modulekit/integrations/interfaces/uniswap/v3/IUniswapV3Factory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\nabstract contract IUniswapV3Factory {\\n    function getPool(\\n        address token0,\\n        address token1,\\n        uint24 fee\\n    )\\n        external\\n        view\\n        virtual\\n        returns (address poolAddress);\\n}\\n\",\"keccak256\":\"0x4d305c2ff3c3350153da53f01e95d091648f561db67322b1af5e1eb418d03906\",\"license\":\"MIT\"},\"modulekit/integrations/interfaces/uniswap/v3/IUniswapV3Pool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\nabstract contract IUniswapV3Pool {\\n    struct Slot0 {\\n        // the current price\\n        uint160 sqrtPriceX96;\\n        // the current tick\\n        int24 tick;\\n        // the most-recently updated index of the observations array\\n        uint16 observationIndex;\\n        // the current maximum number of observations that are being stored\\n        uint16 observationCardinality;\\n        // the next maximum number of observations to store, triggered in observations.write\\n        uint16 observationCardinalityNext;\\n        // the current protocol fee as a percentage of the swap fee taken on withdrawal\\n        // represented as an integer denominator (1/x)%\\n        uint8 feeProtocol;\\n        // whether the pool is locked\\n        bool unlocked;\\n    }\\n\\n    function slot0() external view virtual returns (Slot0 memory);\\n\\n    function fee() external view virtual returns (uint24 fee);\\n\\n    function flash(\\n        address recipient,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes memory data\\n    )\\n        external\\n        virtual;\\n\\n    function token0() external view virtual returns (address);\\n    function token1() external view virtual returns (address);\\n}\\n\",\"keccak256\":\"0xe3bb1a1c66f5362d892b9dc81ac9560a951873116856268a25f6bf98609fbe9a\",\"license\":\"MIT\"},\"modulekit/integrations/interfaces/uniswap/v3/IUniswapV3SwapCallback.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical\\n    /// UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received\\n    /// (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received\\n    /// (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    )\\n        external;\\n}\\n\",\"keccak256\":\"0x923496e539a4b65b83344d901ad1402c5fe29258646ecfdd5e145d95bac3ee4b\",\"license\":\"GPL-2.0-or-later\"},\"modulekit/integrations/uniswap/helpers/MainnetAddresses.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\naddress payable constant SWAPROUTER_ADDRESS = payable(0xE592427A0AEce92De3Edee1F18E0157C05861564);\\nuint24 constant SWAPROUTER_DEFAULTFEE = 3000;\\naddress constant QUOTER_ADDRESS = 0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6;\\naddress constant FACTORY_ADDRESS = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\\n\",\"keccak256\":\"0xb116979986a1694219a669ed3b2dcd8802387d7f83ed3882b67190bfd8f74844\",\"license\":\"MIT\"},\"modulekit/integrations/uniswap/v3/Uniswap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport {\\n    SWAPROUTER_ADDRESS,\\n    SWAPROUTER_DEFAULTFEE,\\n    FACTORY_ADDRESS\\n} from \\\"../helpers/MainnetAddresses.sol\\\";\\nimport { ISwapRouter } from \\\"../../interfaces/uniswap/v3/ISwapRouter.sol\\\";\\nimport { IUniswapV3Factory } from \\\"../../interfaces/uniswap/v3/IUniswapV3Factory.sol\\\";\\nimport { IUniswapV3Pool } from \\\"../../interfaces/uniswap/v3/IUniswapV3Pool.sol\\\";\\nimport { IERC20 } from \\\"forge-std/interfaces/IERC20.sol\\\";\\nimport { ERC20Integration } from \\\"../../ERC20.sol\\\";\\nimport { Execution } from \\\"../../../Accounts.sol\\\";\\n\\n/// @author zeroknots\\nlibrary UniswapV3Integration {\\n    using ERC20Integration for IERC20;\\n\\n    error PoolDoesNotExist();\\n\\n    function approveAndSwap(\\n        address smartAccount,\\n        IERC20 tokenIn,\\n        IERC20 tokenOut,\\n        uint256 amountIn,\\n        uint160 sqrtPriceLimitX96\\n    )\\n        internal\\n        view\\n        returns (Execution[] memory exec)\\n    {\\n        exec = new Execution[](3);\\n        (exec[0], exec[1]) = ERC20Integration.safeApprove(tokenIn, SWAPROUTER_ADDRESS, amountIn);\\n        exec[2] = swapExactInputSingle(smartAccount, tokenIn, tokenOut, amountIn, sqrtPriceLimitX96);\\n    }\\n\\n    function swapExactInputSingle(\\n        address smartAccount,\\n        IERC20 tokenIn,\\n        IERC20 tokenOut,\\n        uint256 amountIn,\\n        uint160 sqrtPriceLimitX96\\n    )\\n        internal\\n        view\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: SWAPROUTER_ADDRESS,\\n            value: 0,\\n            callData: abi.encodeCall(\\n                ISwapRouter.exactInputSingle,\\n                (\\n                    ISwapRouter.ExactInputSingleParams({\\n                        tokenIn: address(tokenIn),\\n                        tokenOut: address(tokenOut),\\n                        fee: SWAPROUTER_DEFAULTFEE,\\n                        recipient: smartAccount,\\n                        deadline: block.timestamp,\\n                        amountIn: amountIn,\\n                        amountOutMinimum: 0,\\n                        sqrtPriceLimitX96: sqrtPriceLimitX96\\n                    })\\n                )\\n            )\\n        });\\n    }\\n\\n    function swapExactOutputSingle(\\n        address smartAccount,\\n        IERC20 tokenIn,\\n        IERC20 tokenOut,\\n        uint256 amountOut,\\n        uint256 amountInMaximum\\n    )\\n        internal\\n        view\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: SWAPROUTER_ADDRESS,\\n            value: 0,\\n            callData: abi.encodeCall(\\n                ISwapRouter.exactOutputSingle,\\n                (\\n                    ISwapRouter.ExactOutputSingleParams({\\n                        tokenIn: address(tokenIn),\\n                        tokenOut: address(tokenOut),\\n                        fee: SWAPROUTER_DEFAULTFEE,\\n                        recipient: smartAccount,\\n                        deadline: block.timestamp,\\n                        amountOut: amountOut,\\n                        amountInMaximum: amountInMaximum,\\n                        sqrtPriceLimitX96: 0\\n                    })\\n                )\\n            )\\n        });\\n    }\\n\\n    function getPoolAddress(\\n        address token0,\\n        address token1\\n    )\\n        public\\n        view\\n        returns (address poolAddress)\\n    {\\n        IUniswapV3Factory factory = IUniswapV3Factory(FACTORY_ADDRESS);\\n        address poolAddress = factory.getPool(token0, token1, SWAPROUTER_DEFAULTFEE);\\n        if (poolAddress == address(0)) {\\n            revert PoolDoesNotExist();\\n        }\\n        return poolAddress;\\n    }\\n\\n    function getSqrtPriceX96(address poolAddress) public view returns (uint160 sqrtPriceX96) {\\n        IUniswapV3Pool pool = IUniswapV3Pool(poolAddress);\\n        IUniswapV3Pool.Slot0 memory slot0 = pool.slot0();\\n        uint160 sqrtPriceX96 = slot0.sqrtPriceX96;\\n        return sqrtPriceX96;\\n    }\\n\\n    function sqrtPriceX96toPriceRatio(\\n        uint160 sqrtPriceX96\\n    )\\n        internal\\n        pure\\n        returns (uint256 priceRatio)\\n    {\\n        uint256 decodedSqrtPrice = sqrtPriceX96 / (2 ** 96);\\n        uint256 priceRatio = decodedSqrtPrice * decodedSqrtPrice;\\n        return priceRatio;\\n    }\\n\\n    function priceRatioToPrice(\\n        uint256 priceRatio,\\n        address poolAddress,\\n        address tokenSwappedFrom\\n    )\\n        internal\\n        view\\n        returns (uint256 price)\\n    {\\n        IUniswapV3Pool pool = IUniswapV3Pool(poolAddress);\\n        address poolToken0 = pool.token0();\\n        address poolToken1 = pool.token1();\\n        uint256 token0Decimals = IERC20(poolToken0).decimals();\\n        uint256 token1Decimals = IERC20(poolToken1).decimals();\\n\\n        bool swapToken0to1 = (tokenSwappedFrom == poolToken0);\\n        if (swapToken0to1) {\\n            price = 10 ** token1Decimals / priceRatio;\\n        } else {\\n            price = priceRatio * 10 ** token0Decimals;\\n        }\\n        return price;\\n    }\\n\\n    function priceRatioToSqrtPriceX96(uint256 priceRatio) internal pure returns (uint160) {\\n        uint256 sqrtPriceRatio = sqrt256(priceRatio * 1e18); // Scale priceRatio to 18 decimals for\\n            // precision\\n\\n        uint256 sqrtPriceX96 = (sqrtPriceRatio * 2 ** 96) / 1e9; // Adjust back from the scaling\\n\\n        return uint160(sqrtPriceX96);\\n    }\\n\\n    function checkTokenOrder(\\n        address tokenSwappedFrom,\\n        address poolAddress\\n    )\\n        internal\\n        view\\n        returns (bool swapToken0to1)\\n    {\\n        address poolToken0 = IUniswapV3Pool(poolAddress).token0();\\n        bool swapToken0to1 = (tokenSwappedFrom == poolToken0);\\n        return swapToken0to1;\\n    }\\n\\n    function sqrt256(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x00674841391db093b9af74bee6660a7ae603bc254b6b3706071b38bbbc5361c2\",\"license\":\"MIT\"},\"sentinellist/SentinelList.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\naddress constant SENTINEL = address(0x1);\\naddress constant ZERO_ADDRESS = address(0x0);\\n\\nlibrary SentinelListLib {\\n    struct SentinelList {\\n        mapping(address => address) entries;\\n    }\\n\\n    error LinkedList_AlreadyInitialized();\\n    error LinkedList_InvalidPage();\\n    error LinkedList_InvalidEntry(address entry);\\n    error LinkedList_EntryAlreadyInList(address entry);\\n\\n    function init(SentinelList storage self) internal {\\n        if (alreadyInitialized(self)) revert LinkedList_AlreadyInitialized();\\n        self.entries[SENTINEL] = SENTINEL;\\n    }\\n\\n    function alreadyInitialized(SentinelList storage self) internal view returns (bool) {\\n        return self.entries[SENTINEL] != ZERO_ADDRESS;\\n    }\\n\\n    function getNext(SentinelList storage self, address entry) internal view returns (address) {\\n        if (entry == ZERO_ADDRESS) {\\n            revert LinkedList_InvalidEntry(entry);\\n        }\\n        return self.entries[entry];\\n    }\\n\\n    function push(SentinelList storage self, address newEntry) internal {\\n        if (newEntry == ZERO_ADDRESS || newEntry == SENTINEL) {\\n            revert LinkedList_InvalidEntry(newEntry);\\n        }\\n        if (self.entries[newEntry] != ZERO_ADDRESS) revert LinkedList_EntryAlreadyInList(newEntry);\\n        self.entries[newEntry] = self.entries[SENTINEL];\\n        self.entries[SENTINEL] = newEntry;\\n    }\\n\\n    function pop(SentinelList storage self, address prevEntry, address popEntry) internal {\\n        if (popEntry == ZERO_ADDRESS || popEntry == SENTINEL) {\\n            revert LinkedList_InvalidEntry(prevEntry);\\n        }\\n        if (self.entries[prevEntry] != popEntry) revert LinkedList_InvalidEntry(popEntry);\\n        self.entries[prevEntry] = self.entries[popEntry];\\n        self.entries[popEntry] = ZERO_ADDRESS;\\n    }\\n\\n    function popAll(SentinelList storage self) internal {\\n        address next = self.entries[SENTINEL];\\n        while (next != ZERO_ADDRESS) {\\n            address current = next;\\n            next = self.entries[next];\\n            self.entries[current] = ZERO_ADDRESS;\\n        }\\n        self.entries[SENTINEL] = ZERO_ADDRESS;\\n    }\\n\\n    function contains(SentinelList storage self, address entry) internal view returns (bool) {\\n        return SENTINEL != entry && self.entries[entry] != ZERO_ADDRESS;\\n    }\\n\\n    function getEntriesPaginated(\\n        SentinelList storage self,\\n        address start,\\n        uint256 pageSize\\n    )\\n        internal\\n        view\\n        returns (address[] memory array, address next)\\n    {\\n        if (start != SENTINEL && !contains(self, start)) revert LinkedList_InvalidEntry(start);\\n        if (pageSize == 0) revert LinkedList_InvalidPage();\\n        // Init array with max page size\\n        array = new address[](pageSize);\\n\\n        // Populate return array\\n        uint256 entryCount = 0;\\n        next = self.entries[start];\\n        while (next != ZERO_ADDRESS && next != SENTINEL && entryCount < pageSize) {\\n            array[entryCount] = next;\\n            next = self.entries[next];\\n            entryCount++;\\n        }\\n\\n        /**\\n         * Because of the argument validation, we can assume that the loop will always iterate over\\n         * the valid entry list values\\n         *       and the `next` variable will either be an enabled entry or a sentinel address\\n         * (signalling the end).\\n         *\\n         *       If we haven't reached the end inside the loop, we need to set the next pointer to\\n         * the last element of the entry array\\n         *       because the `next` variable (which is a entry by itself) acting as a pointer to the\\n         * start of the next page is neither\\n         *       incSENTINELrent page, nor will it be included in the next one if you pass it as a\\n         * start.\\n         */\\n        if (next != SENTINEL && entryCount > 0) {\\n            next = array[entryCount - 1];\\n        }\\n        // Set correct size of returned array\\n        // solhint-disable-next-line no-inline-assembly\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(array, entryCount)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0fdb07d60acf6c8272517b2cf9a7ce36cef7dabd3acfc61e7424662818044da2\",\"license\":\"MIT\"},\"solady/utils/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Gas optimized ECDSA wrapper.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\\n///\\n/// @dev Note:\\n/// - The recovery functions use the ecrecover precompile (0x1).\\n/// - As of Solady version 0.0.68, the `recover` variants will revert upon recovery failure.\\n///   This is for more safety by default.\\n///   Use the `tryRecover` variants if you need to get the zero address back\\n///   upon recovery failure instead.\\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\\n///   See: https://eips.ethereum.org/EIPS/eip-2098\\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\\n///\\n/// WARNING! Do NOT use signatures as unique identifiers:\\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\\n///   EIP-712 also enables readable signing of typed data for better user safety.\\n/// This implementation does NOT check if a signature is non-malleable.\\nlibrary ECDSA {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The signature is invalid.\\n    error InvalidSignature();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                    RECOVERY OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\n    function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            for {} 1 {} {\\n                mstore(0x00, hash)\\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n                if eq(mload(signature), 64) {\\n                    let vs := mload(add(signature, 0x40))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    break\\n                }\\n                if eq(mload(signature), 65) {\\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\\n                    break\\n                }\\n                result := 0\\n                break\\n            }\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        result, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\n    function recoverCalldata(bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            for {} 1 {} {\\n                if eq(signature.length, 64) {\\n                    let vs := calldataload(add(signature.offset, 0x20))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    break\\n                }\\n                if eq(signature.length, 65) {\\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\\n                    break\\n                }\\n                result := 0\\n                break\\n            }\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        result, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n            mstore(0x40, r)\\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the signature defined by `v`, `r`, `s`.\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, and(v, 0xff))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            result :=\\n                mload(\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                )\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            if iszero(returndatasize()) {\\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x60, 0) // Restore the zero slot.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   TRY-RECOVER OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // WARNING!\\n    // These functions will NOT revert upon recovery failure.\\n    // Instead, they will return the zero address upon recovery failure.\\n    // It is critical that the returned address is NEVER compared against\\n    // a zero address (e.g. an uninitialized address variable).\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\n    function tryRecover(bytes32 hash, bytes memory signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            for {} 1 {} {\\n                mstore(0x00, hash)\\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n                if eq(mload(signature), 64) {\\n                    let vs := mload(add(signature, 0x40))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    break\\n                }\\n                if eq(mload(signature), 65) {\\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\\n                    break\\n                }\\n                result := 0\\n                break\\n            }\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    result, // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\\n    function tryRecoverCalldata(bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            for {} 1 {} {\\n                if eq(signature.length, 64) {\\n                    let vs := calldataload(add(signature.offset, 0x20))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    break\\n                }\\n                if eq(signature.length, 65) {\\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\\n                    break\\n                }\\n                result := 0\\n                break\\n            }\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    result, // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n            mstore(0x40, r)\\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    1, // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Recovers the signer's address from a message digest `hash`,\\n    /// and the signature defined by `v`, `r`, `s`.\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (address result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x00, hash)\\n            mstore(0x20, and(v, 0xff))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            pop(\\n                staticcall(\\n                    gas(), // Amount of gas left for the transaction.\\n                    1, // Address of `ecrecover`.\\n                    0x00, // Start of input.\\n                    0x80, // Size of input.\\n                    0x40, // Start of output.\\n                    0x20 // Size of output.\\n                )\\n            )\\n            mstore(0x60, 0) // Restore the zero slot.\\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n            result := mload(xor(0x60, returndatasize()))\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     HASHING OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, hash) // Store into scratch space for keccak256.\\n            mstore(0x00, \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n32\\\") // 28 bytes.\\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\\n        }\\n    }\\n\\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    /// Note: Supports lengths of `s` up to 999999 bytes.\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let sLength := mload(s)\\n            let o := 0x20\\n            mstore(o, \\\"\\\\x19Ethereum Signed Message:\\\\n\\\") // 26 bytes, zero-right-padded.\\n            mstore(0x00, 0x00)\\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\\n            for { let temp := sLength } 1 {} {\\n                o := sub(o, 1)\\n                mstore8(o, add(48, mod(temp, 10)))\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\\n            mstore(s, sLength) // Restore the length.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   EMPTY CALLDATA HELPERS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns an empty calldata bytes.\\n    function emptySignature() internal pure returns (bytes calldata signature) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            signature.length := 0\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x317f8208d1f03356e8f709eec8e2c579d6be227099a26f777cc9ec8a06814ae4\",\"license\":\"MIT\"},\"solady/utils/LibClone.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Minimal proxy library.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\\n/// @author Minimal proxy by 0age (https://github.com/0age)\\n/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie\\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\\n/// @author Minimal ERC1967 proxy by jtriley-eth (https://github.com/jtriley-eth/minimum-viable-proxy)\\n///\\n/// @dev Minimal proxy:\\n/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,\\n/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,\\n/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.\\n///\\n/// @dev Minimal proxy (PUSH0 variant):\\n/// This is a new minimal proxy that uses the PUSH0 opcode introduced during Shanghai.\\n/// It is optimized first for minimal runtime gas, then for minimal bytecode.\\n/// The PUSH0 clone functions are intentionally postfixed with a jarring \\\"_PUSH0\\\" as\\n/// many EVM chains may not support the PUSH0 opcode in the early months after Shanghai.\\n/// Please use with caution.\\n///\\n/// @dev Clones with immutable args (CWIA):\\n/// The implementation of CWIA here implements a `receive()` method that emits the\\n/// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,\\n/// enabling us to accept hard gas-capped `sends` & `transfers` for maximum backwards\\n/// composability. The minimal proxy implementation does not offer this feature.\\n///\\n/// @dev Minimal ERC1967 proxy:\\n/// An minimal ERC1967 proxy, intended to be upgraded with UUPS.\\n/// This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\\n/// This proxy is automatically verified on Etherscan.\\n///\\n/// @dev ERC1967I proxy:\\n/// An variant of the minimal ERC1967 proxy, with a special code path that activates\\n/// if `calldatasize() == 1`. This code path skips the delegatecall and directly returns the\\n/// `implementation` address. The returned implementation is guaranteed to be valid if the\\n/// keccak256 of the proxy's code is equal to `ERC1967I_CODE_HASH`.\\nlibrary LibClone {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The keccak256 of the deployed code for the ERC1967 proxy.\\n    bytes32 internal constant ERC1967_CODE_HASH =\\n        0xaaa52c8cc8a0e3fd27ce756cc6b4e70c51423e9b597b11f32d3e49f8b1fc890d;\\n\\n    /// @dev The keccak256 of the deployed code for the ERC1967I proxy.\\n    bytes32 internal constant ERC1967I_CODE_HASH =\\n        0xce700223c0d4cea4583409accfc45adac4a093b3519998a9cbbe1504dadba6f7;\\n\\n    /// @dev The keccak256 of the deployed code for the ERC1967 beacon proxy.\\n    bytes32 internal constant ERC1967_BEACON_PROXY_CODE_HASH =\\n        0x14044459af17bc4f0f5aa2f658cb692add77d1302c29fe2aebab005eea9d1162;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Unable to deploy the clone.\\n    error DeploymentFailed();\\n\\n    /// @dev The salt must start with either the zero address or `by`.\\n    error SaltDoesNotStartWith();\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                  MINIMAL PROXY OPERATIONS                  */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Deploys a clone of `implementation`.\\n    function clone(address implementation) internal returns (address instance) {\\n        instance = clone(0, implementation);\\n    }\\n\\n    /// @dev Deploys a clone of `implementation`.\\n    /// Deposits `value` ETH during deployment.\\n    function clone(uint256 value, address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * --------------------------------------------------------------------------+\\n             * CREATION (9 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\\n             * --------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize     | r         |                              |\\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\\n             * 81         | DUP2              | r 0 r     |                              |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\\n             * --------------------------------------------------------------------------|\\n             * RUNTIME (44 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\\n             * --------------------------------------------------------------------------|\\n             *                                                                           |\\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | 0                      |                       |\\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\\n             *                                                                           |\\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\\n             *                                                                           |\\n             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * fd      | REVERT         |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\\n             * f3      | RETURN         |                        | [0..rds): returndata  |\\n             * --------------------------------------------------------------------------+\\n             */\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            instance := create(value, 0x0c, 0x35)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\\n    function cloneDeterministic(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = cloneDeterministic(0, implementation, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    function cloneDeterministic(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            instance := create2(value, 0x0c, 0x35, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code of the clone of `implementation`.\\n    function initCode(address implementation) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(add(result, 0x40), 0x5af43d3d93803e602a57fd5bf30000000000000000000000)\\n            mstore(add(result, 0x28), implementation)\\n            mstore(add(result, 0x14), 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            mstore(result, 0x35) // Store the length.\\n            mstore(0x40, add(result, 0x60)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            hash := keccak256(0x0c, 0x35)\\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic clone of `implementation`,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)\\n        internal\\n        pure\\n        returns (address predicted)\\n    {\\n        bytes32 hash = initCodeHash(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*          MINIMAL PROXY OPERATIONS (PUSH0 VARIANT)          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Deploys a PUSH0 clone of `implementation`.\\n    function clone_PUSH0(address implementation) internal returns (address instance) {\\n        instance = clone_PUSH0(0, implementation);\\n    }\\n\\n    /// @dev Deploys a PUSH0 clone of `implementation`.\\n    /// Deposits `value` ETH during deployment.\\n    function clone_PUSH0(uint256 value, address implementation)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * --------------------------------------------------------------------------+\\n             * CREATION (9 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\\n             * --------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize     | r         |                              |\\n             * 5f         | PUSH0             | 0 r       |                              |\\n             * 81         | DUP2              | r 0 r     |                              |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\\n             * 5f         | PUSH0             | 0 o r 0 r |                              |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\\n             * --------------------------------------------------------------------------|\\n             * RUNTIME (45 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\\n             * --------------------------------------------------------------------------|\\n             *                                                                           |\\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5f      | PUSH0          | 0                      |                       |\\n             * 5f      | PUSH0          | 0 0                    |                       |\\n             *                                                                           |\\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0                |                       |\\n             * 5f      | PUSH0          | 0 cds 0 0              |                       |\\n             * 5f      | PUSH0          | 0 0 cds 0 0            |                       |\\n             * 37      | CALLDATACOPY   | 0 0                    | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0                | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 cds 0 0              | [0..cds): calldata    |\\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0         | [0..cds): calldata    |\\n             * 5a      | GAS            | gas addr 0 cds 0 0     | [0..cds): calldata    |\\n             * f4      | DELEGATECALL   | success                | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds success            | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 rds success          | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 0 rds success        | [0..cds): calldata    |\\n             * 3e      | RETURNDATACOPY | success                | [0..rds): returndata  |\\n             *                                                                           |\\n             * 60 0x29 | PUSH1 0x29     | 0x29 success           | [0..rds): returndata  |\\n             * 57      | JUMPI          |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\\n             * fd      | REVERT         |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b      | JUMPDEST       |                        | [0..rds): returndata  |\\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\\n             * f3      | RETURN         |                        | [0..rds): returndata  |\\n             * --------------------------------------------------------------------------+\\n             */\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            instance := create(value, 0x0e, 0x36)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\\n    function cloneDeterministic_PUSH0(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = cloneDeterministic_PUSH0(0, implementation, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    function cloneDeterministic_PUSH0(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            instance := create2(value, 0x0e, 0x36, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code of the PUSH0 clone of `implementation`.\\n    function initCode_PUSH0(address implementation) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(add(result, 0x40), 0x5af43d5f5f3e6029573d5ffd5b3d5ff300000000000000000000) // 16\\n            mstore(add(result, 0x26), implementation) // 20\\n            mstore(add(result, 0x12), 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            mstore(result, 0x36) // Store the length.\\n            mstore(0x40, add(result, 0x60)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the PUSH0 clone of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash_PUSH0(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            hash := keccak256(0x0e, 0x36)\\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic PUSH0 clone of `implementation`,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress_PUSH0(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHash_PUSH0(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*           CLONES WITH IMMUTABLE ARGS OPERATIONS            */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: This implementation of CWIA differs from the original implementation.\\n    // If the calldata is empty, it will emit a `ReceiveETH(uint256)` event and skip the `DELEGATECALL`.\\n\\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.\\n    function clone(address implementation, bytes memory data) internal returns (address instance) {\\n        instance = clone(0, implementation, data);\\n    }\\n\\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.\\n    /// Deposits `value` ETH during deployment.\\n    function clone(uint256 value, address implementation, bytes memory data)\\n        internal\\n        returns (address instance)\\n    {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n            // The `creationSize` is `extraLength + 108`\\n            // The `runSize` is `creationSize - 10`.\\n\\n            /**\\n             * ---------------------------------------------------------------------------------------------------+\\n             * CREATION (10 bytes)                                                                                |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                                                |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * 61 runSize | PUSH2 runSize     | r         |                                                       |\\n             * 3d         | RETURNDATASIZE    | 0 r       |                                                       |\\n             * 81         | DUP2              | r 0 r     |                                                       |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                                                       |\\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                                                       |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code                            |\\n             * f3         | RETURN            |           | [0..runSize): runtime code                            |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * RUNTIME (98 bytes + extraLength)                                                                   |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * Opcode   | Mnemonic       | Stack                    | Memory                                      |\\n             * ---------------------------------------------------------------------------------------------------|\\n             *                                                                                                    |\\n             * ::: if no calldata, emit event & return w/o `DELEGATECALL` ::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds                      |                                             |\\n             * 60 0x2c  | PUSH1 0x2c     | 0x2c cds                 |                                             |\\n             * 57       | JUMPI          |                          |                                             |\\n             * 34       | CALLVALUE      | cv                       |                                             |\\n             * 3d       | RETURNDATASIZE | 0 cv                     |                                             |\\n             * 52       | MSTORE         |                          | [0..0x20): callvalue                        |\\n             * 7f sig   | PUSH32 0x9e..  | sig                      | [0..0x20): callvalue                        |\\n             * 59       | MSIZE          | 0x20 sig                 | [0..0x20): callvalue                        |\\n             * 3d       | RETURNDATASIZE | 0 0x20 sig               | [0..0x20): callvalue                        |\\n             * a1       | LOG1           |                          | [0..0x20): callvalue                        |\\n             * 00       | STOP           |                          | [0..0x20): callvalue                        |\\n             * 5b       | JUMPDEST       |                          |                                             |\\n             *                                                                                                    |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds                      |                                             |\\n             * 3d       | RETURNDATASIZE | 0 cds                    |                                             |\\n             * 3d       | RETURNDATASIZE | 0 0 cds                  |                                             |\\n             * 37       | CALLDATACOPY   |                          | [0..cds): calldata                          |\\n             *                                                                                                    |\\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d       | RETURNDATASIZE | 0                        | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0                      | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0 0                    | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0 0 0                  | [0..cds): calldata                          |\\n             * 61 extra | PUSH2 extra    | e 0 0 0 0                | [0..cds): calldata                          |\\n             *                                                                                                    |\\n             * ::: copy extra data to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 80       | DUP1           | e e 0 0 0 0              | [0..cds): calldata                          |\\n             * 60 0x62  | PUSH1 0x62     | 0x62 e e 0 0 0 0         | [0..cds): calldata                          |\\n             * 36       | CALLDATASIZE   | cds 0x62 e e 0 0 0 0     | [0..cds): calldata                          |\\n             * 39       | CODECOPY       | e 0 0 0 0                | [0..cds): calldata, [cds..cds+e): extraData |\\n             *                                                                                                    |\\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 01       | ADD            | cds+e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3d       | RETURNDATASIZE | 0 cds+e 0 0 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 73 addr  | PUSH20 addr    | addr 0 cds+e 0 0 0 0     | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 5a       | GAS            | gas addr 0 cds+e 0 0 0 0 | [0..cds): calldata, [cds..cds+e): extraData |\\n             * f4       | DELEGATECALL   | success 0 0              | [0..cds): calldata, [cds..cds+e): extraData |\\n             *                                                                                                    |\\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d       | RETURNDATASIZE | rds success 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3d       | RETURNDATASIZE | rds rds success 0 0      | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 93       | SWAP4          | 0 rds success 0 rds      | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 80       | DUP1           | 0 0 rds success 0 rds    | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3e       | RETURNDATACOPY | success 0 rds            | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * 60 0x60  | PUSH1 0x60     | 0x60 success 0 rds       | [0..rds): returndata                        |\\n             * 57       | JUMPI          | 0 rds                    | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * fd       | REVERT         |                          | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b       | JUMPDEST       | 0 rds                    | [0..rds): returndata                        |\\n             * f3       | RETURN         |                          | [0..rds): returndata                        |\\n             * ---------------------------------------------------------------------------------------------------+\\n             */\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\\n                // The actual EVM limit may be smaller and may change over time.\\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            instance := create(value, sub(data, 0x4c), add(extraLength, 0x6c))\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation`\\n    /// with immutable arguments encoded in `data` and `salt`.\\n    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = cloneDeterministic(0, implementation, data, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation`\\n    /// with immutable arguments encoded in `data` and `salt`.\\n    function cloneDeterministic(\\n        uint256 value,\\n        address implementation,\\n        bytes memory data,\\n        bytes32 salt\\n    ) internal returns (address instance) {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\\n                // The actual EVM limit may be smaller and may change over time.\\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            instance := create2(value, sub(data, 0x4c), add(extraLength, 0x6c), salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`\\n    /// using immutable arguments encoded in `data`.\\n    function initCode(address implementation, bytes memory data)\\n        internal\\n        pure\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let dataLength := mload(data)\\n\\n            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.\\n            // The actual EVM limit may be smaller and may change over time.\\n            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))\\n\\n            let o := add(result, 0x8c)\\n            let end := add(o, dataLength)\\n\\n            // Copy the `data` into `result`.\\n            for { let d := sub(add(data, 0x20), o) } 1 {} {\\n                mstore(o, mload(add(o, d)))\\n                o := add(o, 0x20)\\n                if iszero(lt(o, end)) { break }\\n            }\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            mstore(add(result, 0x6c), 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\\n            mstore(add(result, 0x5f), implementation) // Write the address of the implementation.\\n            // Write the rest of the bytecode.\\n            mstore(\\n                add(result, 0x4b),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                add(result, 0x32),\\n                0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                add(result, 0x12),\\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(end, shl(0xf0, extraLength))\\n            mstore(add(end, 0x02), 0) // Zeroize the slot after the result.\\n            mstore(result, add(extraLength, 0x6c)) // Store the length.\\n            mstore(0x40, add(0x22, end)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`\\n    /// using immutable arguments encoded in `data`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash(address implementation, bytes memory data)\\n        internal\\n        pure\\n        returns (bytes32 hash)\\n    {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.\\n            // The actual EVM limit may be smaller and may change over time.\\n            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                sub(data, 0x5a),\\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic clone of\\n    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes memory data,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHash(implementation, data);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*              MINIMAL ERC1967 PROXY OPERATIONS              */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: The ERC1967 proxy here is intended to be upgraded with UUPS.\\n    // This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\\n\\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\\n    function deployERC1967(address implementation) internal returns (address instance) {\\n        instance = deployERC1967(0, implementation);\\n    }\\n\\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\\n    /// Deposits `value` ETH during deployment.\\n    function deployERC1967(uint256 value, address implementation)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * ---------------------------------------------------------------------------------+\\n             * CREATION (34 bytes)                                                              |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\\n             * 81         | DUP2           | r 0 r            |                                 |\\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\\n             * ---------------------------------------------------------------------------------|\\n             * RUNTIME (61 bytes)                                                               |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             *                                                                                  |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36         | CALLDATASIZE   | cds              |                                 |\\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | 0                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 60 0x38    | PUSH1 0x38     | dest succ        | [0..returndatasize): returndata |\\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\\n             * ---------------------------------------------------------------------------------+\\n             */\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\\n            mstore(0x20, 0x6009)\\n            mstore(0x1e, implementation)\\n            mstore(0x0a, 0x603d3d8160223d3973)\\n            instance := create(value, 0x21, 0x5f)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\\n    function deployDeterministicERC1967(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = deployDeterministicERC1967(0, implementation, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    function deployDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\\n            mstore(0x20, 0x6009)\\n            mstore(0x1e, implementation)\\n            mstore(0x0a, 0x603d3d8160223d3973)\\n            instance := create2(value, 0x21, 0x5f, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967(address implementation, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        return createDeterministicERC1967(0, implementation, salt);\\n    }\\n\\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\\n            mstore(0x20, 0x6009)\\n            mstore(0x1e, implementation)\\n            mstore(0x0a, 0x603d3d8160223d3973)\\n            // Compute and store the bytecode hash.\\n            mstore(add(m, 0x35), keccak256(0x21, 0x5f))\\n            mstore(m, shl(88, address()))\\n            mstore8(m, 0xff) // Write the prefix.\\n            mstore(add(m, 0x15), salt)\\n            instance := keccak256(m, 0x55)\\n            for {} 1 {} {\\n                if iszero(extcodesize(instance)) {\\n                    instance := create2(value, 0x21, 0x5f, salt)\\n                    if iszero(instance) {\\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    break\\n                }\\n                alreadyDeployed := 1\\n                if iszero(value) { break }\\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                break\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation`.\\n    function initCodeERC1967(address implementation) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(\\n                add(result, 0x60),\\n                0x3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f300\\n            )\\n            mstore(\\n                add(result, 0x40),\\n                0x55f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076cc\\n            )\\n            mstore(add(result, 0x20), or(shl(24, implementation), 0x600951))\\n            mstore(add(result, 0x09), 0x603d3d8160223d3973)\\n            mstore(result, 0x5f) // Store the length.\\n            mstore(0x40, add(result, 0x80)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHashERC1967(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\\n            mstore(0x20, 0x6009)\\n            mstore(0x1e, implementation)\\n            mstore(0x0a, 0x603d3d8160223d3973)\\n            hash := keccak256(0x21, 0x5f)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic ERC1967 proxy of `implementation`,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddressERC1967(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHashERC1967(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                 ERC1967I PROXY OPERATIONS                  */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: This proxy has a special code path that activates if `calldatasize() == 1`.\\n    // This code path skips the delegatecall and directly returns the `implementation` address.\\n    // The returned implementation is guaranteed to be valid if the keccak256 of the\\n    // proxy's code is equal to `ERC1967I_CODE_HASH`.\\n\\n    /// @dev Deploys a minimal ERC1967I proxy with `implementation`.\\n    function deployERC1967I(address implementation) internal returns (address instance) {\\n        instance = deployERC1967I(0, implementation);\\n    }\\n\\n    /// @dev Deploys a ERC1967I proxy with `implementation`.\\n    /// Deposits `value` ETH during deployment.\\n    function deployERC1967I(uint256 value, address implementation)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * ---------------------------------------------------------------------------------+\\n             * CREATION (34 bytes)                                                              |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\\n             * 81         | DUP2           | r 0 r            |                                 |\\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\\n             * ---------------------------------------------------------------------------------|\\n             * RUNTIME (82 bytes)                                                               |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             *                                                                                  |\\n             * ::: check calldatasize ::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36         | CALLDATASIZE   | cds              |                                 |\\n             * 58         | PC             | 1 cds            |                                 |\\n             * 14         | EQ             | eqs              |                                 |\\n             * 60 0x43    | PUSH1 0x43     | dest eqs         |                                 |\\n             * 57         | JUMPI          |                  |                                 |\\n             *                                                                                  |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36         | CALLDATASIZE   | cds              |                                 |\\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | 0                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 60 0x3E    | PUSH1 0x3E     | dest succ        | [0..returndatasize): returndata |\\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: implementation , return :::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b         | JUMPDEST       |                  |                                 |\\n             * 60 0x20    | PUSH1 0x20     | 32               |                                 |\\n             * 60 0x0F    | PUSH1 0x0F     | o 32             |                                 |\\n             * 3d         | RETURNDATASIZE | 0 o 32           |                                 |\\n             * 39         | CODECOPY       |                  | [0..32): implementation slot    |\\n             * 3d         | RETURNDATASIZE | 0                | [0..32): implementation slot    |\\n             * 51         | MLOAD          | slot             | [0..32): implementation slot    |\\n             * 54         | SLOAD          | impl             | [0..32): implementation slot    |\\n             * 3d         | RETURNDATASIZE | 0 impl           | [0..32): implementation slot    |\\n             * 52         | MSTORE         |                  | [0..32): implementation address |\\n             * 59         | MSIZE          | 32               | [0..32): implementation address |\\n             * 3d         | RETURNDATASIZE | 0 32             | [0..32): implementation address |\\n             * f3         | RETURN         |                  | [0..32): implementation address |\\n             * ---------------------------------------------------------------------------------+\\n             */\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\\n            instance := create(value, 0x0c, 0x74)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.\\n    function deployDeterministicERC1967I(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = deployDeterministicERC1967I(0, implementation, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    function deployDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\\n            instance := create2(value, 0x0c, 0x74, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967I(address implementation, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        return createDeterministicERC1967I(0, implementation, salt);\\n    }\\n\\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\\n            // Compute and store the bytecode hash.\\n            mstore(add(m, 0x35), keccak256(0x0c, 0x74))\\n            mstore(m, shl(88, address()))\\n            mstore8(m, 0xff) // Write the prefix.\\n            mstore(add(m, 0x15), salt)\\n            instance := keccak256(m, 0x55)\\n            for {} 1 {} {\\n                if iszero(extcodesize(instance)) {\\n                    instance := create2(value, 0x0c, 0x74, salt)\\n                    if iszero(instance) {\\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    break\\n                }\\n                alreadyDeployed := 1\\n                if iszero(value) { break }\\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                break\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation`.\\n    function initCodeERC1967I(address implementation) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(\\n                add(result, 0x74),\\n                0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3\\n            )\\n            mstore(\\n                add(result, 0x54),\\n                0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4\\n            )\\n            mstore(add(result, 0x34), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\\n            mstore(add(result, 0x1d), implementation)\\n            mstore(add(result, 0x09), 0x60523d8160223d3973)\\n            mstore(add(result, 0x94), 0)\\n            mstore(result, 0x74) // Store the length.\\n            mstore(0x40, add(result, 0xa0)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHashERC1967I(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\\n            hash := keccak256(0x0c, 0x74)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic ERC1967I proxy of `implementation`,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddressERC1967I(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHashERC1967I(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*            CONSTANT ERC1967 BOOTSTRAP OPERATIONS           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: This enables an ERC1967 proxy to be deployed at a deterministic address\\n    // independent of the implementation:\\n    // ```\\n    //     address bootstrap = LibClone.constantERC1967Bootstrap();\\n    //     address instance = LibClone.deployDeterministicERC1967(0, bootstrap, salt);\\n    //     LibClone.bootstrapConstantERC1967(bootstrap, implementation);\\n    // ```\\n\\n    /// @dev Deploys the constant ERC1967 bootstrap if it has not been deployed.\\n    function constantERC1967Bootstrap() internal returns (address bootstrap) {\\n        bootstrap = constantERC1967BootstrapAddress();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(extcodesize(bootstrap)) {\\n                mstore(0x20, 0x0894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc55)\\n                mstore(0x00, 0x60258060093d393df358357f36)\\n                if iszero(create2(0, 0x13, 0x2e, 0)) {\\n                    mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the implementation address of the ERC1967 bootstrap for this contract.\\n    function constantERC1967BootstrapAddress() internal view returns (address bootstrap) {\\n        bytes32 hash = 0xfe1a42b9c571a6a8c083c94ac67b9cfd74e2582923426aa3b762e3431d717cd1;\\n        bootstrap = predictDeterministicAddress(hash, bytes32(0), address(this));\\n    }\\n\\n    /// @dev Replaces the implementation at `instance`.\\n    function bootstrapERC1967(address instance, address implementation) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, shr(96, shl(96, implementation)))\\n            if iszero(call(gas(), instance, 0, 0x00, 0x20, codesize(), 0x00)) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*          MINIMAL ERC1967 BEACON PROXY OPERATIONS           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: If you use this proxy, you MUST make sure that the beacon is a\\n    // valid ERC1967 beacon. This means that the beacon must always return a valid\\n    // address upon a staticcall to `implementation()`, given sufficient gas.\\n    // For performance, the deployment operations and the proxy assumes that the\\n    // beacon is always valid and will NOT validate it.\\n\\n    /// @dev Deploys a minimal ERC1967 beacon proxy.\\n    function deployERC1967BeaconProxy(address beacon) internal returns (address instance) {\\n        instance = deployERC1967BeaconProxy(0, beacon);\\n    }\\n\\n    /// @dev Deploys a minimal ERC1967 beacon proxy.\\n    /// Deposits `value` ETH during deployment.\\n    function deployERC1967BeaconProxy(uint256 value, address beacon)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * ---------------------------------------------------------------------------------+\\n             * CREATION (34 bytes)                                                              |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\\n             * 81         | DUP2           | r 0 r            |                                 |\\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\\n             * 73 beac    | PUSH20 beac    | beac 0 r         | [0..runSize): runtime code      |\\n             * 60 slotPos | PUSH1 slotPos  | slotPos beac 0 r | [0..runSize): runtime code      |\\n             * 51         | MLOAD          | slot beac 0 r    | [0..runSize): runtime code      |\\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\\n             * ---------------------------------------------------------------------------------|\\n             * RUNTIME (82 bytes)                                                               |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             *                                                                                  |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36         | CALLDATASIZE   | cds              |                                 |\\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | 0                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ~~~~~~~ beacon staticcall sub procedure ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\\n             * 60 0x20       | PUSH1 0x20       | 32                          |                 |\\n             * 36            | CALLDATASIZE     | cds 32                      |                 |\\n             * 60 0x04       | PUSH1 0x04       | 4 cds 32                    |                 |\\n             * 36            | CALLDATASIZE     | cds 4 cds 32                |                 |\\n             * 63 0x5c60da1b | PUSH4 0x5c60da1b | 0x5c60da1b cds 4 cds 32     |                 |\\n             * 60 0xe0       | PUSH1 0xe0       | 224 0x5c60da1b cds 4 cds 32 |                 |\\n             * 1b            | SHL              | sel cds 4 cds 32            |                 |\\n             * 36            | CALLDATASIZE     | cds sel cds 4 cds 32        |                 |\\n             * 52            | MSTORE           | cds 4 cds 32                | sel             |\\n             * 7f slot       | PUSH32 slot      | s cds 4 cds 32              | sel             |\\n             * 54            | SLOAD            | beac cds 4 cds 32           | sel             |\\n             * 5a            | GAS              | g beac cds 4 cds 32         | sel             |\\n             * fa            | STATICCALL       | succ                        | impl            |\\n             * 50            | POP              |                             | impl            |\\n             * 36            | CALLDATASIZE     | cds                         | impl            |\\n             * 51            | MLOAD            | impl                        | impl            |\\n             * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\\n             * 5a         | GAS            | g impl 0 cds 0 0 | [0..calldatasize): calldata     |\\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 60 0x4d    | PUSH1 0x4d     | dest succ        | [0..returndatasize): returndata |\\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\\n             * ---------------------------------------------------------------------------------+\\n             */\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\\n            instance := create(value, 0x0c, 0x74)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic minimal ERC1967 beacon proxy with `salt`.\\n    function deployDeterministicERC1967BeaconProxy(address beacon, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = deployDeterministicERC1967BeaconProxy(0, beacon, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic minimal ERC1967 beacon proxy with `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    function deployDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\\n            instance := create2(value, 0x0c, 0x74, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Creates a deterministic minimal ERC1967 beacon proxy with `salt`.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967BeaconProxy(address beacon, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        return createDeterministicERC1967BeaconProxy(0, beacon, salt);\\n    }\\n\\n    /// @dev Creates a deterministic minimal ERC1967 beacon proxy with `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\\n            // Compute and store the bytecode hash.\\n            mstore(add(m, 0x35), keccak256(0x0c, 0x74))\\n            mstore(m, shl(88, address()))\\n            mstore8(m, 0xff) // Write the prefix.\\n            mstore(add(m, 0x15), salt)\\n            instance := keccak256(m, 0x55)\\n            for {} 1 {} {\\n                if iszero(extcodesize(instance)) {\\n                    instance := create2(value, 0x0c, 0x74, salt)\\n                    if iszero(instance) {\\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    break\\n                }\\n                alreadyDeployed := 1\\n                if iszero(value) { break }\\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                break\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code of the minimal ERC1967 beacon proxy.\\n    function initCodeERC1967BeaconProxy(address beacon)\\n        internal\\n        pure\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(\\n                add(result, 0x74),\\n                0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3\\n            )\\n            mstore(\\n                add(result, 0x54),\\n                0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c\\n            )\\n            mstore(add(result, 0x34), 0x60195155f3363d3d373d3d363d602036600436635c60da)\\n            mstore(add(result, 0x1d), beacon)\\n            mstore(add(result, 0x09), 0x60523d8160223d3973)\\n            mstore(add(result, 0x94), 0)\\n            mstore(result, 0x74) // Store the length.\\n            mstore(0x40, add(result, 0xa0)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the minimal ERC1967 beacon proxy.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHashERC1967BeaconProxy(address beacon) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\\n            hash := keccak256(0x0c, 0x74)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic ERC1967 beacon proxy,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddressERC1967BeaconProxy(\\n        address beacon,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHashERC1967BeaconProxy(beacon);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      OTHER OPERATIONS                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the address when a contract with initialization code hash,\\n    /// `hash`, is deployed with `salt`, by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\\n        internal\\n        pure\\n        returns (address predicted)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and store the bytecode hash.\\n            mstore8(0x00, 0xff) // Write the prefix.\\n            mstore(0x35, hash)\\n            mstore(0x01, shl(96, deployer))\\n            mstore(0x15, salt)\\n            predicted := keccak256(0x00, 0x55)\\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Requires that `salt` starts with either the zero address or `by`.\\n    function checkStartsWith(bytes32 salt, address by) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the salt does not start with the zero address or `by`.\\n            if iszero(or(iszero(shr(96, salt)), eq(shr(96, shl(96, by)), shr(96, salt)))) {\\n                mstore(0x00, 0x0c4549ef) // `SaltDoesNotStartWith()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xeef85d149b91730bbcf9a657bcd716de80ad0919b9e085beb9c018eb451c0aa1\",\"license\":\"MIT\"},\"solady/utils/SignatureCheckerLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Signature verification helper that supports both ECDSA signatures from EOAs\\n/// and ERC1271 signatures from smart contract wallets like Argent and Gnosis safe.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SignatureCheckerLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/SignatureChecker.sol)\\n///\\n/// @dev Note:\\n/// - The signature checking functions use the ecrecover precompile (0x1).\\n/// - The `bytes memory signature` variants use the identity precompile (0x4)\\n///   to copy memory internally.\\n/// - Unlike ECDSA signatures, contract signatures are revocable.\\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\\n///   See: https://eips.ethereum.org/EIPS/eip-2098\\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\\n///\\n/// WARNING! Do NOT use signatures as unique identifiers:\\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\\n///   EIP-712 also enables readable signing of typed data for better user safety.\\n/// This implementation does NOT check if a signature is non-malleable.\\nlibrary SignatureCheckerLib {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*               SIGNATURE CHECKING OPERATIONS                */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits of `signer` in case they are dirty.\\n            for { signer := shr(96, shl(96, signer)) } signer {} {\\n                let m := mload(0x40)\\n                mstore(0x00, hash)\\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\\n                if eq(mload(signature), 64) {\\n                    let vs := mload(add(signature, 0x40))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    let t :=\\n                        staticcall(\\n                            gas(), // Amount of gas left for the transaction.\\n                            1, // Address of `ecrecover`.\\n                            0x00, // Start of input.\\n                            0x80, // Size of input.\\n                            0x01, // Start of output.\\n                            0x20 // Size of output.\\n                        )\\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                        isValid := 1\\n                        mstore(0x60, 0) // Restore the zero slot.\\n                        mstore(0x40, m) // Restore the free memory pointer.\\n                        break\\n                    }\\n                }\\n                if eq(mload(signature), 65) {\\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\\n                    let t :=\\n                        staticcall(\\n                            gas(), // Amount of gas left for the transaction.\\n                            1, // Address of `ecrecover`.\\n                            0x00, // Start of input.\\n                            0x80, // Size of input.\\n                            0x01, // Start of output.\\n                            0x20 // Size of output.\\n                        )\\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                        isValid := 1\\n                        mstore(0x60, 0) // Restore the zero slot.\\n                        mstore(0x40, m) // Restore the free memory pointer.\\n                        break\\n                    }\\n                }\\n                mstore(0x60, 0) // Restore the zero slot.\\n                mstore(0x40, m) // Restore the free memory pointer.\\n\\n                let f := shl(224, 0x1626ba7e)\\n                mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m, 0x04), hash)\\n                let d := add(m, 0x24)\\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n                // Copy the `signature` over.\\n                let n := add(0x20, mload(signature))\\n                pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\\n                // forgefmt: disable-next-item\\n                isValid := and(\\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                    eq(mload(d), f),\\n                    // Whether the staticcall does not revert.\\n                    // This must be placed at the end of the `and` clause,\\n                    // as the arguments are evaluated from right to left.\\n                    staticcall(\\n                        gas(), // Remaining gas.\\n                        signer, // The `signer` address.\\n                        m, // Offset of calldata in memory.\\n                        add(returndatasize(), 0x44), // Length of calldata in memory.\\n                        d, // Offset of returndata.\\n                        0x20 // Length of returndata to write.\\n                    )\\n                )\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns whether `signature` is valid for `signer` and `hash`.\\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\\n    function isValidSignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits of `signer` in case they are dirty.\\n            for { signer := shr(96, shl(96, signer)) } signer {} {\\n                let m := mload(0x40)\\n                mstore(0x00, hash)\\n                if eq(signature.length, 64) {\\n                    let vs := calldataload(add(signature.offset, 0x20))\\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                    let t :=\\n                        staticcall(\\n                            gas(), // Amount of gas left for the transaction.\\n                            1, // Address of `ecrecover`.\\n                            0x00, // Start of input.\\n                            0x80, // Size of input.\\n                            0x01, // Start of output.\\n                            0x20 // Size of output.\\n                        )\\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                        isValid := 1\\n                        mstore(0x60, 0) // Restore the zero slot.\\n                        mstore(0x40, m) // Restore the free memory pointer.\\n                        break\\n                    }\\n                }\\n                if eq(signature.length, 65) {\\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\\n                    calldatacopy(0x40, signature.offset, 0x40) // `r`, `s`.\\n                    let t :=\\n                        staticcall(\\n                            gas(), // Amount of gas left for the transaction.\\n                            1, // Address of `ecrecover`.\\n                            0x00, // Start of input.\\n                            0x80, // Size of input.\\n                            0x01, // Start of output.\\n                            0x20 // Size of output.\\n                        )\\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                    if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                        isValid := 1\\n                        mstore(0x60, 0) // Restore the zero slot.\\n                        mstore(0x40, m) // Restore the free memory pointer.\\n                        break\\n                    }\\n                }\\n                mstore(0x60, 0) // Restore the zero slot.\\n                mstore(0x40, m) // Restore the free memory pointer.\\n\\n                let f := shl(224, 0x1626ba7e)\\n                mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m, 0x04), hash)\\n                let d := add(m, 0x24)\\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n                mstore(add(m, 0x44), signature.length)\\n                // Copy the `signature` over.\\n                calldatacopy(add(m, 0x64), signature.offset, signature.length)\\n                // forgefmt: disable-next-item\\n                isValid := and(\\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                    eq(mload(d), f),\\n                    // Whether the staticcall does not revert.\\n                    // This must be placed at the end of the `and` clause,\\n                    // as the arguments are evaluated from right to left.\\n                    staticcall(\\n                        gas(), // Remaining gas.\\n                        signer, // The `signer` address.\\n                        m, // Offset of calldata in memory.\\n                        add(signature.length, 0x64), // Length of calldata in memory.\\n                        d, // Offset of returndata.\\n                        0x20 // Length of returndata to write.\\n                    )\\n                )\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `signer` and `hash`.\\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits of `signer` in case they are dirty.\\n            for { signer := shr(96, shl(96, signer)) } signer {} {\\n                let m := mload(0x40)\\n                mstore(0x00, hash)\\n                mstore(0x20, add(shr(255, vs), 27)) // `v`.\\n                mstore(0x40, r) // `r`.\\n                mstore(0x60, shr(1, shl(1, vs))) // `s`.\\n                let t :=\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                    isValid := 1\\n                    mstore(0x60, 0) // Restore the zero slot.\\n                    mstore(0x40, m) // Restore the free memory pointer.\\n                    break\\n                }\\n\\n                let f := shl(224, 0x1626ba7e)\\n                mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m, 0x04), hash)\\n                let d := add(m, 0x24)\\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n                mstore(add(m, 0x44), 65) // Length of the signature.\\n                mstore(add(m, 0x64), r) // `r`.\\n                mstore(add(m, 0x84), mload(0x60)) // `s`.\\n                mstore8(add(m, 0xa4), mload(0x20)) // `v`.\\n                // forgefmt: disable-next-item\\n                isValid := and(\\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                    eq(mload(d), f),\\n                    // Whether the staticcall does not revert.\\n                    // This must be placed at the end of the `and` clause,\\n                    // as the arguments are evaluated from right to left.\\n                    staticcall(\\n                        gas(), // Remaining gas.\\n                        signer, // The `signer` address.\\n                        m, // Offset of calldata in memory.\\n                        0xa5, // Length of calldata in memory.\\n                        d, // Offset of returndata.\\n                        0x20 // Length of returndata to write.\\n                    )\\n                )\\n                mstore(0x60, 0) // Restore the zero slot.\\n                mstore(0x40, m) // Restore the free memory pointer.\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `signer` and `hash`.\\n    /// If `signer` is a smart contract, the signature is validated with ERC1271.\\n    /// Otherwise, the signature is validated with `ECDSA.recover`.\\n    function isValidSignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits of `signer` in case they are dirty.\\n            for { signer := shr(96, shl(96, signer)) } signer {} {\\n                let m := mload(0x40)\\n                mstore(0x00, hash)\\n                mstore(0x20, and(v, 0xff)) // `v`.\\n                mstore(0x40, r) // `r`.\\n                mstore(0x60, s) // `s`.\\n                let t :=\\n                    staticcall(\\n                        gas(), // Amount of gas left for the transaction.\\n                        1, // Address of `ecrecover`.\\n                        0x00, // Start of input.\\n                        0x80, // Size of input.\\n                        0x01, // Start of output.\\n                        0x20 // Size of output.\\n                    )\\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                if iszero(or(iszero(returndatasize()), xor(signer, mload(t)))) {\\n                    isValid := 1\\n                    mstore(0x60, 0) // Restore the zero slot.\\n                    mstore(0x40, m) // Restore the free memory pointer.\\n                    break\\n                }\\n\\n                let f := shl(224, 0x1626ba7e)\\n                mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m, 0x04), hash)\\n                let d := add(m, 0x24)\\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n                mstore(add(m, 0x44), 65) // Length of the signature.\\n                mstore(add(m, 0x64), r) // `r`.\\n                mstore(add(m, 0x84), s) // `s`.\\n                mstore8(add(m, 0xa4), v) // `v`.\\n                // forgefmt: disable-next-item\\n                isValid := and(\\n                    // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                    eq(mload(d), f),\\n                    // Whether the staticcall does not revert.\\n                    // This must be placed at the end of the `and` clause,\\n                    // as the arguments are evaluated from right to left.\\n                    staticcall(\\n                        gas(), // Remaining gas.\\n                        signer, // The `signer` address.\\n                        m, // Offset of calldata in memory.\\n                        0xa5, // Length of calldata in memory.\\n                        d, // Offset of returndata.\\n                        0x20 // Length of returndata to write.\\n                    )\\n                )\\n                mstore(0x60, 0) // Restore the zero slot.\\n                mstore(0x40, m) // Restore the free memory pointer.\\n                break\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     ERC1271 OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: These ERC1271 operations do NOT have an ECDSA fallback.\\n    // These functions are intended to be used with the regular `isValidSignatureNow` functions\\n    // or other signature verification functions (e.g. P256).\\n\\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes memory signature)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            let f := shl(224, 0x1626ba7e)\\n            mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n            mstore(add(m, 0x04), hash)\\n            let d := add(m, 0x24)\\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n            // Copy the `signature` over.\\n            let n := add(0x20, mload(signature))\\n            pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\\n            // forgefmt: disable-next-item\\n            isValid := and(\\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                eq(mload(d), f),\\n                // Whether the staticcall does not revert.\\n                // This must be placed at the end of the `and` clause,\\n                // as the arguments are evaluated from right to left.\\n                staticcall(\\n                    gas(), // Remaining gas.\\n                    signer, // The `signer` address.\\n                    m, // Offset of calldata in memory.\\n                    add(returndatasize(), 0x44), // Length of calldata in memory.\\n                    d, // Offset of returndata.\\n                    0x20 // Length of returndata to write.\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `signature` is valid for `hash` for an ERC1271 `signer` contract.\\n    function isValidERC1271SignatureNowCalldata(\\n        address signer,\\n        bytes32 hash,\\n        bytes calldata signature\\n    ) internal view returns (bool isValid) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            let f := shl(224, 0x1626ba7e)\\n            mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n            mstore(add(m, 0x04), hash)\\n            let d := add(m, 0x24)\\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n            mstore(add(m, 0x44), signature.length)\\n            // Copy the `signature` over.\\n            calldatacopy(add(m, 0x64), signature.offset, signature.length)\\n            // forgefmt: disable-next-item\\n            isValid := and(\\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                eq(mload(d), f),\\n                // Whether the staticcall does not revert.\\n                // This must be placed at the end of the `and` clause,\\n                // as the arguments are evaluated from right to left.\\n                staticcall(\\n                    gas(), // Remaining gas.\\n                    signer, // The `signer` address.\\n                    m, // Offset of calldata in memory.\\n                    add(signature.length, 0x64), // Length of calldata in memory.\\n                    d, // Offset of returndata.\\n                    0x20 // Length of returndata to write.\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether the signature (`r`, `vs`) is valid for `hash`\\n    /// for an ERC1271 `signer` contract.\\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            let f := shl(224, 0x1626ba7e)\\n            mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n            mstore(add(m, 0x04), hash)\\n            let d := add(m, 0x24)\\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n            mstore(add(m, 0x44), 65) // Length of the signature.\\n            mstore(add(m, 0x64), r) // `r`.\\n            mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.\\n            mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.\\n            // forgefmt: disable-next-item\\n            isValid := and(\\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                eq(mload(d), f),\\n                // Whether the staticcall does not revert.\\n                // This must be placed at the end of the `and` clause,\\n                // as the arguments are evaluated from right to left.\\n                staticcall(\\n                    gas(), // Remaining gas.\\n                    signer, // The `signer` address.\\n                    m, // Offset of calldata in memory.\\n                    0xa5, // Length of calldata in memory.\\n                    d, // Offset of returndata.\\n                    0x20 // Length of returndata to write.\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether the signature (`v`, `r`, `s`) is valid for `hash`\\n    /// for an ERC1271 `signer` contract.\\n    function isValidERC1271SignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\\n        internal\\n        view\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40)\\n            let f := shl(224, 0x1626ba7e)\\n            mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n            mstore(add(m, 0x04), hash)\\n            let d := add(m, 0x24)\\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\\n            mstore(add(m, 0x44), 65) // Length of the signature.\\n            mstore(add(m, 0x64), r) // `r`.\\n            mstore(add(m, 0x84), s) // `s`.\\n            mstore8(add(m, 0xa4), v) // `v`.\\n            // forgefmt: disable-next-item\\n            isValid := and(\\n                // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                eq(mload(d), f),\\n                // Whether the staticcall does not revert.\\n                // This must be placed at the end of the `and` clause,\\n                // as the arguments are evaluated from right to left.\\n                staticcall(\\n                    gas(), // Remaining gas.\\n                    signer, // The `signer` address.\\n                    m, // Offset of calldata in memory.\\n                    0xa5, // Length of calldata in memory.\\n                    d, // Offset of returndata.\\n                    0x20 // Length of returndata to write.\\n                )\\n            )\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     ERC6492 OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: These ERC6492 operations do NOT have an ECDSA fallback.\\n    // These functions are intended to be used with the regular `isValidSignatureNow` functions\\n    // or other signature verification functions (e.g. P256).\\n    // The calldata variants are excluded for brevity.\\n\\n    /// @dev Returns whether `signature` is valid for `hash`.\\n    /// If the signature is postfixed with the ERC6492 magic number, it will attempt to\\n    /// deploy / prepare the `signer` smart account before doing a regular ERC1271 check.\\n    /// Note: This function is NOT reentrancy safe.\\n    function isValidERC6492SignatureNowAllowSideEffects(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal returns (bool isValid) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function callIsValidSignature(signer_, hash_, signature_) -> _isValid {\\n                let m_ := mload(0x40)\\n                let f_ := shl(224, 0x1626ba7e)\\n                mstore(m_, f_) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m_, 0x04), hash_)\\n                let d_ := add(m_, 0x24)\\n                mstore(d_, 0x40) // The offset of the `signature` in the calldata.\\n                let n_ := add(0x20, mload(signature_))\\n                pop(staticcall(gas(), 4, signature_, n_, add(m_, 0x44), n_))\\n                _isValid :=\\n                    and(\\n                        eq(mload(d_), f_),\\n                        staticcall(gas(), signer_, m_, add(returndatasize(), 0x44), d_, 0x20)\\n                    )\\n            }\\n            for { let n := mload(signature) } 1 {} {\\n                if iszero(eq(mload(add(signature, n)), mul(0x6492, div(not(isValid), 0xffff)))) {\\n                    isValid := callIsValidSignature(signer, hash, signature)\\n                    break\\n                }\\n                let o := add(signature, 0x20) // Signature bytes.\\n                let d := add(o, mload(add(o, 0x20))) // Factory calldata.\\n                if iszero(extcodesize(signer)) {\\n                    if iszero(call(gas(), mload(o), 0, add(d, 0x20), mload(d), codesize(), 0x00)) {\\n                        break\\n                    }\\n                }\\n                let s := add(o, mload(add(o, 0x40))) // Inner signature.\\n                isValid := callIsValidSignature(signer, hash, s)\\n                if iszero(isValid) {\\n                    if call(gas(), mload(o), 0, add(d, 0x20), mload(d), codesize(), 0x00) {\\n                        isValid := callIsValidSignature(signer, hash, s)\\n                    }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns whether `signature` is valid for `hash`.\\n    /// If the signature is postfixed with the ERC6492 magic number, it will attempt\\n    /// to use a reverting verifier to deploy / prepare the `signer` smart account\\n    /// and do a `isValidSignature` check via the reverting verifier.\\n    /// Note: This function is reentrancy safe.\\n    /// The reverting verifier must be be deployed.\\n    /// Otherwise, the function will return false if `signer` is not yet deployed / prepared.\\n    /// See: https://gist.github.com/Vectorized/846a474c855eee9e441506676800a9ad\\n    function isValidERC6492SignatureNow(address signer, bytes32 hash, bytes memory signature)\\n        internal\\n        returns (bool isValid)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            function callIsValidSignature(signer_, hash_, signature_) -> _isValid {\\n                let m_ := mload(0x40)\\n                let f_ := shl(224, 0x1626ba7e)\\n                mstore(m_, f_) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m_, 0x04), hash_)\\n                let d_ := add(m_, 0x24)\\n                mstore(d_, 0x40) // The offset of the `signature` in the calldata.\\n                let n_ := add(0x20, mload(signature_))\\n                pop(staticcall(gas(), 4, signature_, n_, add(m_, 0x44), n_))\\n                _isValid :=\\n                    and(\\n                        eq(mload(d_), f_),\\n                        staticcall(gas(), signer_, m_, add(returndatasize(), 0x44), d_, 0x20)\\n                    )\\n            }\\n            for { let n := mload(signature) } 1 {} {\\n                if iszero(eq(mload(add(signature, n)), mul(0x6492, div(not(isValid), 0xffff)))) {\\n                    isValid := callIsValidSignature(signer, hash, signature)\\n                    break\\n                }\\n                if extcodesize(signer) {\\n                    let o := add(signature, 0x20) // Signature bytes.\\n                    isValid := callIsValidSignature(signer, hash, add(o, mload(add(o, 0x40))))\\n                    if isValid { break }\\n                }\\n                let m := mload(0x40)\\n                mstore(m, signer)\\n                mstore(add(m, 0x20), hash)\\n                let willBeZeroIfRevertingVerifierExists :=\\n                    call(\\n                        gas(), // Remaining gas.\\n                        0x00007bd799e4A591FeA53f8A8a3E9f931626Ba7e, // Reverting verifier.\\n                        0, // Send zero ETH.\\n                        m, // Start of memory.\\n                        add(returndatasize(), 0x40), // Length of calldata in memory.\\n                        staticcall(gas(), 4, add(signature, 0x20), n, add(m, 0x40), n), // 1.\\n                        0x00 // Length of returndata to write.\\n                    )\\n                isValid := gt(returndatasize(), willBeZeroIfRevertingVerifierExists)\\n                break\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     HASHING OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, hash) // Store into scratch space for keccak256.\\n            mstore(0x00, \\\"\\\\x00\\\\x00\\\\x00\\\\x00\\\\x19Ethereum Signed Message:\\\\n32\\\") // 28 bytes.\\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\\n        }\\n    }\\n\\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\\n    /// This produces a hash corresponding to the one signed with the\\n    /// [`eth_sign`](https://eth.wiki/json-rpc/API#eth_sign)\\n    /// JSON-RPC method as part of EIP-191.\\n    /// Note: Supports lengths of `s` up to 999999 bytes.\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let sLength := mload(s)\\n            let o := 0x20\\n            mstore(o, \\\"\\\\x19Ethereum Signed Message:\\\\n\\\") // 26 bytes, zero-right-padded.\\n            mstore(0x00, 0x00)\\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\\n            for { let temp := sLength } 1 {} {\\n                o := sub(o, 1)\\n                mstore8(o, add(48, mod(temp, 10)))\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\\n            mstore(s, sLength) // Restore the length.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   EMPTY CALLDATA HELPERS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns an empty calldata bytes.\\n    function emptySignature() internal pure returns (bytes calldata signature) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            signature.length := 0\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x43e24246cc3e120f2d8e979f58bf28e2a84e3cac47d9653845a2b2af16a00d99\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60808060405234601557610f14908161001b8239f35b600080fdfe6040608081526004908136101561001557600080fd5b600090813560e01c806306fdde031461072757806351b037901461069457806354fd4d501461063e5780636d61fe70146106045780638a91b0e3146105ce5780639479b011146104e45780639700320314610498578063c037ee191461044b578063c7305b1714610400578063ced2023214610327578063d56842fe14610277578063d60b347f14610252578063d8d38e42146101ad578063ecd0596114610174578063f4d2a1941461011c5763f551e2ee146100d157600080fd5b34610118576060366003190112610118576100ea6107be565b5060443567ffffffffffffffff81116101145760209361010c913691016107d9565b505051908152f35b8280fd5b5080fd5b50346101185760203660031901126101185760209061016b61013c6107be565b6001600160a01b0316600052600160205260406000203360005260205260ff60016040600020015460301c1690565b90519015158152f35b50823461011457602036600319011261011457602092503590600182149182156101a2575b50519015158152f35b600214915083610199565b50829034610114576020366003190112610114576001600160a01b036101d16107be565b1691828452600160205281842033855260205265ffffffffffff60018386200154161561023d575060018391838352816020528083203384526020528220828155015533907ffed2ef743855f014248940ee5ec9f0e777462c94ab9c0218f7df27d5acf963958380a380f35b82602492519163bf7faead60e01b8352820152fd5b503461011857602036600319011261011857906020916102706107be565b5051908152f35b50346101185760c0366003190112610118576102916107be565b9060a0366023190112610114576102a6610807565b906024356001600160a01b03811681036103235782526044356001600160e01b03198116810361032357602083015260643565ffffffffffff91828216820361031f57830152608435908116810361031b57606082015260a43591821515830361031b57610318926080830152610de3565b80f35b8380fd5b8580fd5b8480fd5b5090346103fd576020806003193601126101185760018360a0946103496107be565b94806080610355610807565b8281528288820152828582015282606082015201526001600160a01b0380961681528385528181203382528552209061038c610807565b918054958616958684526001600160e01b031995808501968083861b16885265ffffffffffff968794858789019560c01c16855201549760ff60806060890198878c168a52019960301c16151589528551998a52511690880152511690850152511660608301525115156080820152f35b80fd5b50346101185780600319360112610118576104196107be565b6024356001600160a01b0380921684528360205282842080548210156103235784526020938490200154915191168152f35b5082346101145760031990828236011261031b576104676107be565b936024359267ffffffffffffffff8411610118576101209084360301126103fd57509261016b916020940190610b6a565b5090346103fd576003199082823601126103fd5783359167ffffffffffffffff8311610118576101209083360301126103fd57506020926104dd916024359101610953565b9051908152f35b508234610114576020366003190112610114576001600160a01b036105076107be565b169182845260016020528084203385526020526001818520019182549165ffffffffffff8316156105b857505060ff8160301c1660001461057a5750805466ff0000000000001916905533907f372387852d8cf935f1b241dc2c9401f2de07256dc3b7624f41771a65aa8c30588380a380f35b66ff0000000000001916660100000000000017905533907f295a27d3639cc5db57f2823fa52be0046afef8b8a991ed07a36ed22a07d98dc68380a380f35b9084602492519163bf7faead60e01b8352820152fd5b8284346101185760203660031901126101185780359067ffffffffffffffff8211610114576105ff913691016107d9565b505080f35b82843461011857602036600319011261011857803567ffffffffffffffff81116101145761031891610638913691016107d9565b90610870565b50346101185781600319360112610118576106909061065b61083d565b90600582527f302e302e3100000000000000000000000000000000000000000000000000000060208301525191829182610775565b0390f35b50346101185780600319360112610118576106ad6107be565b906024356001600160a01b0392838216809203610323578260a09560ff94938660019416825283602052828220908252602052209182549265ffffffffffff928391015493825196811687526001600160e01b031981841b16602088015260c01c16908501528116606084015260301c1615156080820152f35b50346101185781600319360112610118576106909061074461083d565b90601482527f4175746f44434153657373696f6e4d6f64756c65000000000000000000000000602083015251918291825b6020808252825181830181905290939260005b8281106107aa57505060409293506000838284010152601f8019910116010190565b818101860151848201604001528501610788565b600435906001600160a01b03821682036107d457565b600080fd5b9181601f840112156107d45782359167ffffffffffffffff83116107d457602083818601950101116107d457565b6040519060a0820182811067ffffffffffffffff82111761082757604052565b634e487b7160e01b600052604160045260246000fd5b604051906040820182811067ffffffffffffffff82111761082757604052565b359065ffffffffffff821682036107d457565b90801561091c57819081010360c081126107d4578135916001600160a01b03918284168094036107d45760a090601f1901126107d4576108ae610807565b91602082013590811681036107d45782526040810135906001600160e01b0319821682036107d45760a09160208401526108ea6060820161085d565b60408401526108fb6080820161085d565b606084015201359182151583036107d45761091a926080830152610de3565b565b5050565b903590601e19813603018212156107d4570180359067ffffffffffffffff82116107d4576020019181360383136107d457565b60209182526000907b19457468657265756d205369676e6564204d6573736167653a0a33328252603c60042061098d610100830183610920565b67ffffffffffffffff9391848211610b1e57601f1991604095865193603f81601f850116011684019084821090821117610b0a578652808352878301913682820111610b0657928783818b858b96610a219a998399378501015260019084519883525184528380845114610acd57506041835114610ab5575060809150805b5afa50846060523d6060185192845282610b6a565b15610aac5760018260ff936080956001600160a01b03809516815283885281812033825288522090610a51610807565b96825494851688526001600160e01b031985831b169088015265ffffffffffff809460c01c16908701520154908116606085015260301c16151591015279ffffffffffff000000000000000000000000000000000000000090565b50505050600190565b6080928460609182810151851a885201519052610a0c565b7f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff906080940151601b8160ff1c01875216606052610a0c565b8780fd5b602488634e487b7160e01b81526041600452fd5b602486634e487b7160e01b81526041600452fd5b9190811015610b545760051b81013590605e19813603018212156107d4570190565b634e487b7160e01b600052603260045260246000fd5b906001600160a01b0360009080841682526001936001602052604093604084203385526020526040842090610b9d610807565b90610c1a835494868616845260ff6001600160e01b03199660016020870197898360401b16895265ffffffffffff809360c01c1660408901520154908116606087015260301c16151560808501526001600160a01b0316600052600160205260406000203360005260205260ff60016040600020015460301c1690565b15610dd857806060610c2d920190610920565b949060049580600411610b0657813586167fe9ae5c530000000000000000000000000000000000000000000000000000000003610d6c5780602411610b06577fff000000000000000000000000000000000000000000000000000000000000006004830135168015610d79577f010000000000000000000000000000000000000000000000000000000000000003610d6c57606411610d68576064810135019160646084840193013597875b898110610cf0575050505050505050505050600190565b610cfb818b87610b32565b35848116809103610d6457610d1d610d14838d89610b32565b84810190610920565b8a92919211610d60578585511603610d5157878088511691351603610d43578a01610cd9565b505050505050505091505090565b50505050505050505091505090565b8a80fd5b8980fd5b8680fd5b5050505050505091505090565b509293955096509294965080606411610d6857606319810180601411610b0657603411610d68576097190160041161031f575116606484013560601c03610dd2578160989151169201351603610dcf5750600190565b90565b50505090565b505050505091505090565b906001600160a01b038092169060016000938385528160205260408520338652602052604085209083511681549077ffffffff0000000000000000000000000000000000000000602086015160401c16907fffff0000000000000000000000000000000000000000000000000000000000007dffffffffffff000000000000000000000000000000000000000000000000604088015160c01b1693161717178155019065ffffffffffff60608201511666ff00000000000060808454930151151560301b169166ffffffffffffff1916171790557f18181a00afae36a38027e087bdecba0ee3dd48839669ffb2b1484450c703267b339280a356fea2646970667358221220854ec62edeaf66686c379050e8d01f402b679458f5d4e8993474ce4960f94cdb64736f6c63430008190033",
  "deployedBytecode": "0x6040608081526004908136101561001557600080fd5b600090813560e01c806306fdde031461072757806351b037901461069457806354fd4d501461063e5780636d61fe70146106045780638a91b0e3146105ce5780639479b011146104e45780639700320314610498578063c037ee191461044b578063c7305b1714610400578063ced2023214610327578063d56842fe14610277578063d60b347f14610252578063d8d38e42146101ad578063ecd0596114610174578063f4d2a1941461011c5763f551e2ee146100d157600080fd5b34610118576060366003190112610118576100ea6107be565b5060443567ffffffffffffffff81116101145760209361010c913691016107d9565b505051908152f35b8280fd5b5080fd5b50346101185760203660031901126101185760209061016b61013c6107be565b6001600160a01b0316600052600160205260406000203360005260205260ff60016040600020015460301c1690565b90519015158152f35b50823461011457602036600319011261011457602092503590600182149182156101a2575b50519015158152f35b600214915083610199565b50829034610114576020366003190112610114576001600160a01b036101d16107be565b1691828452600160205281842033855260205265ffffffffffff60018386200154161561023d575060018391838352816020528083203384526020528220828155015533907ffed2ef743855f014248940ee5ec9f0e777462c94ab9c0218f7df27d5acf963958380a380f35b82602492519163bf7faead60e01b8352820152fd5b503461011857602036600319011261011857906020916102706107be565b5051908152f35b50346101185760c0366003190112610118576102916107be565b9060a0366023190112610114576102a6610807565b906024356001600160a01b03811681036103235782526044356001600160e01b03198116810361032357602083015260643565ffffffffffff91828216820361031f57830152608435908116810361031b57606082015260a43591821515830361031b57610318926080830152610de3565b80f35b8380fd5b8580fd5b8480fd5b5090346103fd576020806003193601126101185760018360a0946103496107be565b94806080610355610807565b8281528288820152828582015282606082015201526001600160a01b0380961681528385528181203382528552209061038c610807565b918054958616958684526001600160e01b031995808501968083861b16885265ffffffffffff968794858789019560c01c16855201549760ff60806060890198878c168a52019960301c16151589528551998a52511690880152511690850152511660608301525115156080820152f35b80fd5b50346101185780600319360112610118576104196107be565b6024356001600160a01b0380921684528360205282842080548210156103235784526020938490200154915191168152f35b5082346101145760031990828236011261031b576104676107be565b936024359267ffffffffffffffff8411610118576101209084360301126103fd57509261016b916020940190610b6a565b5090346103fd576003199082823601126103fd5783359167ffffffffffffffff8311610118576101209083360301126103fd57506020926104dd916024359101610953565b9051908152f35b508234610114576020366003190112610114576001600160a01b036105076107be565b169182845260016020528084203385526020526001818520019182549165ffffffffffff8316156105b857505060ff8160301c1660001461057a5750805466ff0000000000001916905533907f372387852d8cf935f1b241dc2c9401f2de07256dc3b7624f41771a65aa8c30588380a380f35b66ff0000000000001916660100000000000017905533907f295a27d3639cc5db57f2823fa52be0046afef8b8a991ed07a36ed22a07d98dc68380a380f35b9084602492519163bf7faead60e01b8352820152fd5b8284346101185760203660031901126101185780359067ffffffffffffffff8211610114576105ff913691016107d9565b505080f35b82843461011857602036600319011261011857803567ffffffffffffffff81116101145761031891610638913691016107d9565b90610870565b50346101185781600319360112610118576106909061065b61083d565b90600582527f302e302e3100000000000000000000000000000000000000000000000000000060208301525191829182610775565b0390f35b50346101185780600319360112610118576106ad6107be565b906024356001600160a01b0392838216809203610323578260a09560ff94938660019416825283602052828220908252602052209182549265ffffffffffff928391015493825196811687526001600160e01b031981841b16602088015260c01c16908501528116606084015260301c1615156080820152f35b50346101185781600319360112610118576106909061074461083d565b90601482527f4175746f44434153657373696f6e4d6f64756c65000000000000000000000000602083015251918291825b6020808252825181830181905290939260005b8281106107aa57505060409293506000838284010152601f8019910116010190565b818101860151848201604001528501610788565b600435906001600160a01b03821682036107d457565b600080fd5b9181601f840112156107d45782359167ffffffffffffffff83116107d457602083818601950101116107d457565b6040519060a0820182811067ffffffffffffffff82111761082757604052565b634e487b7160e01b600052604160045260246000fd5b604051906040820182811067ffffffffffffffff82111761082757604052565b359065ffffffffffff821682036107d457565b90801561091c57819081010360c081126107d4578135916001600160a01b03918284168094036107d45760a090601f1901126107d4576108ae610807565b91602082013590811681036107d45782526040810135906001600160e01b0319821682036107d45760a09160208401526108ea6060820161085d565b60408401526108fb6080820161085d565b606084015201359182151583036107d45761091a926080830152610de3565b565b5050565b903590601e19813603018212156107d4570180359067ffffffffffffffff82116107d4576020019181360383136107d457565b60209182526000907b19457468657265756d205369676e6564204d6573736167653a0a33328252603c60042061098d610100830183610920565b67ffffffffffffffff9391848211610b1e57601f1991604095865193603f81601f850116011684019084821090821117610b0a578652808352878301913682820111610b0657928783818b858b96610a219a998399378501015260019084519883525184528380845114610acd57506041835114610ab5575060809150805b5afa50846060523d6060185192845282610b6a565b15610aac5760018260ff936080956001600160a01b03809516815283885281812033825288522090610a51610807565b96825494851688526001600160e01b031985831b169088015265ffffffffffff809460c01c16908701520154908116606085015260301c16151591015279ffffffffffff000000000000000000000000000000000000000090565b50505050600190565b6080928460609182810151851a885201519052610a0c565b7f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff906080940151601b8160ff1c01875216606052610a0c565b8780fd5b602488634e487b7160e01b81526041600452fd5b602486634e487b7160e01b81526041600452fd5b9190811015610b545760051b81013590605e19813603018212156107d4570190565b634e487b7160e01b600052603260045260246000fd5b906001600160a01b0360009080841682526001936001602052604093604084203385526020526040842090610b9d610807565b90610c1a835494868616845260ff6001600160e01b03199660016020870197898360401b16895265ffffffffffff809360c01c1660408901520154908116606087015260301c16151560808501526001600160a01b0316600052600160205260406000203360005260205260ff60016040600020015460301c1690565b15610dd857806060610c2d920190610920565b949060049580600411610b0657813586167fe9ae5c530000000000000000000000000000000000000000000000000000000003610d6c5780602411610b06577fff000000000000000000000000000000000000000000000000000000000000006004830135168015610d79577f010000000000000000000000000000000000000000000000000000000000000003610d6c57606411610d68576064810135019160646084840193013597875b898110610cf0575050505050505050505050600190565b610cfb818b87610b32565b35848116809103610d6457610d1d610d14838d89610b32565b84810190610920565b8a92919211610d60578585511603610d5157878088511691351603610d43578a01610cd9565b505050505050505091505090565b50505050505050505091505090565b8a80fd5b8980fd5b8680fd5b5050505050505091505090565b509293955096509294965080606411610d6857606319810180601411610b0657603411610d68576097190160041161031f575116606484013560601c03610dd2578160989151169201351603610dcf5750600190565b90565b50505090565b505050505091505090565b906001600160a01b038092169060016000938385528160205260408520338652602052604085209083511681549077ffffffff0000000000000000000000000000000000000000602086015160401c16907fffff0000000000000000000000000000000000000000000000000000000000007dffffffffffff000000000000000000000000000000000000000000000000604088015160c01b1693161717178155019065ffffffffffff60608201511666ff00000000000060808454930151151560301b169166ffffffffffffff1916171790557f18181a00afae36a38027e087bdecba0ee3dd48839669ffb2b1484450c703267b339280a356fea2646970667358221220854ec62edeaf66686c379050e8d01f402b679458f5d4e8993474ce4960f94cdb64736f6c63430008190033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "enableSessionKey(address,(address,bytes4,uint48,uint48,bool))": {
        "details": "Adds a session key to the mapping."
      },
      "isInitialized(address)": {
        "details": "Returns if the module was already initialized for a provided smartaccount"
      },
      "onInstall(bytes)": {
        "details": "This function is called by the smart account during installation of the module",
        "params": {
          "data": "arbitrary data that may be required on the module during `onInstall` initialization MUST revert on error (i.e. if module is already enabled)"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 2402,
        "contract": "contracts/validator/SessionValidator.sol:SessionValidator",
        "label": "sessionKeyList",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_array(t_address)dyn_storage)"
      },
      {
        "astId": 2409,
        "contract": "contracts/validator/SessionValidator.sol:SessionValidator",
        "label": "sessionKeyData",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_mapping(t_address,t_struct(SessionData)2420_storage))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes4": {
        "encoding": "inplace",
        "label": "bytes4",
        "numberOfBytes": "4"
      },
      "t_mapping(t_address,t_array(t_address)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => address[])",
        "numberOfBytes": "32",
        "value": "t_array(t_address)dyn_storage"
      },
      "t_mapping(t_address,t_mapping(t_address,t_struct(SessionData)2420_storage))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => struct SessionValidator.SessionData))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_struct(SessionData)2420_storage)"
      },
      "t_mapping(t_address,t_struct(SessionData)2420_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct SessionValidator.SessionData)",
        "numberOfBytes": "32",
        "value": "t_struct(SessionData)2420_storage"
      },
      "t_struct(SessionData)2420_storage": {
        "encoding": "inplace",
        "label": "struct SessionValidator.SessionData",
        "members": [
          {
            "astId": 2411,
            "contract": "contracts/validator/SessionValidator.sol:SessionValidator",
            "label": "target",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 2413,
            "contract": "contracts/validator/SessionValidator.sol:SessionValidator",
            "label": "funcSelector",
            "offset": 20,
            "slot": "0",
            "type": "t_bytes4"
          },
          {
            "astId": 2415,
            "contract": "contracts/validator/SessionValidator.sol:SessionValidator",
            "label": "validAfter",
            "offset": 24,
            "slot": "0",
            "type": "t_uint48"
          },
          {
            "astId": 2417,
            "contract": "contracts/validator/SessionValidator.sol:SessionValidator",
            "label": "validUntil",
            "offset": 0,
            "slot": "1",
            "type": "t_uint48"
          },
          {
            "astId": 2419,
            "contract": "contracts/validator/SessionValidator.sol:SessionValidator",
            "label": "active",
            "offset": 6,
            "slot": "1",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint48": {
        "encoding": "inplace",
        "label": "uint48",
        "numberOfBytes": "6"
      }
    }
  }
}