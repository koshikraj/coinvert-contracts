{
  "address": "0x7362839Ede3E5f146740451075230d486FAf05db",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "smartAccount",
          "type": "address"
        }
      ],
      "name": "AlreadyInitialized",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSqrtPriceLimitX96",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LinkedList_AlreadyInitialized",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "entry",
          "type": "address"
        }
      ],
      "name": "LinkedList_EntryAlreadyInList",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "entry",
          "type": "address"
        }
      ],
      "name": "LinkedList_InvalidEntry",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LinkedList_InvalidPage",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "smartAccount",
          "type": "address"
        }
      ],
      "name": "NotInitialized",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "x",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "y",
          "type": "uint256"
        }
      ],
      "name": "PRBMath_MulDiv18_Overflow",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TooManyTokens",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "smartAccount",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        }
      ],
      "name": "AutoSaveExecuted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "ConfigSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "ModuleInitialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "ModuleUninitialized",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amountReceived",
          "type": "uint256"
        }
      ],
      "name": "autoSave",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountReceived",
          "type": "uint256"
        },
        {
          "internalType": "UD2x18",
          "name": "percentage",
          "type": "uint64"
        }
      ],
      "name": "calcDepositAmount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "config",
      "outputs": [
        {
          "internalType": "UD2x18",
          "name": "percentage",
          "type": "uint64"
        },
        {
          "internalType": "address",
          "name": "vault",
          "type": "address"
        },
        {
          "internalType": "uint128",
          "name": "sqrtPriceLimitX96",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "prevToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "deleteConfig",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "getTokens",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "tokensArray",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "smartAccount",
          "type": "address"
        }
      ],
      "name": "isInitialized",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "typeID",
          "type": "uint256"
        }
      ],
      "name": "isModuleType",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "onInstall",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "onUninstall",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "UD2x18",
              "name": "percentage",
              "type": "uint64"
            },
            {
              "internalType": "address",
              "name": "vault",
              "type": "address"
            },
            {
              "internalType": "uint128",
              "name": "sqrtPriceLimitX96",
              "type": "uint128"
            }
          ],
          "internalType": "struct AutoDCAModule.Config",
          "name": "_config",
          "type": "tuple"
        }
      ],
      "name": "setConfig",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "version",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x3d8b6f3192ef5777d0d8ee264585952a76da09416ddd48fb39aac892514bcf69",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x814a545d0F39Ae9Fa190c92968F3e1441952FB2C",
    "contractAddress": null,
    "transactionIndex": 41,
    "gasUsed": "1250004",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x9f23e7275b5c4e4454b1ad0d5493bc8717c00fc7b05722e983b85547cdefd472",
    "transactionHash": "0x3d8b6f3192ef5777d0d8ee264585952a76da09416ddd48fb39aac892514bcf69",
    "logs": [],
    "blockNumber": 6618482,
    "cumulativeGasUsed": "12956769",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "e912b3ad105dcc75c728c4f1c386c03b",
  "metadata": "{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartAccount\",\"type\":\"address\"}],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSqrtPriceLimitX96\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LinkedList_AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"entry\",\"type\":\"address\"}],\"name\":\"LinkedList_EntryAlreadyInList\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"entry\",\"type\":\"address\"}],\"name\":\"LinkedList_InvalidEntry\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LinkedList_InvalidPage\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartAccount\",\"type\":\"address\"}],\"name\":\"NotInitialized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"PRBMath_MulDiv18_Overflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooManyTokens\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"smartAccount\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"AutoSaveExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"ConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ModuleInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ModuleUninitialized\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"}],\"name\":\"autoSave\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"},{\"internalType\":\"UD2x18\",\"name\":\"percentage\",\"type\":\"uint64\"}],\"name\":\"calcDepositAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"config\",\"outputs\":[{\"internalType\":\"UD2x18\",\"name\":\"percentage\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"prevToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"deleteConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokensArray\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"smartAccount\",\"type\":\"address\"}],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"typeID\",\"type\":\"uint256\"}],\"name\":\"isModuleType\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onInstall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onUninstall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"UD2x18\",\"name\":\"percentage\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint128\"}],\"internalType\":\"struct AutoDCAModule.Config\",\"name\":\"_config\",\"type\":\"tuple\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Module that allows users to automatically save a percentage of their received tokens to a vault\",\"kind\":\"dev\",\"methods\":{\"autoSave(address,uint256)\":{\"params\":{\"amountReceived\":\"amount received by the user\",\"token\":\"address of the token received\"}},\"calcDepositAmount(uint256,uint64)\":{\"params\":{\"amountReceived\":\"amount received by the user\",\"percentage\":\"percentage to be saved to the vault\"},\"returns\":{\"_0\":\"amount to be saved to the vault\"}},\"deleteConfig(address,address)\":{\"details\":\"the function will revert if the module is not initialized\",\"params\":{\"prevToken\":\"address of the token stored before the token to be deleted\",\"token\":\"address of the token to be deleted\"}},\"getTokens(address)\":{\"details\":\"the function will revert if the module is not initialized\",\"params\":{\"account\":\"address of the account\"}},\"isInitialized(address)\":{\"params\":{\"smartAccount\":\"address of the smart account\"},\"returns\":{\"_0\":\"true if the module is initialized, false otherwise\"}},\"isModuleType(uint256)\":{\"params\":{\"typeID\":\"type of the module\"},\"returns\":{\"_0\":\"true if the type is a module type, false otherwise\"}},\"name()\":{\"returns\":{\"_0\":\"name of the module\"}},\"onInstall(bytes)\":{\"details\":\"data is encoded as follows: abi.encode([tokens], [configs])if there are more tokens than configs, the function will revertif there are more configs than tokens, the function will ignore the extra configs\",\"params\":{\"data\":\"encoded data containing the tokens and their configurations\"}},\"onUninstall(bytes)\":{\"details\":\"the data parameter is not used\"},\"setConfig(address,(uint64,address,uint128))\":{\"details\":\"the function will revert if the module is not initializedthis function can be used to set a new configuration or update an existing one\",\"params\":{\"_config\":\"Config struct containing the configuration\",\"token\":\"address of the token\"}},\"version()\":{\"returns\":{\"_0\":\"version of the module\"}}},\"title\":\"AutoDCAModule\",\"version\":1},\"userdoc\":{\"errors\":{\"PRBMath_MulDiv18_Overflow(uint256,uint256)\":[{\"notice\":\"Thrown when the resultant value in {mulDiv18} overflows uint256.\"}]},\"kind\":\"user\",\"methods\":{\"autoSave(address,uint256)\":{\"notice\":\"Executes the auto save logic\"},\"calcDepositAmount(uint256,uint64)\":{\"notice\":\"Calculates the amount to be saved to the vault\"},\"deleteConfig(address,address)\":{\"notice\":\"Deletes the configuration for a token\"},\"getTokens(address)\":{\"notice\":\"Gets a list of all tokens\"},\"isInitialized(address)\":{\"notice\":\"Checks if the module is initialized\"},\"isModuleType(uint256)\":{\"notice\":\"Returns the type of the module\"},\"name()\":{\"notice\":\"Returns the name of the module\"},\"onInstall(bytes)\":{\"notice\":\"Initializes the module with the tokens and their configurations\"},\"onUninstall(bytes)\":{\"notice\":\"Handles the uninstallation of the module and clears the tokens and configurations\"},\"setConfig(address,(uint64,address,uint128))\":{\"notice\":\"Sets the configuration for a token\"},\"version()\":{\"notice\":\"Returns the version of the module\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/AutoDCA/AutoDCAModule.sol\":\"AutoDCAModule\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@prb/math/Common.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\n// Common.sol\\n//\\n// Common mathematical functions used in both SD59x18 and UD60x18. Note that these global functions do not\\n// always operate with SD59x18 and UD60x18 numbers.\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                CUSTOM ERRORS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Thrown when the resultant value in {mulDiv} overflows uint256.\\nerror PRBMath_MulDiv_Overflow(uint256 x, uint256 y, uint256 denominator);\\n\\n/// @notice Thrown when the resultant value in {mulDiv18} overflows uint256.\\nerror PRBMath_MulDiv18_Overflow(uint256 x, uint256 y);\\n\\n/// @notice Thrown when one of the inputs passed to {mulDivSigned} is `type(int256).min`.\\nerror PRBMath_MulDivSigned_InputTooSmall();\\n\\n/// @notice Thrown when the resultant value in {mulDivSigned} overflows int256.\\nerror PRBMath_MulDivSigned_Overflow(int256 x, int256 y);\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    CONSTANTS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @dev The maximum value a uint128 number can have.\\nuint128 constant MAX_UINT128 = type(uint128).max;\\n\\n/// @dev The maximum value a uint40 number can have.\\nuint40 constant MAX_UINT40 = type(uint40).max;\\n\\n/// @dev The unit number, which the decimal precision of the fixed-point types.\\nuint256 constant UNIT = 1e18;\\n\\n/// @dev The unit number inverted mod 2^256.\\nuint256 constant UNIT_INVERSE = 78156646155174841979727994598816262306175212592076161876661_508869554232690281;\\n\\n/// @dev The the largest power of two that divides the decimal value of `UNIT`. The logarithm of this value is the least significant\\n/// bit in the binary representation of `UNIT`.\\nuint256 constant UNIT_LPOTD = 262144;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Calculates the binary exponent of x using the binary fraction method.\\n/// @dev Has to use 192.64-bit fixed-point numbers. See https://ethereum.stackexchange.com/a/96594/24693.\\n/// @param x The exponent as an unsigned 192.64-bit fixed-point number.\\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction exp2(uint256 x) pure returns (uint256 result) {\\n    unchecked {\\n        // Start from 0.5 in the 192.64-bit fixed-point format.\\n        result = 0x800000000000000000000000000000000000000000000000;\\n\\n        // The following logic multiplies the result by $\\\\sqrt{2^{-i}}$ when the bit at position i is 1. Key points:\\n        //\\n        // 1. Intermediate results will not overflow, as the starting point is 2^191 and all magic factors are under 2^65.\\n        // 2. The rationale for organizing the if statements into groups of 8 is gas savings. If the result of performing\\n        // a bitwise AND operation between x and any value in the array [0x80; 0x40; 0x20; 0x10; 0x08; 0x04; 0x02; 0x01] is 1,\\n        // we know that `x & 0xFF` is also 1.\\n        if (x & 0xFF00000000000000 > 0) {\\n            if (x & 0x8000000000000000 > 0) {\\n                result = (result * 0x16A09E667F3BCC909) >> 64;\\n            }\\n            if (x & 0x4000000000000000 > 0) {\\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\\n            }\\n            if (x & 0x2000000000000000 > 0) {\\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\\n            }\\n            if (x & 0x1000000000000000 > 0) {\\n                result = (result * 0x10B5586CF9890F62A) >> 64;\\n            }\\n            if (x & 0x800000000000000 > 0) {\\n                result = (result * 0x1059B0D31585743AE) >> 64;\\n            }\\n            if (x & 0x400000000000000 > 0) {\\n                result = (result * 0x102C9A3E778060EE7) >> 64;\\n            }\\n            if (x & 0x200000000000000 > 0) {\\n                result = (result * 0x10163DA9FB33356D8) >> 64;\\n            }\\n            if (x & 0x100000000000000 > 0) {\\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF000000000000 > 0) {\\n            if (x & 0x80000000000000 > 0) {\\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\\n            }\\n            if (x & 0x40000000000000 > 0) {\\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\\n            }\\n            if (x & 0x20000000000000 > 0) {\\n                result = (result * 0x100162F3904051FA1) >> 64;\\n            }\\n            if (x & 0x10000000000000 > 0) {\\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\\n            }\\n            if (x & 0x8000000000000 > 0) {\\n                result = (result * 0x100058BA01FB9F96D) >> 64;\\n            }\\n            if (x & 0x4000000000000 > 0) {\\n                result = (result * 0x10002C5CC37DA9492) >> 64;\\n            }\\n            if (x & 0x2000000000000 > 0) {\\n                result = (result * 0x1000162E525EE0547) >> 64;\\n            }\\n            if (x & 0x1000000000000 > 0) {\\n                result = (result * 0x10000B17255775C04) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF0000000000 > 0) {\\n            if (x & 0x800000000000 > 0) {\\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\\n            }\\n            if (x & 0x400000000000 > 0) {\\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\\n            }\\n            if (x & 0x200000000000 > 0) {\\n                result = (result * 0x10000162E43F4F831) >> 64;\\n            }\\n            if (x & 0x100000000000 > 0) {\\n                result = (result * 0x100000B1721BCFC9A) >> 64;\\n            }\\n            if (x & 0x80000000000 > 0) {\\n                result = (result * 0x10000058B90CF1E6E) >> 64;\\n            }\\n            if (x & 0x40000000000 > 0) {\\n                result = (result * 0x1000002C5C863B73F) >> 64;\\n            }\\n            if (x & 0x20000000000 > 0) {\\n                result = (result * 0x100000162E430E5A2) >> 64;\\n            }\\n            if (x & 0x10000000000 > 0) {\\n                result = (result * 0x1000000B172183551) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF00000000 > 0) {\\n            if (x & 0x8000000000 > 0) {\\n                result = (result * 0x100000058B90C0B49) >> 64;\\n            }\\n            if (x & 0x4000000000 > 0) {\\n                result = (result * 0x10000002C5C8601CC) >> 64;\\n            }\\n            if (x & 0x2000000000 > 0) {\\n                result = (result * 0x1000000162E42FFF0) >> 64;\\n            }\\n            if (x & 0x1000000000 > 0) {\\n                result = (result * 0x10000000B17217FBB) >> 64;\\n            }\\n            if (x & 0x800000000 > 0) {\\n                result = (result * 0x1000000058B90BFCE) >> 64;\\n            }\\n            if (x & 0x400000000 > 0) {\\n                result = (result * 0x100000002C5C85FE3) >> 64;\\n            }\\n            if (x & 0x200000000 > 0) {\\n                result = (result * 0x10000000162E42FF1) >> 64;\\n            }\\n            if (x & 0x100000000 > 0) {\\n                result = (result * 0x100000000B17217F8) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF000000 > 0) {\\n            if (x & 0x80000000 > 0) {\\n                result = (result * 0x10000000058B90BFC) >> 64;\\n            }\\n            if (x & 0x40000000 > 0) {\\n                result = (result * 0x1000000002C5C85FE) >> 64;\\n            }\\n            if (x & 0x20000000 > 0) {\\n                result = (result * 0x100000000162E42FF) >> 64;\\n            }\\n            if (x & 0x10000000 > 0) {\\n                result = (result * 0x1000000000B17217F) >> 64;\\n            }\\n            if (x & 0x8000000 > 0) {\\n                result = (result * 0x100000000058B90C0) >> 64;\\n            }\\n            if (x & 0x4000000 > 0) {\\n                result = (result * 0x10000000002C5C860) >> 64;\\n            }\\n            if (x & 0x2000000 > 0) {\\n                result = (result * 0x1000000000162E430) >> 64;\\n            }\\n            if (x & 0x1000000 > 0) {\\n                result = (result * 0x10000000000B17218) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF0000 > 0) {\\n            if (x & 0x800000 > 0) {\\n                result = (result * 0x1000000000058B90C) >> 64;\\n            }\\n            if (x & 0x400000 > 0) {\\n                result = (result * 0x100000000002C5C86) >> 64;\\n            }\\n            if (x & 0x200000 > 0) {\\n                result = (result * 0x10000000000162E43) >> 64;\\n            }\\n            if (x & 0x100000 > 0) {\\n                result = (result * 0x100000000000B1721) >> 64;\\n            }\\n            if (x & 0x80000 > 0) {\\n                result = (result * 0x10000000000058B91) >> 64;\\n            }\\n            if (x & 0x40000 > 0) {\\n                result = (result * 0x1000000000002C5C8) >> 64;\\n            }\\n            if (x & 0x20000 > 0) {\\n                result = (result * 0x100000000000162E4) >> 64;\\n            }\\n            if (x & 0x10000 > 0) {\\n                result = (result * 0x1000000000000B172) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF00 > 0) {\\n            if (x & 0x8000 > 0) {\\n                result = (result * 0x100000000000058B9) >> 64;\\n            }\\n            if (x & 0x4000 > 0) {\\n                result = (result * 0x10000000000002C5D) >> 64;\\n            }\\n            if (x & 0x2000 > 0) {\\n                result = (result * 0x1000000000000162E) >> 64;\\n            }\\n            if (x & 0x1000 > 0) {\\n                result = (result * 0x10000000000000B17) >> 64;\\n            }\\n            if (x & 0x800 > 0) {\\n                result = (result * 0x1000000000000058C) >> 64;\\n            }\\n            if (x & 0x400 > 0) {\\n                result = (result * 0x100000000000002C6) >> 64;\\n            }\\n            if (x & 0x200 > 0) {\\n                result = (result * 0x10000000000000163) >> 64;\\n            }\\n            if (x & 0x100 > 0) {\\n                result = (result * 0x100000000000000B1) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF > 0) {\\n            if (x & 0x80 > 0) {\\n                result = (result * 0x10000000000000059) >> 64;\\n            }\\n            if (x & 0x40 > 0) {\\n                result = (result * 0x1000000000000002C) >> 64;\\n            }\\n            if (x & 0x20 > 0) {\\n                result = (result * 0x10000000000000016) >> 64;\\n            }\\n            if (x & 0x10 > 0) {\\n                result = (result * 0x1000000000000000B) >> 64;\\n            }\\n            if (x & 0x8 > 0) {\\n                result = (result * 0x10000000000000006) >> 64;\\n            }\\n            if (x & 0x4 > 0) {\\n                result = (result * 0x10000000000000003) >> 64;\\n            }\\n            if (x & 0x2 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n            if (x & 0x1 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n        }\\n\\n        // In the code snippet below, two operations are executed simultaneously:\\n        //\\n        // 1. The result is multiplied by $(2^n + 1)$, where $2^n$ represents the integer part, and the additional 1\\n        // accounts for the initial guess of 0.5. This is achieved by subtracting from 191 instead of 192.\\n        // 2. The result is then converted to an unsigned 60.18-decimal fixed-point format.\\n        //\\n        // The underlying logic is based on the relationship $2^{191-ip} = 2^{ip} / 2^{191}$, where $ip$ denotes the,\\n        // integer part, $2^n$.\\n        result *= UNIT;\\n        result >>= (191 - (x >> 64));\\n    }\\n}\\n\\n/// @notice Finds the zero-based index of the first 1 in the binary representation of x.\\n///\\n/// @dev See the note on \\\"msb\\\" in this Wikipedia article: https://en.wikipedia.org/wiki/Find_first_set\\n///\\n/// Each step in this implementation is equivalent to this high-level code:\\n///\\n/// ```solidity\\n/// if (x >= 2 ** 128) {\\n///     x >>= 128;\\n///     result += 128;\\n/// }\\n/// ```\\n///\\n/// Where 128 is replaced with each respective power of two factor. See the full high-level implementation here:\\n/// https://gist.github.com/PaulRBerg/f932f8693f2733e30c4d479e8e980948\\n///\\n/// The Yul instructions used below are:\\n///\\n/// - \\\"gt\\\" is \\\"greater than\\\"\\n/// - \\\"or\\\" is the OR bitwise operator\\n/// - \\\"shl\\\" is \\\"shift left\\\"\\n/// - \\\"shr\\\" is \\\"shift right\\\"\\n///\\n/// @param x The uint256 number for which to find the index of the most significant bit.\\n/// @return result The index of the most significant bit as a uint256.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction msb(uint256 x) pure returns (uint256 result) {\\n    // 2^128\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(7, gt(x, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^64\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(6, gt(x, 0xFFFFFFFFFFFFFFFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^32\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(5, gt(x, 0xFFFFFFFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^16\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(4, gt(x, 0xFFFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^8\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(3, gt(x, 0xFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^4\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(2, gt(x, 0xF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^2\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := shl(1, gt(x, 0x3))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^1\\n    // No need to shift x any more.\\n    assembly (\\\"memory-safe\\\") {\\n        let factor := gt(x, 0x1)\\n        result := or(result, factor)\\n    }\\n}\\n\\n/// @notice Calculates x*y\\u00f7denominator with 512-bit precision.\\n///\\n/// @dev Credits to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\\n///\\n/// Notes:\\n/// - The result is rounded toward zero.\\n///\\n/// Requirements:\\n/// - The denominator must not be zero.\\n/// - The result must fit in uint256.\\n///\\n/// @param x The multiplicand as a uint256.\\n/// @param y The multiplier as a uint256.\\n/// @param denominator The divisor as a uint256.\\n/// @return result The result as a uint256.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction mulDiv(uint256 x, uint256 y, uint256 denominator) pure returns (uint256 result) {\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n    // use the Chinese Remainder Theorem to reconstruct the 512-bit result. The result is stored in two 256\\n    // variables such that product = prod1 * 2^256 + prod0.\\n    uint256 prod0; // Least significant 256 bits of the product\\n    uint256 prod1; // Most significant 256 bits of the product\\n    assembly (\\\"memory-safe\\\") {\\n        let mm := mulmod(x, y, not(0))\\n        prod0 := mul(x, y)\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n    }\\n\\n    // Handle non-overflow cases, 256 by 256 division.\\n    if (prod1 == 0) {\\n        unchecked {\\n            return prod0 / denominator;\\n        }\\n    }\\n\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n    if (prod1 >= denominator) {\\n        revert PRBMath_MulDiv_Overflow(x, y, denominator);\\n    }\\n\\n    ////////////////////////////////////////////////////////////////////////////\\n    // 512 by 256 division\\n    ////////////////////////////////////////////////////////////////////////////\\n\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\n    uint256 remainder;\\n    assembly (\\\"memory-safe\\\") {\\n        // Compute remainder using the mulmod Yul instruction.\\n        remainder := mulmod(x, y, denominator)\\n\\n        // Subtract 256 bit number from 512-bit number.\\n        prod1 := sub(prod1, gt(remainder, prod0))\\n        prod0 := sub(prod0, remainder)\\n    }\\n\\n    unchecked {\\n        // Calculate the largest power of two divisor of the denominator using the unary operator ~. This operation cannot overflow\\n        // because the denominator cannot be zero at this point in the function execution. The result is always >= 1.\\n        // For more detail, see https://cs.stackexchange.com/q/138556/92363.\\n        uint256 lpotdod = denominator & (~denominator + 1);\\n        uint256 flippedLpotdod;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            // Factor powers of two out of denominator.\\n            denominator := div(denominator, lpotdod)\\n\\n            // Divide [prod1 prod0] by lpotdod.\\n            prod0 := div(prod0, lpotdod)\\n\\n            // Get the flipped value `2^256 / lpotdod`. If the `lpotdod` is zero, the flipped value is one.\\n            // `sub(0, lpotdod)` produces the two's complement version of `lpotdod`, which is equivalent to flipping all the bits.\\n            // However, `div` interprets this value as an unsigned value: https://ethereum.stackexchange.com/q/147168/24693\\n            flippedLpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\n        }\\n\\n        // Shift in bits from prod1 into prod0.\\n        prod0 |= prod1 * flippedLpotdod;\\n\\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n        // four bits. That is, denominator * inv = 1 mod 2^4.\\n        uint256 inverse = (3 * denominator) ^ 2;\\n\\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n        // in modular arithmetic, doubling the correct bits in each step.\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n        // is no longer required.\\n        result = prod0 * inverse;\\n    }\\n}\\n\\n/// @notice Calculates x*y\\u00f71e18 with 512-bit precision.\\n///\\n/// @dev A variant of {mulDiv} with constant folding, i.e. in which the denominator is hard coded to 1e18.\\n///\\n/// Notes:\\n/// - The body is purposely left uncommented; to understand how this works, see the documentation in {mulDiv}.\\n/// - The result is rounded toward zero.\\n/// - We take as an axiom that the result cannot be `MAX_UINT256` when x and y solve the following system of equations:\\n///\\n/// $$\\n/// \\\\begin{cases}\\n///     x * y = MAX\\\\_UINT256 * UNIT \\\\\\\\\\n///     (x * y) \\\\% UNIT \\\\geq \\\\frac{UNIT}{2}\\n/// \\\\end{cases}\\n/// $$\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {mulDiv}.\\n/// - The result must fit in uint256.\\n///\\n/// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n/// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction mulDiv18(uint256 x, uint256 y) pure returns (uint256 result) {\\n    uint256 prod0;\\n    uint256 prod1;\\n    assembly (\\\"memory-safe\\\") {\\n        let mm := mulmod(x, y, not(0))\\n        prod0 := mul(x, y)\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n    }\\n\\n    if (prod1 == 0) {\\n        unchecked {\\n            return prod0 / UNIT;\\n        }\\n    }\\n\\n    if (prod1 >= UNIT) {\\n        revert PRBMath_MulDiv18_Overflow(x, y);\\n    }\\n\\n    uint256 remainder;\\n    assembly (\\\"memory-safe\\\") {\\n        remainder := mulmod(x, y, UNIT)\\n        result :=\\n            mul(\\n                or(\\n                    div(sub(prod0, remainder), UNIT_LPOTD),\\n                    mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, UNIT_LPOTD), UNIT_LPOTD), 1))\\n                ),\\n                UNIT_INVERSE\\n            )\\n    }\\n}\\n\\n/// @notice Calculates x*y\\u00f7denominator with 512-bit precision.\\n///\\n/// @dev This is an extension of {mulDiv} for signed numbers, which works by computing the signs and the absolute values separately.\\n///\\n/// Notes:\\n/// - The result is rounded toward zero.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {mulDiv}.\\n/// - None of the inputs can be `type(int256).min`.\\n/// - The result must fit in int256.\\n///\\n/// @param x The multiplicand as an int256.\\n/// @param y The multiplier as an int256.\\n/// @param denominator The divisor as an int256.\\n/// @return result The result as an int256.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction mulDivSigned(int256 x, int256 y, int256 denominator) pure returns (int256 result) {\\n    if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\\n        revert PRBMath_MulDivSigned_InputTooSmall();\\n    }\\n\\n    // Get hold of the absolute values of x, y and the denominator.\\n    uint256 xAbs;\\n    uint256 yAbs;\\n    uint256 dAbs;\\n    unchecked {\\n        xAbs = x < 0 ? uint256(-x) : uint256(x);\\n        yAbs = y < 0 ? uint256(-y) : uint256(y);\\n        dAbs = denominator < 0 ? uint256(-denominator) : uint256(denominator);\\n    }\\n\\n    // Compute the absolute value of x*y\\u00f7denominator. The result must fit in int256.\\n    uint256 resultAbs = mulDiv(xAbs, yAbs, dAbs);\\n    if (resultAbs > uint256(type(int256).max)) {\\n        revert PRBMath_MulDivSigned_Overflow(x, y);\\n    }\\n\\n    // Get the signs of x, y and the denominator.\\n    uint256 sx;\\n    uint256 sy;\\n    uint256 sd;\\n    assembly (\\\"memory-safe\\\") {\\n        // \\\"sgt\\\" is the \\\"signed greater than\\\" assembly instruction and \\\"sub(0,1)\\\" is -1 in two's complement.\\n        sx := sgt(x, sub(0, 1))\\n        sy := sgt(y, sub(0, 1))\\n        sd := sgt(denominator, sub(0, 1))\\n    }\\n\\n    // XOR over sx, sy and sd. What this does is to check whether there are 1 or 3 negative signs in the inputs.\\n    // If there are, the result should be negative. Otherwise, it should be positive.\\n    unchecked {\\n        result = sx ^ sy ^ sd == 0 ? -int256(resultAbs) : int256(resultAbs);\\n    }\\n}\\n\\n/// @notice Calculates the square root of x using the Babylonian method.\\n///\\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n///\\n/// Notes:\\n/// - If x is not a perfect square, the result is rounded down.\\n/// - Credits to OpenZeppelin for the explanations in comments below.\\n///\\n/// @param x The uint256 number for which to calculate the square root.\\n/// @return result The result as a uint256.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction sqrt(uint256 x) pure returns (uint256 result) {\\n    if (x == 0) {\\n        return 0;\\n    }\\n\\n    // For our first guess, we calculate the biggest power of 2 which is smaller than the square root of x.\\n    //\\n    // We know that the \\\"msb\\\" (most significant bit) of x is a power of 2 such that we have:\\n    //\\n    // $$\\n    // msb(x) <= x <= 2*msb(x)$\\n    // $$\\n    //\\n    // We write $msb(x)$ as $2^k$, and we get:\\n    //\\n    // $$\\n    // k = log_2(x)\\n    // $$\\n    //\\n    // Thus, we can write the initial inequality as:\\n    //\\n    // $$\\n    // 2^{log_2(x)} <= x <= 2*2^{log_2(x)+1} \\\\\\\\\\n    // sqrt(2^k) <= sqrt(x) < sqrt(2^{k+1}) \\\\\\\\\\n    // 2^{k/2} <= sqrt(x) < 2^{(k+1)/2} <= 2^{(k/2)+1}\\n    // $$\\n    //\\n    // Consequently, $2^{log_2(x) /2} is a good first approximation of sqrt(x) with at least one correct bit.\\n    uint256 xAux = uint256(x);\\n    result = 1;\\n    if (xAux >= 2 ** 128) {\\n        xAux >>= 128;\\n        result <<= 64;\\n    }\\n    if (xAux >= 2 ** 64) {\\n        xAux >>= 64;\\n        result <<= 32;\\n    }\\n    if (xAux >= 2 ** 32) {\\n        xAux >>= 32;\\n        result <<= 16;\\n    }\\n    if (xAux >= 2 ** 16) {\\n        xAux >>= 16;\\n        result <<= 8;\\n    }\\n    if (xAux >= 2 ** 8) {\\n        xAux >>= 8;\\n        result <<= 4;\\n    }\\n    if (xAux >= 2 ** 4) {\\n        xAux >>= 4;\\n        result <<= 2;\\n    }\\n    if (xAux >= 2 ** 2) {\\n        result <<= 1;\\n    }\\n\\n    // At this point, `result` is an estimation with at least one bit of precision. We know the true value has at\\n    // most 128 bits, since it is the square root of a uint256. Newton's method converges quadratically (precision\\n    // doubles at every iteration). We thus need at most 7 iteration to turn our partial result with one bit of\\n    // precision into the expected uint128 result.\\n    unchecked {\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n\\n        // If x is not a perfect square, round the result toward zero.\\n        uint256 roundedResult = x / result;\\n        if (result >= roundedResult) {\\n            result = roundedResult;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xaa374e2c26cc93e8c22a6953804ee05f811597ef5fa82f76824378b22944778b\",\"license\":\"MIT\"},\"@prb/math/UD2x18.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\n/*\\n\\n\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2557   \\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2557  \\u2588\\u2588\\u2557\\n\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u255a\\u2550\\u2550\\u2588\\u2588\\u2554\\u2550\\u2550\\u255d\\u2588\\u2588\\u2551  \\u2588\\u2588\\u2551\\n\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2554\\u2588\\u2588\\u2588\\u2588\\u2554\\u2588\\u2588\\u2551\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2551\\n\\u2588\\u2588\\u2554\\u2550\\u2550\\u2550\\u255d \\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2551\\u255a\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2551\\n\\u2588\\u2588\\u2551     \\u2588\\u2588\\u2551  \\u2588\\u2588\\u2551\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2551 \\u255a\\u2550\\u255d \\u2588\\u2588\\u2551\\u2588\\u2588\\u2551  \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551  \\u2588\\u2588\\u2551\\n\\u255a\\u2550\\u255d     \\u255a\\u2550\\u255d  \\u255a\\u2550\\u255d\\u255a\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d \\u255a\\u2550\\u255d     \\u255a\\u2550\\u255d\\u255a\\u2550\\u255d  \\u255a\\u2550\\u255d   \\u255a\\u2550\\u255d   \\u255a\\u2550\\u255d  \\u255a\\u2550\\u255d\\n\\n\\u2588\\u2588\\u2557   \\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2557  \\u2588\\u2588\\u2557 \\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\n\\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u255a\\u2550\\u2550\\u2550\\u2550\\u2588\\u2588\\u2557\\u255a\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\n\\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551\\u2588\\u2588\\u2551  \\u2588\\u2588\\u2551 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d \\u255a\\u2588\\u2588\\u2588\\u2554\\u255d \\u255a\\u2588\\u2588\\u2551\\u255a\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\n\\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551\\u2588\\u2588\\u2551  \\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u2550\\u255d  \\u2588\\u2588\\u2554\\u2588\\u2588\\u2557  \\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\n\\u255a\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u255d \\u2588\\u2588\\u2557 \\u2588\\u2588\\u2551\\u255a\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\n \\u255a\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d \\u255a\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d \\u255a\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d\\u255a\\u2550\\u255d  \\u255a\\u2550\\u255d \\u255a\\u2550\\u255d \\u255a\\u2550\\u2550\\u2550\\u2550\\u255d\\n\\n*/\\n\\nimport \\\"./ud2x18/Casting.sol\\\";\\nimport \\\"./ud2x18/Constants.sol\\\";\\nimport \\\"./ud2x18/Errors.sol\\\";\\nimport \\\"./ud2x18/ValueType.sol\\\";\\n\",\"keccak256\":\"0xfb624e24cd8bb790fa08e7827819de85504a86e20e961fa4ad126c65b6d90641\",\"license\":\"MIT\"},\"@prb/math/UD60x18.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\n/*\\n\\n\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2557   \\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2557  \\u2588\\u2588\\u2557\\n\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u255a\\u2550\\u2550\\u2588\\u2588\\u2554\\u2550\\u2550\\u255d\\u2588\\u2588\\u2551  \\u2588\\u2588\\u2551\\n\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2554\\u2588\\u2588\\u2588\\u2588\\u2554\\u2588\\u2588\\u2551\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2551\\n\\u2588\\u2588\\u2554\\u2550\\u2550\\u2550\\u255d \\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2551\\u255a\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2551\\n\\u2588\\u2588\\u2551     \\u2588\\u2588\\u2551  \\u2588\\u2588\\u2551\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2551 \\u255a\\u2550\\u255d \\u2588\\u2588\\u2551\\u2588\\u2588\\u2551  \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551  \\u2588\\u2588\\u2551\\n\\u255a\\u2550\\u255d     \\u255a\\u2550\\u255d  \\u255a\\u2550\\u255d\\u255a\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d \\u255a\\u2550\\u255d     \\u255a\\u2550\\u255d\\u255a\\u2550\\u255d  \\u255a\\u2550\\u255d   \\u255a\\u2550\\u255d   \\u255a\\u2550\\u255d  \\u255a\\u2550\\u255d\\n\\n\\u2588\\u2588\\u2557   \\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557  \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557  \\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2557  \\u2588\\u2588\\u2557 \\u2588\\u2588\\u2557 \\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\n\\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u2550\\u2550\\u2550\\u2550\\u255d \\u2588\\u2588\\u2554\\u2550\\u2588\\u2588\\u2588\\u2588\\u2557\\u255a\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\n\\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551\\u2588\\u2588\\u2551  \\u2588\\u2588\\u2551\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557 \\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2588\\u2588\\u2551 \\u255a\\u2588\\u2588\\u2588\\u2554\\u255d \\u255a\\u2588\\u2588\\u2551\\u255a\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\n\\u2588\\u2588\\u2551   \\u2588\\u2588\\u2551\\u2588\\u2588\\u2551  \\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2551 \\u2588\\u2588\\u2554\\u2588\\u2588\\u2557  \\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\n\\u255a\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u255a\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u255a\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2554\\u255d \\u2588\\u2588\\u2557 \\u2588\\u2588\\u2551\\u255a\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\n \\u255a\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d \\u255a\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d  \\u255a\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d  \\u255a\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d \\u255a\\u2550\\u255d  \\u255a\\u2550\\u255d \\u255a\\u2550\\u255d \\u255a\\u2550\\u2550\\u2550\\u2550\\u255d\\n\\n*/\\n\\nimport \\\"./ud60x18/Casting.sol\\\";\\nimport \\\"./ud60x18/Constants.sol\\\";\\nimport \\\"./ud60x18/Conversions.sol\\\";\\nimport \\\"./ud60x18/Errors.sol\\\";\\nimport \\\"./ud60x18/Helpers.sol\\\";\\nimport \\\"./ud60x18/Math.sol\\\";\\nimport \\\"./ud60x18/ValueType.sol\\\";\\n\",\"keccak256\":\"0xb98c6f74275914d279e8af6c502c2b1f50d5f6e1ed418d3b0153f5a193206c48\",\"license\":\"MIT\"},\"@prb/math/sd1x18/Casting.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport \\\"../Common.sol\\\" as Common;\\nimport \\\"./Errors.sol\\\" as CastingErrors;\\nimport { SD59x18 } from \\\"../sd59x18/ValueType.sol\\\";\\nimport { UD2x18 } from \\\"../ud2x18/ValueType.sol\\\";\\nimport { UD60x18 } from \\\"../ud60x18/ValueType.sol\\\";\\nimport { SD1x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Casts an SD1x18 number into SD59x18.\\n/// @dev There is no overflow check because the domain of SD1x18 is a subset of SD59x18.\\nfunction intoSD59x18(SD1x18 x) pure returns (SD59x18 result) {\\n    result = SD59x18.wrap(int256(SD1x18.unwrap(x)));\\n}\\n\\n/// @notice Casts an SD1x18 number into UD2x18.\\n/// - x must be positive.\\nfunction intoUD2x18(SD1x18 x) pure returns (UD2x18 result) {\\n    int64 xInt = SD1x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert CastingErrors.PRBMath_SD1x18_ToUD2x18_Underflow(x);\\n    }\\n    result = UD2x18.wrap(uint64(xInt));\\n}\\n\\n/// @notice Casts an SD1x18 number into UD60x18.\\n/// @dev Requirements:\\n/// - x must be positive.\\nfunction intoUD60x18(SD1x18 x) pure returns (UD60x18 result) {\\n    int64 xInt = SD1x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert CastingErrors.PRBMath_SD1x18_ToUD60x18_Underflow(x);\\n    }\\n    result = UD60x18.wrap(uint64(xInt));\\n}\\n\\n/// @notice Casts an SD1x18 number into uint256.\\n/// @dev Requirements:\\n/// - x must be positive.\\nfunction intoUint256(SD1x18 x) pure returns (uint256 result) {\\n    int64 xInt = SD1x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert CastingErrors.PRBMath_SD1x18_ToUint256_Underflow(x);\\n    }\\n    result = uint256(uint64(xInt));\\n}\\n\\n/// @notice Casts an SD1x18 number into uint128.\\n/// @dev Requirements:\\n/// - x must be positive.\\nfunction intoUint128(SD1x18 x) pure returns (uint128 result) {\\n    int64 xInt = SD1x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert CastingErrors.PRBMath_SD1x18_ToUint128_Underflow(x);\\n    }\\n    result = uint128(uint64(xInt));\\n}\\n\\n/// @notice Casts an SD1x18 number into uint40.\\n/// @dev Requirements:\\n/// - x must be positive.\\n/// - x must be less than or equal to `MAX_UINT40`.\\nfunction intoUint40(SD1x18 x) pure returns (uint40 result) {\\n    int64 xInt = SD1x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert CastingErrors.PRBMath_SD1x18_ToUint40_Underflow(x);\\n    }\\n    if (xInt > int64(uint64(Common.MAX_UINT40))) {\\n        revert CastingErrors.PRBMath_SD1x18_ToUint40_Overflow(x);\\n    }\\n    result = uint40(uint64(xInt));\\n}\\n\\n/// @notice Alias for {wrap}.\\nfunction sd1x18(int64 x) pure returns (SD1x18 result) {\\n    result = SD1x18.wrap(x);\\n}\\n\\n/// @notice Unwraps an SD1x18 number into int64.\\nfunction unwrap(SD1x18 x) pure returns (int64 result) {\\n    result = SD1x18.unwrap(x);\\n}\\n\\n/// @notice Wraps an int64 number into SD1x18.\\nfunction wrap(int64 x) pure returns (SD1x18 result) {\\n    result = SD1x18.wrap(x);\\n}\\n\",\"keccak256\":\"0x9e49e2b37c1bb845861740805edaaef3fe951a7b96eef16ce84fbf76e8278670\",\"license\":\"MIT\"},\"@prb/math/sd1x18/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { SD1x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @dev Euler's number as an SD1x18 number.\\nSD1x18 constant E = SD1x18.wrap(2_718281828459045235);\\n\\n/// @dev The maximum value an SD1x18 number can have.\\nint64 constant uMAX_SD1x18 = 9_223372036854775807;\\nSD1x18 constant MAX_SD1x18 = SD1x18.wrap(uMAX_SD1x18);\\n\\n/// @dev The maximum value an SD1x18 number can have.\\nint64 constant uMIN_SD1x18 = -9_223372036854775808;\\nSD1x18 constant MIN_SD1x18 = SD1x18.wrap(uMIN_SD1x18);\\n\\n/// @dev PI as an SD1x18 number.\\nSD1x18 constant PI = SD1x18.wrap(3_141592653589793238);\\n\\n/// @dev The unit number, which gives the decimal precision of SD1x18.\\nSD1x18 constant UNIT = SD1x18.wrap(1e18);\\nint64 constant uUNIT = 1e18;\\n\",\"keccak256\":\"0x6496165b80552785a4b65a239b96e2a5fedf62fe54f002eeed72d75e566d7585\",\"license\":\"MIT\"},\"@prb/math/sd1x18/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { SD1x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Thrown when trying to cast a SD1x18 number that doesn't fit in UD2x18.\\nerror PRBMath_SD1x18_ToUD2x18_Underflow(SD1x18 x);\\n\\n/// @notice Thrown when trying to cast a SD1x18 number that doesn't fit in UD60x18.\\nerror PRBMath_SD1x18_ToUD60x18_Underflow(SD1x18 x);\\n\\n/// @notice Thrown when trying to cast a SD1x18 number that doesn't fit in uint128.\\nerror PRBMath_SD1x18_ToUint128_Underflow(SD1x18 x);\\n\\n/// @notice Thrown when trying to cast a SD1x18 number that doesn't fit in uint256.\\nerror PRBMath_SD1x18_ToUint256_Underflow(SD1x18 x);\\n\\n/// @notice Thrown when trying to cast a SD1x18 number that doesn't fit in uint40.\\nerror PRBMath_SD1x18_ToUint40_Overflow(SD1x18 x);\\n\\n/// @notice Thrown when trying to cast a SD1x18 number that doesn't fit in uint40.\\nerror PRBMath_SD1x18_ToUint40_Underflow(SD1x18 x);\\n\",\"keccak256\":\"0x836cb42ba619ca369fd4765bc47fefc3c3621369c5861882af14660aca5057ee\",\"license\":\"MIT\"},\"@prb/math/sd1x18/ValueType.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport \\\"./Casting.sol\\\" as Casting;\\n\\n/// @notice The signed 1.18-decimal fixed-point number representation, which can have up to 1 digit and up to 18\\n/// decimals. The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity\\n/// type int64. This is useful when end users want to use int64 to save gas, e.g. with tight variable packing in contract\\n/// storage.\\ntype SD1x18 is int64;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    CASTING\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nusing {\\n    Casting.intoSD59x18,\\n    Casting.intoUD2x18,\\n    Casting.intoUD60x18,\\n    Casting.intoUint256,\\n    Casting.intoUint128,\\n    Casting.intoUint40,\\n    Casting.unwrap\\n} for SD1x18 global;\\n\",\"keccak256\":\"0x2f86f1aa9fca42f40808b51a879b406ac51817647bdb9642f8a79dd8fdb754a7\",\"license\":\"MIT\"},\"@prb/math/sd59x18/Casting.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport \\\"./Errors.sol\\\" as CastingErrors;\\nimport { MAX_UINT128, MAX_UINT40 } from \\\"../Common.sol\\\";\\nimport { uMAX_SD1x18, uMIN_SD1x18 } from \\\"../sd1x18/Constants.sol\\\";\\nimport { SD1x18 } from \\\"../sd1x18/ValueType.sol\\\";\\nimport { uMAX_UD2x18 } from \\\"../ud2x18/Constants.sol\\\";\\nimport { UD2x18 } from \\\"../ud2x18/ValueType.sol\\\";\\nimport { UD60x18 } from \\\"../ud60x18/ValueType.sol\\\";\\nimport { SD59x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Casts an SD59x18 number into int256.\\n/// @dev This is basically a functional alias for {unwrap}.\\nfunction intoInt256(SD59x18 x) pure returns (int256 result) {\\n    result = SD59x18.unwrap(x);\\n}\\n\\n/// @notice Casts an SD59x18 number into SD1x18.\\n/// @dev Requirements:\\n/// - x must be greater than or equal to `uMIN_SD1x18`.\\n/// - x must be less than or equal to `uMAX_SD1x18`.\\nfunction intoSD1x18(SD59x18 x) pure returns (SD1x18 result) {\\n    int256 xInt = SD59x18.unwrap(x);\\n    if (xInt < uMIN_SD1x18) {\\n        revert CastingErrors.PRBMath_SD59x18_IntoSD1x18_Underflow(x);\\n    }\\n    if (xInt > uMAX_SD1x18) {\\n        revert CastingErrors.PRBMath_SD59x18_IntoSD1x18_Overflow(x);\\n    }\\n    result = SD1x18.wrap(int64(xInt));\\n}\\n\\n/// @notice Casts an SD59x18 number into UD2x18.\\n/// @dev Requirements:\\n/// - x must be positive.\\n/// - x must be less than or equal to `uMAX_UD2x18`.\\nfunction intoUD2x18(SD59x18 x) pure returns (UD2x18 result) {\\n    int256 xInt = SD59x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert CastingErrors.PRBMath_SD59x18_IntoUD2x18_Underflow(x);\\n    }\\n    if (xInt > int256(uint256(uMAX_UD2x18))) {\\n        revert CastingErrors.PRBMath_SD59x18_IntoUD2x18_Overflow(x);\\n    }\\n    result = UD2x18.wrap(uint64(uint256(xInt)));\\n}\\n\\n/// @notice Casts an SD59x18 number into UD60x18.\\n/// @dev Requirements:\\n/// - x must be positive.\\nfunction intoUD60x18(SD59x18 x) pure returns (UD60x18 result) {\\n    int256 xInt = SD59x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert CastingErrors.PRBMath_SD59x18_IntoUD60x18_Underflow(x);\\n    }\\n    result = UD60x18.wrap(uint256(xInt));\\n}\\n\\n/// @notice Casts an SD59x18 number into uint256.\\n/// @dev Requirements:\\n/// - x must be positive.\\nfunction intoUint256(SD59x18 x) pure returns (uint256 result) {\\n    int256 xInt = SD59x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert CastingErrors.PRBMath_SD59x18_IntoUint256_Underflow(x);\\n    }\\n    result = uint256(xInt);\\n}\\n\\n/// @notice Casts an SD59x18 number into uint128.\\n/// @dev Requirements:\\n/// - x must be positive.\\n/// - x must be less than or equal to `uMAX_UINT128`.\\nfunction intoUint128(SD59x18 x) pure returns (uint128 result) {\\n    int256 xInt = SD59x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert CastingErrors.PRBMath_SD59x18_IntoUint128_Underflow(x);\\n    }\\n    if (xInt > int256(uint256(MAX_UINT128))) {\\n        revert CastingErrors.PRBMath_SD59x18_IntoUint128_Overflow(x);\\n    }\\n    result = uint128(uint256(xInt));\\n}\\n\\n/// @notice Casts an SD59x18 number into uint40.\\n/// @dev Requirements:\\n/// - x must be positive.\\n/// - x must be less than or equal to `MAX_UINT40`.\\nfunction intoUint40(SD59x18 x) pure returns (uint40 result) {\\n    int256 xInt = SD59x18.unwrap(x);\\n    if (xInt < 0) {\\n        revert CastingErrors.PRBMath_SD59x18_IntoUint40_Underflow(x);\\n    }\\n    if (xInt > int256(uint256(MAX_UINT40))) {\\n        revert CastingErrors.PRBMath_SD59x18_IntoUint40_Overflow(x);\\n    }\\n    result = uint40(uint256(xInt));\\n}\\n\\n/// @notice Alias for {wrap}.\\nfunction sd(int256 x) pure returns (SD59x18 result) {\\n    result = SD59x18.wrap(x);\\n}\\n\\n/// @notice Alias for {wrap}.\\nfunction sd59x18(int256 x) pure returns (SD59x18 result) {\\n    result = SD59x18.wrap(x);\\n}\\n\\n/// @notice Unwraps an SD59x18 number into int256.\\nfunction unwrap(SD59x18 x) pure returns (int256 result) {\\n    result = SD59x18.unwrap(x);\\n}\\n\\n/// @notice Wraps an int256 number into SD59x18.\\nfunction wrap(int256 x) pure returns (SD59x18 result) {\\n    result = SD59x18.wrap(x);\\n}\\n\",\"keccak256\":\"0x3b21b60ec2998c3ae32f647412da51d3683b3f183a807198cc8d157499484f99\",\"license\":\"MIT\"},\"@prb/math/sd59x18/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { SD59x18 } from \\\"./ValueType.sol\\\";\\n\\n// NOTICE: the \\\"u\\\" prefix stands for \\\"unwrapped\\\".\\n\\n/// @dev Euler's number as an SD59x18 number.\\nSD59x18 constant E = SD59x18.wrap(2_718281828459045235);\\n\\n/// @dev The maximum input permitted in {exp}.\\nint256 constant uEXP_MAX_INPUT = 133_084258667509499440;\\nSD59x18 constant EXP_MAX_INPUT = SD59x18.wrap(uEXP_MAX_INPUT);\\n\\n/// @dev Any value less than this returns 0 in {exp}.\\nint256 constant uEXP_MIN_THRESHOLD = -41_446531673892822322;\\nSD59x18 constant EXP_MIN_THRESHOLD = SD59x18.wrap(uEXP_MIN_THRESHOLD);\\n\\n/// @dev The maximum input permitted in {exp2}.\\nint256 constant uEXP2_MAX_INPUT = 192e18 - 1;\\nSD59x18 constant EXP2_MAX_INPUT = SD59x18.wrap(uEXP2_MAX_INPUT);\\n\\n/// @dev Any value less than this returns 0 in {exp2}.\\nint256 constant uEXP2_MIN_THRESHOLD = -59_794705707972522261;\\nSD59x18 constant EXP2_MIN_THRESHOLD = SD59x18.wrap(uEXP2_MIN_THRESHOLD);\\n\\n/// @dev Half the UNIT number.\\nint256 constant uHALF_UNIT = 0.5e18;\\nSD59x18 constant HALF_UNIT = SD59x18.wrap(uHALF_UNIT);\\n\\n/// @dev $log_2(10)$ as an SD59x18 number.\\nint256 constant uLOG2_10 = 3_321928094887362347;\\nSD59x18 constant LOG2_10 = SD59x18.wrap(uLOG2_10);\\n\\n/// @dev $log_2(e)$ as an SD59x18 number.\\nint256 constant uLOG2_E = 1_442695040888963407;\\nSD59x18 constant LOG2_E = SD59x18.wrap(uLOG2_E);\\n\\n/// @dev The maximum value an SD59x18 number can have.\\nint256 constant uMAX_SD59x18 = 57896044618658097711785492504343953926634992332820282019728_792003956564819967;\\nSD59x18 constant MAX_SD59x18 = SD59x18.wrap(uMAX_SD59x18);\\n\\n/// @dev The maximum whole value an SD59x18 number can have.\\nint256 constant uMAX_WHOLE_SD59x18 = 57896044618658097711785492504343953926634992332820282019728_000000000000000000;\\nSD59x18 constant MAX_WHOLE_SD59x18 = SD59x18.wrap(uMAX_WHOLE_SD59x18);\\n\\n/// @dev The minimum value an SD59x18 number can have.\\nint256 constant uMIN_SD59x18 = -57896044618658097711785492504343953926634992332820282019728_792003956564819968;\\nSD59x18 constant MIN_SD59x18 = SD59x18.wrap(uMIN_SD59x18);\\n\\n/// @dev The minimum whole value an SD59x18 number can have.\\nint256 constant uMIN_WHOLE_SD59x18 = -57896044618658097711785492504343953926634992332820282019728_000000000000000000;\\nSD59x18 constant MIN_WHOLE_SD59x18 = SD59x18.wrap(uMIN_WHOLE_SD59x18);\\n\\n/// @dev PI as an SD59x18 number.\\nSD59x18 constant PI = SD59x18.wrap(3_141592653589793238);\\n\\n/// @dev The unit number, which gives the decimal precision of SD59x18.\\nint256 constant uUNIT = 1e18;\\nSD59x18 constant UNIT = SD59x18.wrap(1e18);\\n\\n/// @dev The unit number squared.\\nint256 constant uUNIT_SQUARED = 1e36;\\nSD59x18 constant UNIT_SQUARED = SD59x18.wrap(uUNIT_SQUARED);\\n\\n/// @dev Zero as an SD59x18 number.\\nSD59x18 constant ZERO = SD59x18.wrap(0);\\n\",\"keccak256\":\"0x9bcb8dd6b3e886d140ad1c32747a4f6d29a492529ceb835be878ae837aa6cc3a\",\"license\":\"MIT\"},\"@prb/math/sd59x18/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { SD59x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Thrown when taking the absolute value of `MIN_SD59x18`.\\nerror PRBMath_SD59x18_Abs_MinSD59x18();\\n\\n/// @notice Thrown when ceiling a number overflows SD59x18.\\nerror PRBMath_SD59x18_Ceil_Overflow(SD59x18 x);\\n\\n/// @notice Thrown when converting a basic integer to the fixed-point format overflows SD59x18.\\nerror PRBMath_SD59x18_Convert_Overflow(int256 x);\\n\\n/// @notice Thrown when converting a basic integer to the fixed-point format underflows SD59x18.\\nerror PRBMath_SD59x18_Convert_Underflow(int256 x);\\n\\n/// @notice Thrown when dividing two numbers and one of them is `MIN_SD59x18`.\\nerror PRBMath_SD59x18_Div_InputTooSmall();\\n\\n/// @notice Thrown when dividing two numbers and one of the intermediary unsigned results overflows SD59x18.\\nerror PRBMath_SD59x18_Div_Overflow(SD59x18 x, SD59x18 y);\\n\\n/// @notice Thrown when taking the natural exponent of a base greater than 133_084258667509499441.\\nerror PRBMath_SD59x18_Exp_InputTooBig(SD59x18 x);\\n\\n/// @notice Thrown when taking the binary exponent of a base greater than 192e18.\\nerror PRBMath_SD59x18_Exp2_InputTooBig(SD59x18 x);\\n\\n/// @notice Thrown when flooring a number underflows SD59x18.\\nerror PRBMath_SD59x18_Floor_Underflow(SD59x18 x);\\n\\n/// @notice Thrown when taking the geometric mean of two numbers and their product is negative.\\nerror PRBMath_SD59x18_Gm_NegativeProduct(SD59x18 x, SD59x18 y);\\n\\n/// @notice Thrown when taking the geometric mean of two numbers and multiplying them overflows SD59x18.\\nerror PRBMath_SD59x18_Gm_Overflow(SD59x18 x, SD59x18 y);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in SD1x18.\\nerror PRBMath_SD59x18_IntoSD1x18_Overflow(SD59x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in SD1x18.\\nerror PRBMath_SD59x18_IntoSD1x18_Underflow(SD59x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in UD2x18.\\nerror PRBMath_SD59x18_IntoUD2x18_Overflow(SD59x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in UD2x18.\\nerror PRBMath_SD59x18_IntoUD2x18_Underflow(SD59x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in UD60x18.\\nerror PRBMath_SD59x18_IntoUD60x18_Underflow(SD59x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in uint128.\\nerror PRBMath_SD59x18_IntoUint128_Overflow(SD59x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in uint128.\\nerror PRBMath_SD59x18_IntoUint128_Underflow(SD59x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in uint256.\\nerror PRBMath_SD59x18_IntoUint256_Underflow(SD59x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in uint40.\\nerror PRBMath_SD59x18_IntoUint40_Overflow(SD59x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in uint40.\\nerror PRBMath_SD59x18_IntoUint40_Underflow(SD59x18 x);\\n\\n/// @notice Thrown when taking the logarithm of a number less than or equal to zero.\\nerror PRBMath_SD59x18_Log_InputTooSmall(SD59x18 x);\\n\\n/// @notice Thrown when multiplying two numbers and one of the inputs is `MIN_SD59x18`.\\nerror PRBMath_SD59x18_Mul_InputTooSmall();\\n\\n/// @notice Thrown when multiplying two numbers and the intermediary absolute result overflows SD59x18.\\nerror PRBMath_SD59x18_Mul_Overflow(SD59x18 x, SD59x18 y);\\n\\n/// @notice Thrown when raising a number to a power and the intermediary absolute result overflows SD59x18.\\nerror PRBMath_SD59x18_Powu_Overflow(SD59x18 x, uint256 y);\\n\\n/// @notice Thrown when taking the square root of a negative number.\\nerror PRBMath_SD59x18_Sqrt_NegativeInput(SD59x18 x);\\n\\n/// @notice Thrown when the calculating the square root overflows SD59x18.\\nerror PRBMath_SD59x18_Sqrt_Overflow(SD59x18 x);\\n\",\"keccak256\":\"0xa6d00fe5efa215ac0df25c896e3da99a12fb61e799644b2ec32da947313d3db4\",\"license\":\"MIT\"},\"@prb/math/sd59x18/Helpers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { wrap } from \\\"./Casting.sol\\\";\\nimport { SD59x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Implements the checked addition operation (+) in the SD59x18 type.\\nfunction add(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    return wrap(x.unwrap() + y.unwrap());\\n}\\n\\n/// @notice Implements the AND (&) bitwise operation in the SD59x18 type.\\nfunction and(SD59x18 x, int256 bits) pure returns (SD59x18 result) {\\n    return wrap(x.unwrap() & bits);\\n}\\n\\n/// @notice Implements the AND (&) bitwise operation in the SD59x18 type.\\nfunction and2(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    return wrap(x.unwrap() & y.unwrap());\\n}\\n\\n/// @notice Implements the equal (=) operation in the SD59x18 type.\\nfunction eq(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = x.unwrap() == y.unwrap();\\n}\\n\\n/// @notice Implements the greater than operation (>) in the SD59x18 type.\\nfunction gt(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = x.unwrap() > y.unwrap();\\n}\\n\\n/// @notice Implements the greater than or equal to operation (>=) in the SD59x18 type.\\nfunction gte(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = x.unwrap() >= y.unwrap();\\n}\\n\\n/// @notice Implements a zero comparison check function in the SD59x18 type.\\nfunction isZero(SD59x18 x) pure returns (bool result) {\\n    result = x.unwrap() == 0;\\n}\\n\\n/// @notice Implements the left shift operation (<<) in the SD59x18 type.\\nfunction lshift(SD59x18 x, uint256 bits) pure returns (SD59x18 result) {\\n    result = wrap(x.unwrap() << bits);\\n}\\n\\n/// @notice Implements the lower than operation (<) in the SD59x18 type.\\nfunction lt(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = x.unwrap() < y.unwrap();\\n}\\n\\n/// @notice Implements the lower than or equal to operation (<=) in the SD59x18 type.\\nfunction lte(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = x.unwrap() <= y.unwrap();\\n}\\n\\n/// @notice Implements the unchecked modulo operation (%) in the SD59x18 type.\\nfunction mod(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    result = wrap(x.unwrap() % y.unwrap());\\n}\\n\\n/// @notice Implements the not equal operation (!=) in the SD59x18 type.\\nfunction neq(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = x.unwrap() != y.unwrap();\\n}\\n\\n/// @notice Implements the NOT (~) bitwise operation in the SD59x18 type.\\nfunction not(SD59x18 x) pure returns (SD59x18 result) {\\n    result = wrap(~x.unwrap());\\n}\\n\\n/// @notice Implements the OR (|) bitwise operation in the SD59x18 type.\\nfunction or(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    result = wrap(x.unwrap() | y.unwrap());\\n}\\n\\n/// @notice Implements the right shift operation (>>) in the SD59x18 type.\\nfunction rshift(SD59x18 x, uint256 bits) pure returns (SD59x18 result) {\\n    result = wrap(x.unwrap() >> bits);\\n}\\n\\n/// @notice Implements the checked subtraction operation (-) in the SD59x18 type.\\nfunction sub(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    result = wrap(x.unwrap() - y.unwrap());\\n}\\n\\n/// @notice Implements the checked unary minus operation (-) in the SD59x18 type.\\nfunction unary(SD59x18 x) pure returns (SD59x18 result) {\\n    result = wrap(-x.unwrap());\\n}\\n\\n/// @notice Implements the unchecked addition operation (+) in the SD59x18 type.\\nfunction uncheckedAdd(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    unchecked {\\n        result = wrap(x.unwrap() + y.unwrap());\\n    }\\n}\\n\\n/// @notice Implements the unchecked subtraction operation (-) in the SD59x18 type.\\nfunction uncheckedSub(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    unchecked {\\n        result = wrap(x.unwrap() - y.unwrap());\\n    }\\n}\\n\\n/// @notice Implements the unchecked unary minus operation (-) in the SD59x18 type.\\nfunction uncheckedUnary(SD59x18 x) pure returns (SD59x18 result) {\\n    unchecked {\\n        result = wrap(-x.unwrap());\\n    }\\n}\\n\\n/// @notice Implements the XOR (^) bitwise operation in the SD59x18 type.\\nfunction xor(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    result = wrap(x.unwrap() ^ y.unwrap());\\n}\\n\",\"keccak256\":\"0x208570f1657cf730cb6c3d81aa14030e0d45cf906cdedea5059369d7df4bb716\",\"license\":\"MIT\"},\"@prb/math/sd59x18/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport \\\"../Common.sol\\\" as Common;\\nimport \\\"./Errors.sol\\\" as Errors;\\nimport {\\n    uEXP_MAX_INPUT,\\n    uEXP2_MAX_INPUT,\\n    uEXP_MIN_THRESHOLD,\\n    uEXP2_MIN_THRESHOLD,\\n    uHALF_UNIT,\\n    uLOG2_10,\\n    uLOG2_E,\\n    uMAX_SD59x18,\\n    uMAX_WHOLE_SD59x18,\\n    uMIN_SD59x18,\\n    uMIN_WHOLE_SD59x18,\\n    UNIT,\\n    uUNIT,\\n    uUNIT_SQUARED,\\n    ZERO\\n} from \\\"./Constants.sol\\\";\\nimport { wrap } from \\\"./Helpers.sol\\\";\\nimport { SD59x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Calculates the absolute value of x.\\n///\\n/// @dev Requirements:\\n/// - x must be greater than `MIN_SD59x18`.\\n///\\n/// @param x The SD59x18 number for which to calculate the absolute value.\\n/// @param result The absolute value of x as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction abs(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    if (xInt == uMIN_SD59x18) {\\n        revert Errors.PRBMath_SD59x18_Abs_MinSD59x18();\\n    }\\n    result = xInt < 0 ? wrap(-xInt) : x;\\n}\\n\\n/// @notice Calculates the arithmetic average of x and y.\\n///\\n/// @dev Notes:\\n/// - The result is rounded toward zero.\\n///\\n/// @param x The first operand as an SD59x18 number.\\n/// @param y The second operand as an SD59x18 number.\\n/// @return result The arithmetic average as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction avg(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    int256 yInt = y.unwrap();\\n\\n    unchecked {\\n        // This operation is equivalent to `x / 2 +  y / 2`, and it can never overflow.\\n        int256 sum = (xInt >> 1) + (yInt >> 1);\\n\\n        if (sum < 0) {\\n            // If at least one of x and y is odd, add 1 to the result, because shifting negative numbers to the right\\n            // rounds toward negative infinity. The right part is equivalent to `sum + (x % 2 == 1 || y % 2 == 1)`.\\n            assembly (\\\"memory-safe\\\") {\\n                result := add(sum, and(or(xInt, yInt), 1))\\n            }\\n        } else {\\n            // Add 1 if both x and y are odd to account for the double 0.5 remainder truncated after shifting.\\n            result = wrap(sum + (xInt & yInt & 1));\\n        }\\n    }\\n}\\n\\n/// @notice Yields the smallest whole number greater than or equal to x.\\n///\\n/// @dev Optimized for fractional value inputs, because every whole value has (1e18 - 1) fractional counterparts.\\n/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n///\\n/// Requirements:\\n/// - x must be less than or equal to `MAX_WHOLE_SD59x18`.\\n///\\n/// @param x The SD59x18 number to ceil.\\n/// @param result The smallest whole number greater than or equal to x, as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction ceil(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    if (xInt > uMAX_WHOLE_SD59x18) {\\n        revert Errors.PRBMath_SD59x18_Ceil_Overflow(x);\\n    }\\n\\n    int256 remainder = xInt % uUNIT;\\n    if (remainder == 0) {\\n        result = x;\\n    } else {\\n        unchecked {\\n            // Solidity uses C fmod style, which returns a modulus with the same sign as x.\\n            int256 resultInt = xInt - remainder;\\n            if (xInt > 0) {\\n                resultInt += uUNIT;\\n            }\\n            result = wrap(resultInt);\\n        }\\n    }\\n}\\n\\n/// @notice Divides two SD59x18 numbers, returning a new SD59x18 number.\\n///\\n/// @dev This is an extension of {Common.mulDiv} for signed numbers, which works by computing the signs and the absolute\\n/// values separately.\\n///\\n/// Notes:\\n/// - Refer to the notes in {Common.mulDiv}.\\n/// - The result is rounded toward zero.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {Common.mulDiv}.\\n/// - None of the inputs can be `MIN_SD59x18`.\\n/// - The denominator must not be zero.\\n/// - The result must fit in SD59x18.\\n///\\n/// @param x The numerator as an SD59x18 number.\\n/// @param y The denominator as an SD59x18 number.\\n/// @param result The quotient as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction div(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    int256 yInt = y.unwrap();\\n    if (xInt == uMIN_SD59x18 || yInt == uMIN_SD59x18) {\\n        revert Errors.PRBMath_SD59x18_Div_InputTooSmall();\\n    }\\n\\n    // Get hold of the absolute values of x and y.\\n    uint256 xAbs;\\n    uint256 yAbs;\\n    unchecked {\\n        xAbs = xInt < 0 ? uint256(-xInt) : uint256(xInt);\\n        yAbs = yInt < 0 ? uint256(-yInt) : uint256(yInt);\\n    }\\n\\n    // Compute the absolute value (x*UNIT\\u00f7y). The resulting value must fit in SD59x18.\\n    uint256 resultAbs = Common.mulDiv(xAbs, uint256(uUNIT), yAbs);\\n    if (resultAbs > uint256(uMAX_SD59x18)) {\\n        revert Errors.PRBMath_SD59x18_Div_Overflow(x, y);\\n    }\\n\\n    // Check if x and y have the same sign using two's complement representation. The left-most bit represents the sign (1 for\\n    // negative, 0 for positive or zero).\\n    bool sameSign = (xInt ^ yInt) > -1;\\n\\n    // If the inputs have the same sign, the result should be positive. Otherwise, it should be negative.\\n    unchecked {\\n        result = wrap(sameSign ? int256(resultAbs) : -int256(resultAbs));\\n    }\\n}\\n\\n/// @notice Calculates the natural exponent of x using the following formula:\\n///\\n/// $$\\n/// e^x = 2^{x * log_2{e}}\\n/// $$\\n///\\n/// @dev Notes:\\n/// - Refer to the notes in {exp2}.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {exp2}.\\n/// - x must be less than 133_084258667509499441.\\n///\\n/// @param x The exponent as an SD59x18 number.\\n/// @return result The result as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction exp(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n\\n    // Any input less than the threshold returns zero.\\n    // This check also prevents an overflow for very small numbers.\\n    if (xInt < uEXP_MIN_THRESHOLD) {\\n        return ZERO;\\n    }\\n\\n    // This check prevents values greater than 192e18 from being passed to {exp2}.\\n    if (xInt > uEXP_MAX_INPUT) {\\n        revert Errors.PRBMath_SD59x18_Exp_InputTooBig(x);\\n    }\\n\\n    unchecked {\\n        // Inline the fixed-point multiplication to save gas.\\n        int256 doubleUnitProduct = xInt * uLOG2_E;\\n        result = exp2(wrap(doubleUnitProduct / uUNIT));\\n    }\\n}\\n\\n/// @notice Calculates the binary exponent of x using the binary fraction method using the following formula:\\n///\\n/// $$\\n/// 2^{-x} = \\\\frac{1}{2^x}\\n/// $$\\n///\\n/// @dev See https://ethereum.stackexchange.com/q/79903/24693.\\n///\\n/// Notes:\\n/// - If x is less than -59_794705707972522261, the result is zero.\\n///\\n/// Requirements:\\n/// - x must be less than 192e18.\\n/// - The result must fit in SD59x18.\\n///\\n/// @param x The exponent as an SD59x18 number.\\n/// @return result The result as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction exp2(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    if (xInt < 0) {\\n        // The inverse of any number less than the threshold is truncated to zero.\\n        if (xInt < uEXP2_MIN_THRESHOLD) {\\n            return ZERO;\\n        }\\n\\n        unchecked {\\n            // Inline the fixed-point inversion to save gas.\\n            result = wrap(uUNIT_SQUARED / exp2(wrap(-xInt)).unwrap());\\n        }\\n    } else {\\n        // Numbers greater than or equal to 192e18 don't fit in the 192.64-bit format.\\n        if (xInt > uEXP2_MAX_INPUT) {\\n            revert Errors.PRBMath_SD59x18_Exp2_InputTooBig(x);\\n        }\\n\\n        unchecked {\\n            // Convert x to the 192.64-bit fixed-point format.\\n            uint256 x_192x64 = uint256((xInt << 64) / uUNIT);\\n\\n            // It is safe to cast the result to int256 due to the checks above.\\n            result = wrap(int256(Common.exp2(x_192x64)));\\n        }\\n    }\\n}\\n\\n/// @notice Yields the greatest whole number less than or equal to x.\\n///\\n/// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional\\n/// counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n///\\n/// Requirements:\\n/// - x must be greater than or equal to `MIN_WHOLE_SD59x18`.\\n///\\n/// @param x The SD59x18 number to floor.\\n/// @param result The greatest whole number less than or equal to x, as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction floor(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    if (xInt < uMIN_WHOLE_SD59x18) {\\n        revert Errors.PRBMath_SD59x18_Floor_Underflow(x);\\n    }\\n\\n    int256 remainder = xInt % uUNIT;\\n    if (remainder == 0) {\\n        result = x;\\n    } else {\\n        unchecked {\\n            // Solidity uses C fmod style, which returns a modulus with the same sign as x.\\n            int256 resultInt = xInt - remainder;\\n            if (xInt < 0) {\\n                resultInt -= uUNIT;\\n            }\\n            result = wrap(resultInt);\\n        }\\n    }\\n}\\n\\n/// @notice Yields the excess beyond the floor of x for positive numbers and the part of the number to the right.\\n/// of the radix point for negative numbers.\\n/// @dev Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part\\n/// @param x The SD59x18 number to get the fractional part of.\\n/// @param result The fractional part of x as an SD59x18 number.\\nfunction frac(SD59x18 x) pure returns (SD59x18 result) {\\n    result = wrap(x.unwrap() % uUNIT);\\n}\\n\\n/// @notice Calculates the geometric mean of x and y, i.e. $\\\\sqrt{x * y}$.\\n///\\n/// @dev Notes:\\n/// - The result is rounded toward zero.\\n///\\n/// Requirements:\\n/// - x * y must fit in SD59x18.\\n/// - x * y must not be negative, since complex numbers are not supported.\\n///\\n/// @param x The first operand as an SD59x18 number.\\n/// @param y The second operand as an SD59x18 number.\\n/// @return result The result as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction gm(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    int256 yInt = y.unwrap();\\n    if (xInt == 0 || yInt == 0) {\\n        return ZERO;\\n    }\\n\\n    unchecked {\\n        // Equivalent to `xy / x != y`. Checking for overflow this way is faster than letting Solidity do it.\\n        int256 xyInt = xInt * yInt;\\n        if (xyInt / xInt != yInt) {\\n            revert Errors.PRBMath_SD59x18_Gm_Overflow(x, y);\\n        }\\n\\n        // The product must not be negative, since complex numbers are not supported.\\n        if (xyInt < 0) {\\n            revert Errors.PRBMath_SD59x18_Gm_NegativeProduct(x, y);\\n        }\\n\\n        // We don't need to multiply the result by `UNIT` here because the x*y product picked up a factor of `UNIT`\\n        // during multiplication. See the comments in {Common.sqrt}.\\n        uint256 resultUint = Common.sqrt(uint256(xyInt));\\n        result = wrap(int256(resultUint));\\n    }\\n}\\n\\n/// @notice Calculates the inverse of x.\\n///\\n/// @dev Notes:\\n/// - The result is rounded toward zero.\\n///\\n/// Requirements:\\n/// - x must not be zero.\\n///\\n/// @param x The SD59x18 number for which to calculate the inverse.\\n/// @return result The inverse as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction inv(SD59x18 x) pure returns (SD59x18 result) {\\n    result = wrap(uUNIT_SQUARED / x.unwrap());\\n}\\n\\n/// @notice Calculates the natural logarithm of x using the following formula:\\n///\\n/// $$\\n/// ln{x} = log_2{x} / log_2{e}\\n/// $$\\n///\\n/// @dev Notes:\\n/// - Refer to the notes in {log2}.\\n/// - The precision isn't sufficiently fine-grained to return exactly `UNIT` when the input is `E`.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {log2}.\\n///\\n/// @param x The SD59x18 number for which to calculate the natural logarithm.\\n/// @return result The natural logarithm as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction ln(SD59x18 x) pure returns (SD59x18 result) {\\n    // Inline the fixed-point multiplication to save gas. This is overflow-safe because the maximum value that\\n    // {log2} can return is ~195_205294292027477728.\\n    result = wrap(log2(x).unwrap() * uUNIT / uLOG2_E);\\n}\\n\\n/// @notice Calculates the common logarithm of x using the following formula:\\n///\\n/// $$\\n/// log_{10}{x} = log_2{x} / log_2{10}\\n/// $$\\n///\\n/// However, if x is an exact power of ten, a hard coded value is returned.\\n///\\n/// @dev Notes:\\n/// - Refer to the notes in {log2}.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {log2}.\\n///\\n/// @param x The SD59x18 number for which to calculate the common logarithm.\\n/// @return result The common logarithm as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction log10(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    if (xInt < 0) {\\n        revert Errors.PRBMath_SD59x18_Log_InputTooSmall(x);\\n    }\\n\\n    // Note that the `mul` in this block is the standard multiplication operation, not {SD59x18.mul}.\\n    // prettier-ignore\\n    assembly (\\\"memory-safe\\\") {\\n        switch x\\n        case 1 { result := mul(uUNIT, sub(0, 18)) }\\n        case 10 { result := mul(uUNIT, sub(1, 18)) }\\n        case 100 { result := mul(uUNIT, sub(2, 18)) }\\n        case 1000 { result := mul(uUNIT, sub(3, 18)) }\\n        case 10000 { result := mul(uUNIT, sub(4, 18)) }\\n        case 100000 { result := mul(uUNIT, sub(5, 18)) }\\n        case 1000000 { result := mul(uUNIT, sub(6, 18)) }\\n        case 10000000 { result := mul(uUNIT, sub(7, 18)) }\\n        case 100000000 { result := mul(uUNIT, sub(8, 18)) }\\n        case 1000000000 { result := mul(uUNIT, sub(9, 18)) }\\n        case 10000000000 { result := mul(uUNIT, sub(10, 18)) }\\n        case 100000000000 { result := mul(uUNIT, sub(11, 18)) }\\n        case 1000000000000 { result := mul(uUNIT, sub(12, 18)) }\\n        case 10000000000000 { result := mul(uUNIT, sub(13, 18)) }\\n        case 100000000000000 { result := mul(uUNIT, sub(14, 18)) }\\n        case 1000000000000000 { result := mul(uUNIT, sub(15, 18)) }\\n        case 10000000000000000 { result := mul(uUNIT, sub(16, 18)) }\\n        case 100000000000000000 { result := mul(uUNIT, sub(17, 18)) }\\n        case 1000000000000000000 { result := 0 }\\n        case 10000000000000000000 { result := uUNIT }\\n        case 100000000000000000000 { result := mul(uUNIT, 2) }\\n        case 1000000000000000000000 { result := mul(uUNIT, 3) }\\n        case 10000000000000000000000 { result := mul(uUNIT, 4) }\\n        case 100000000000000000000000 { result := mul(uUNIT, 5) }\\n        case 1000000000000000000000000 { result := mul(uUNIT, 6) }\\n        case 10000000000000000000000000 { result := mul(uUNIT, 7) }\\n        case 100000000000000000000000000 { result := mul(uUNIT, 8) }\\n        case 1000000000000000000000000000 { result := mul(uUNIT, 9) }\\n        case 10000000000000000000000000000 { result := mul(uUNIT, 10) }\\n        case 100000000000000000000000000000 { result := mul(uUNIT, 11) }\\n        case 1000000000000000000000000000000 { result := mul(uUNIT, 12) }\\n        case 10000000000000000000000000000000 { result := mul(uUNIT, 13) }\\n        case 100000000000000000000000000000000 { result := mul(uUNIT, 14) }\\n        case 1000000000000000000000000000000000 { result := mul(uUNIT, 15) }\\n        case 10000000000000000000000000000000000 { result := mul(uUNIT, 16) }\\n        case 100000000000000000000000000000000000 { result := mul(uUNIT, 17) }\\n        case 1000000000000000000000000000000000000 { result := mul(uUNIT, 18) }\\n        case 10000000000000000000000000000000000000 { result := mul(uUNIT, 19) }\\n        case 100000000000000000000000000000000000000 { result := mul(uUNIT, 20) }\\n        case 1000000000000000000000000000000000000000 { result := mul(uUNIT, 21) }\\n        case 10000000000000000000000000000000000000000 { result := mul(uUNIT, 22) }\\n        case 100000000000000000000000000000000000000000 { result := mul(uUNIT, 23) }\\n        case 1000000000000000000000000000000000000000000 { result := mul(uUNIT, 24) }\\n        case 10000000000000000000000000000000000000000000 { result := mul(uUNIT, 25) }\\n        case 100000000000000000000000000000000000000000000 { result := mul(uUNIT, 26) }\\n        case 1000000000000000000000000000000000000000000000 { result := mul(uUNIT, 27) }\\n        case 10000000000000000000000000000000000000000000000 { result := mul(uUNIT, 28) }\\n        case 100000000000000000000000000000000000000000000000 { result := mul(uUNIT, 29) }\\n        case 1000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 30) }\\n        case 10000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 31) }\\n        case 100000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 32) }\\n        case 1000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 33) }\\n        case 10000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 34) }\\n        case 100000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 35) }\\n        case 1000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 36) }\\n        case 10000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 37) }\\n        case 100000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 38) }\\n        case 1000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 39) }\\n        case 10000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 40) }\\n        case 100000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 41) }\\n        case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 42) }\\n        case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 43) }\\n        case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 44) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 45) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 46) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 47) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 48) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 49) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 50) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 51) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 52) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 53) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 54) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 55) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 56) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 57) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 58) }\\n        default { result := uMAX_SD59x18 }\\n    }\\n\\n    if (result.unwrap() == uMAX_SD59x18) {\\n        unchecked {\\n            // Inline the fixed-point division to save gas.\\n            result = wrap(log2(x).unwrap() * uUNIT / uLOG2_10);\\n        }\\n    }\\n}\\n\\n/// @notice Calculates the binary logarithm of x using the iterative approximation algorithm:\\n///\\n/// $$\\n/// log_2{x} = n + log_2{y}, \\\\text{ where } y = x*2^{-n}, \\\\ y \\\\in [1, 2)\\n/// $$\\n///\\n/// For $0 \\\\leq x \\\\lt 1$, the input is inverted:\\n///\\n/// $$\\n/// log_2{x} = -log_2{\\\\frac{1}{x}}\\n/// $$\\n///\\n/// @dev See https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation.\\n///\\n/// Notes:\\n/// - Due to the lossy precision of the iterative approximation, the results are not perfectly accurate to the last decimal.\\n///\\n/// Requirements:\\n/// - x must be greater than zero.\\n///\\n/// @param x The SD59x18 number for which to calculate the binary logarithm.\\n/// @return result The binary logarithm as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction log2(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    if (xInt <= 0) {\\n        revert Errors.PRBMath_SD59x18_Log_InputTooSmall(x);\\n    }\\n\\n    unchecked {\\n        int256 sign;\\n        if (xInt >= uUNIT) {\\n            sign = 1;\\n        } else {\\n            sign = -1;\\n            // Inline the fixed-point inversion to save gas.\\n            xInt = uUNIT_SQUARED / xInt;\\n        }\\n\\n        // Calculate the integer part of the logarithm.\\n        uint256 n = Common.msb(uint256(xInt / uUNIT));\\n\\n        // This is the integer part of the logarithm as an SD59x18 number. The operation can't overflow\\n        // because n is at most 255, `UNIT` is 1e18, and the sign is either 1 or -1.\\n        int256 resultInt = int256(n) * uUNIT;\\n\\n        // Calculate $y = x * 2^{-n}$.\\n        int256 y = xInt >> n;\\n\\n        // If y is the unit number, the fractional part is zero.\\n        if (y == uUNIT) {\\n            return wrap(resultInt * sign);\\n        }\\n\\n        // Calculate the fractional part via the iterative approximation.\\n        // The `delta >>= 1` part is equivalent to `delta /= 2`, but shifting bits is more gas efficient.\\n        int256 DOUBLE_UNIT = 2e18;\\n        for (int256 delta = uHALF_UNIT; delta > 0; delta >>= 1) {\\n            y = (y * y) / uUNIT;\\n\\n            // Is y^2 >= 2e18 and so in the range [2e18, 4e18)?\\n            if (y >= DOUBLE_UNIT) {\\n                // Add the 2^{-m} factor to the logarithm.\\n                resultInt = resultInt + delta;\\n\\n                // Halve y, which corresponds to z/2 in the Wikipedia article.\\n                y >>= 1;\\n            }\\n        }\\n        resultInt *= sign;\\n        result = wrap(resultInt);\\n    }\\n}\\n\\n/// @notice Multiplies two SD59x18 numbers together, returning a new SD59x18 number.\\n///\\n/// @dev Notes:\\n/// - Refer to the notes in {Common.mulDiv18}.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {Common.mulDiv18}.\\n/// - None of the inputs can be `MIN_SD59x18`.\\n/// - The result must fit in SD59x18.\\n///\\n/// @param x The multiplicand as an SD59x18 number.\\n/// @param y The multiplier as an SD59x18 number.\\n/// @return result The product as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction mul(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    int256 yInt = y.unwrap();\\n    if (xInt == uMIN_SD59x18 || yInt == uMIN_SD59x18) {\\n        revert Errors.PRBMath_SD59x18_Mul_InputTooSmall();\\n    }\\n\\n    // Get hold of the absolute values of x and y.\\n    uint256 xAbs;\\n    uint256 yAbs;\\n    unchecked {\\n        xAbs = xInt < 0 ? uint256(-xInt) : uint256(xInt);\\n        yAbs = yInt < 0 ? uint256(-yInt) : uint256(yInt);\\n    }\\n\\n    // Compute the absolute value (x*y\\u00f7UNIT). The resulting value must fit in SD59x18.\\n    uint256 resultAbs = Common.mulDiv18(xAbs, yAbs);\\n    if (resultAbs > uint256(uMAX_SD59x18)) {\\n        revert Errors.PRBMath_SD59x18_Mul_Overflow(x, y);\\n    }\\n\\n    // Check if x and y have the same sign using two's complement representation. The left-most bit represents the sign (1 for\\n    // negative, 0 for positive or zero).\\n    bool sameSign = (xInt ^ yInt) > -1;\\n\\n    // If the inputs have the same sign, the result should be positive. Otherwise, it should be negative.\\n    unchecked {\\n        result = wrap(sameSign ? int256(resultAbs) : -int256(resultAbs));\\n    }\\n}\\n\\n/// @notice Raises x to the power of y using the following formula:\\n///\\n/// $$\\n/// x^y = 2^{log_2{x} * y}\\n/// $$\\n///\\n/// @dev Notes:\\n/// - Refer to the notes in {exp2}, {log2}, and {mul}.\\n/// - Returns `UNIT` for 0^0.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {exp2}, {log2}, and {mul}.\\n///\\n/// @param x The base as an SD59x18 number.\\n/// @param y Exponent to raise x to, as an SD59x18 number\\n/// @return result x raised to power y, as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction pow(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    int256 yInt = y.unwrap();\\n\\n    // If both x and y are zero, the result is `UNIT`. If just x is zero, the result is always zero.\\n    if (xInt == 0) {\\n        return yInt == 0 ? UNIT : ZERO;\\n    }\\n    // If x is `UNIT`, the result is always `UNIT`.\\n    else if (xInt == uUNIT) {\\n        return UNIT;\\n    }\\n\\n    // If y is zero, the result is always `UNIT`.\\n    if (yInt == 0) {\\n        return UNIT;\\n    }\\n    // If y is `UNIT`, the result is always x.\\n    else if (yInt == uUNIT) {\\n        return x;\\n    }\\n\\n    // Calculate the result using the formula.\\n    result = exp2(mul(log2(x), y));\\n}\\n\\n/// @notice Raises x (an SD59x18 number) to the power y (an unsigned basic integer) using the well-known\\n/// algorithm \\\"exponentiation by squaring\\\".\\n///\\n/// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring.\\n///\\n/// Notes:\\n/// - Refer to the notes in {Common.mulDiv18}.\\n/// - Returns `UNIT` for 0^0.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {abs} and {Common.mulDiv18}.\\n/// - The result must fit in SD59x18.\\n///\\n/// @param x The base as an SD59x18 number.\\n/// @param y The exponent as a uint256.\\n/// @return result The result as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction powu(SD59x18 x, uint256 y) pure returns (SD59x18 result) {\\n    uint256 xAbs = uint256(abs(x).unwrap());\\n\\n    // Calculate the first iteration of the loop in advance.\\n    uint256 resultAbs = y & 1 > 0 ? xAbs : uint256(uUNIT);\\n\\n    // Equivalent to `for(y /= 2; y > 0; y /= 2)`.\\n    uint256 yAux = y;\\n    for (yAux >>= 1; yAux > 0; yAux >>= 1) {\\n        xAbs = Common.mulDiv18(xAbs, xAbs);\\n\\n        // Equivalent to `y % 2 == 1`.\\n        if (yAux & 1 > 0) {\\n            resultAbs = Common.mulDiv18(resultAbs, xAbs);\\n        }\\n    }\\n\\n    // The result must fit in SD59x18.\\n    if (resultAbs > uint256(uMAX_SD59x18)) {\\n        revert Errors.PRBMath_SD59x18_Powu_Overflow(x, y);\\n    }\\n\\n    unchecked {\\n        // Is the base negative and the exponent odd? If yes, the result should be negative.\\n        int256 resultInt = int256(resultAbs);\\n        bool isNegative = x.unwrap() < 0 && y & 1 == 1;\\n        if (isNegative) {\\n            resultInt = -resultInt;\\n        }\\n        result = wrap(resultInt);\\n    }\\n}\\n\\n/// @notice Calculates the square root of x using the Babylonian method.\\n///\\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n///\\n/// Notes:\\n/// - Only the positive root is returned.\\n/// - The result is rounded toward zero.\\n///\\n/// Requirements:\\n/// - x cannot be negative, since complex numbers are not supported.\\n/// - x must be less than `MAX_SD59x18 / UNIT`.\\n///\\n/// @param x The SD59x18 number for which to calculate the square root.\\n/// @return result The result as an SD59x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction sqrt(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = x.unwrap();\\n    if (xInt < 0) {\\n        revert Errors.PRBMath_SD59x18_Sqrt_NegativeInput(x);\\n    }\\n    if (xInt > uMAX_SD59x18 / uUNIT) {\\n        revert Errors.PRBMath_SD59x18_Sqrt_Overflow(x);\\n    }\\n\\n    unchecked {\\n        // Multiply x by `UNIT` to account for the factor of `UNIT` picked up when multiplying two SD59x18 numbers.\\n        // In this case, the two numbers are both the square root.\\n        uint256 resultUint = Common.sqrt(uint256(xInt * uUNIT));\\n        result = wrap(int256(resultUint));\\n    }\\n}\\n\",\"keccak256\":\"0xa074831139fc89ca0e5a36086b30eb50896bb6770cd5823461b1f2769017d2f0\",\"license\":\"MIT\"},\"@prb/math/sd59x18/ValueType.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport \\\"./Casting.sol\\\" as Casting;\\nimport \\\"./Helpers.sol\\\" as Helpers;\\nimport \\\"./Math.sol\\\" as Math;\\n\\n/// @notice The signed 59.18-decimal fixed-point number representation, which can have up to 59 digits and up to 18\\n/// decimals. The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity\\n/// type int256.\\ntype SD59x18 is int256;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    CASTING\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nusing {\\n    Casting.intoInt256,\\n    Casting.intoSD1x18,\\n    Casting.intoUD2x18,\\n    Casting.intoUD60x18,\\n    Casting.intoUint256,\\n    Casting.intoUint128,\\n    Casting.intoUint40,\\n    Casting.unwrap\\n} for SD59x18 global;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                            MATHEMATICAL FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nusing {\\n    Math.abs,\\n    Math.avg,\\n    Math.ceil,\\n    Math.div,\\n    Math.exp,\\n    Math.exp2,\\n    Math.floor,\\n    Math.frac,\\n    Math.gm,\\n    Math.inv,\\n    Math.log10,\\n    Math.log2,\\n    Math.ln,\\n    Math.mul,\\n    Math.pow,\\n    Math.powu,\\n    Math.sqrt\\n} for SD59x18 global;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                HELPER FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nusing {\\n    Helpers.add,\\n    Helpers.and,\\n    Helpers.eq,\\n    Helpers.gt,\\n    Helpers.gte,\\n    Helpers.isZero,\\n    Helpers.lshift,\\n    Helpers.lt,\\n    Helpers.lte,\\n    Helpers.mod,\\n    Helpers.neq,\\n    Helpers.not,\\n    Helpers.or,\\n    Helpers.rshift,\\n    Helpers.sub,\\n    Helpers.uncheckedAdd,\\n    Helpers.uncheckedSub,\\n    Helpers.uncheckedUnary,\\n    Helpers.xor\\n} for SD59x18 global;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    OPERATORS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n// The global \\\"using for\\\" directive makes it possible to use these operators on the SD59x18 type.\\nusing {\\n    Helpers.add as +,\\n    Helpers.and2 as &,\\n    Math.div as /,\\n    Helpers.eq as ==,\\n    Helpers.gt as >,\\n    Helpers.gte as >=,\\n    Helpers.lt as <,\\n    Helpers.lte as <=,\\n    Helpers.mod as %,\\n    Math.mul as *,\\n    Helpers.neq as !=,\\n    Helpers.not as ~,\\n    Helpers.or as |,\\n    Helpers.sub as -,\\n    Helpers.unary as -,\\n    Helpers.xor as ^\\n} for SD59x18 global;\\n\",\"keccak256\":\"0xe03112d145dcd5863aff24e5f381debaae29d446acd5666f3d640e3d9af738d7\",\"license\":\"MIT\"},\"@prb/math/ud2x18/Casting.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport \\\"../Common.sol\\\" as Common;\\nimport \\\"./Errors.sol\\\" as Errors;\\nimport { uMAX_SD1x18 } from \\\"../sd1x18/Constants.sol\\\";\\nimport { SD1x18 } from \\\"../sd1x18/ValueType.sol\\\";\\nimport { SD59x18 } from \\\"../sd59x18/ValueType.sol\\\";\\nimport { UD60x18 } from \\\"../ud60x18/ValueType.sol\\\";\\nimport { UD2x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Casts a UD2x18 number into SD1x18.\\n/// - x must be less than or equal to `uMAX_SD1x18`.\\nfunction intoSD1x18(UD2x18 x) pure returns (SD1x18 result) {\\n    uint64 xUint = UD2x18.unwrap(x);\\n    if (xUint > uint64(uMAX_SD1x18)) {\\n        revert Errors.PRBMath_UD2x18_IntoSD1x18_Overflow(x);\\n    }\\n    result = SD1x18.wrap(int64(xUint));\\n}\\n\\n/// @notice Casts a UD2x18 number into SD59x18.\\n/// @dev There is no overflow check because the domain of UD2x18 is a subset of SD59x18.\\nfunction intoSD59x18(UD2x18 x) pure returns (SD59x18 result) {\\n    result = SD59x18.wrap(int256(uint256(UD2x18.unwrap(x))));\\n}\\n\\n/// @notice Casts a UD2x18 number into UD60x18.\\n/// @dev There is no overflow check because the domain of UD2x18 is a subset of UD60x18.\\nfunction intoUD60x18(UD2x18 x) pure returns (UD60x18 result) {\\n    result = UD60x18.wrap(UD2x18.unwrap(x));\\n}\\n\\n/// @notice Casts a UD2x18 number into uint128.\\n/// @dev There is no overflow check because the domain of UD2x18 is a subset of uint128.\\nfunction intoUint128(UD2x18 x) pure returns (uint128 result) {\\n    result = uint128(UD2x18.unwrap(x));\\n}\\n\\n/// @notice Casts a UD2x18 number into uint256.\\n/// @dev There is no overflow check because the domain of UD2x18 is a subset of uint256.\\nfunction intoUint256(UD2x18 x) pure returns (uint256 result) {\\n    result = uint256(UD2x18.unwrap(x));\\n}\\n\\n/// @notice Casts a UD2x18 number into uint40.\\n/// @dev Requirements:\\n/// - x must be less than or equal to `MAX_UINT40`.\\nfunction intoUint40(UD2x18 x) pure returns (uint40 result) {\\n    uint64 xUint = UD2x18.unwrap(x);\\n    if (xUint > uint64(Common.MAX_UINT40)) {\\n        revert Errors.PRBMath_UD2x18_IntoUint40_Overflow(x);\\n    }\\n    result = uint40(xUint);\\n}\\n\\n/// @notice Alias for {wrap}.\\nfunction ud2x18(uint64 x) pure returns (UD2x18 result) {\\n    result = UD2x18.wrap(x);\\n}\\n\\n/// @notice Unwrap a UD2x18 number into uint64.\\nfunction unwrap(UD2x18 x) pure returns (uint64 result) {\\n    result = UD2x18.unwrap(x);\\n}\\n\\n/// @notice Wraps a uint64 number into UD2x18.\\nfunction wrap(uint64 x) pure returns (UD2x18 result) {\\n    result = UD2x18.wrap(x);\\n}\\n\",\"keccak256\":\"0x9b1a35d432ef951a415fae8098b3c609a99b630a3d5464b3c8e1efa8893eea07\",\"license\":\"MIT\"},\"@prb/math/ud2x18/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { UD2x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @dev Euler's number as a UD2x18 number.\\nUD2x18 constant E = UD2x18.wrap(2_718281828459045235);\\n\\n/// @dev The maximum value a UD2x18 number can have.\\nuint64 constant uMAX_UD2x18 = 18_446744073709551615;\\nUD2x18 constant MAX_UD2x18 = UD2x18.wrap(uMAX_UD2x18);\\n\\n/// @dev PI as a UD2x18 number.\\nUD2x18 constant PI = UD2x18.wrap(3_141592653589793238);\\n\\n/// @dev The unit number, which gives the decimal precision of UD2x18.\\nUD2x18 constant UNIT = UD2x18.wrap(1e18);\\nuint64 constant uUNIT = 1e18;\\n\",\"keccak256\":\"0x29b0e050c865899e1fb9022b460a7829cdee248c44c4299f068ba80695eec3fc\",\"license\":\"MIT\"},\"@prb/math/ud2x18/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { UD2x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Thrown when trying to cast a UD2x18 number that doesn't fit in SD1x18.\\nerror PRBMath_UD2x18_IntoSD1x18_Overflow(UD2x18 x);\\n\\n/// @notice Thrown when trying to cast a UD2x18 number that doesn't fit in uint40.\\nerror PRBMath_UD2x18_IntoUint40_Overflow(UD2x18 x);\\n\",\"keccak256\":\"0xdf1e22f0b4c8032bcc8b7f63fe3984e1387f3dc7b2e9ab381822249f75376d33\",\"license\":\"MIT\"},\"@prb/math/ud2x18/ValueType.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport \\\"./Casting.sol\\\" as Casting;\\n\\n/// @notice The unsigned 2.18-decimal fixed-point number representation, which can have up to 2 digits and up to 18\\n/// decimals. The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity\\n/// type uint64. This is useful when end users want to use uint64 to save gas, e.g. with tight variable packing in contract\\n/// storage.\\ntype UD2x18 is uint64;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    CASTING\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nusing {\\n    Casting.intoSD1x18,\\n    Casting.intoSD59x18,\\n    Casting.intoUD60x18,\\n    Casting.intoUint256,\\n    Casting.intoUint128,\\n    Casting.intoUint40,\\n    Casting.unwrap\\n} for UD2x18 global;\\n\",\"keccak256\":\"0x2802edc9869db116a0b5c490cc5f8554742f747183fa30ac5e9c80bb967e61a1\",\"license\":\"MIT\"},\"@prb/math/ud60x18/Casting.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport \\\"./Errors.sol\\\" as CastingErrors;\\nimport { MAX_UINT128, MAX_UINT40 } from \\\"../Common.sol\\\";\\nimport { uMAX_SD1x18 } from \\\"../sd1x18/Constants.sol\\\";\\nimport { SD1x18 } from \\\"../sd1x18/ValueType.sol\\\";\\nimport { uMAX_SD59x18 } from \\\"../sd59x18/Constants.sol\\\";\\nimport { SD59x18 } from \\\"../sd59x18/ValueType.sol\\\";\\nimport { uMAX_UD2x18 } from \\\"../ud2x18/Constants.sol\\\";\\nimport { UD2x18 } from \\\"../ud2x18/ValueType.sol\\\";\\nimport { UD60x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Casts a UD60x18 number into SD1x18.\\n/// @dev Requirements:\\n/// - x must be less than or equal to `uMAX_SD1x18`.\\nfunction intoSD1x18(UD60x18 x) pure returns (SD1x18 result) {\\n    uint256 xUint = UD60x18.unwrap(x);\\n    if (xUint > uint256(int256(uMAX_SD1x18))) {\\n        revert CastingErrors.PRBMath_UD60x18_IntoSD1x18_Overflow(x);\\n    }\\n    result = SD1x18.wrap(int64(uint64(xUint)));\\n}\\n\\n/// @notice Casts a UD60x18 number into UD2x18.\\n/// @dev Requirements:\\n/// - x must be less than or equal to `uMAX_UD2x18`.\\nfunction intoUD2x18(UD60x18 x) pure returns (UD2x18 result) {\\n    uint256 xUint = UD60x18.unwrap(x);\\n    if (xUint > uMAX_UD2x18) {\\n        revert CastingErrors.PRBMath_UD60x18_IntoUD2x18_Overflow(x);\\n    }\\n    result = UD2x18.wrap(uint64(xUint));\\n}\\n\\n/// @notice Casts a UD60x18 number into SD59x18.\\n/// @dev Requirements:\\n/// - x must be less than or equal to `uMAX_SD59x18`.\\nfunction intoSD59x18(UD60x18 x) pure returns (SD59x18 result) {\\n    uint256 xUint = UD60x18.unwrap(x);\\n    if (xUint > uint256(uMAX_SD59x18)) {\\n        revert CastingErrors.PRBMath_UD60x18_IntoSD59x18_Overflow(x);\\n    }\\n    result = SD59x18.wrap(int256(xUint));\\n}\\n\\n/// @notice Casts a UD60x18 number into uint128.\\n/// @dev This is basically an alias for {unwrap}.\\nfunction intoUint256(UD60x18 x) pure returns (uint256 result) {\\n    result = UD60x18.unwrap(x);\\n}\\n\\n/// @notice Casts a UD60x18 number into uint128.\\n/// @dev Requirements:\\n/// - x must be less than or equal to `MAX_UINT128`.\\nfunction intoUint128(UD60x18 x) pure returns (uint128 result) {\\n    uint256 xUint = UD60x18.unwrap(x);\\n    if (xUint > MAX_UINT128) {\\n        revert CastingErrors.PRBMath_UD60x18_IntoUint128_Overflow(x);\\n    }\\n    result = uint128(xUint);\\n}\\n\\n/// @notice Casts a UD60x18 number into uint40.\\n/// @dev Requirements:\\n/// - x must be less than or equal to `MAX_UINT40`.\\nfunction intoUint40(UD60x18 x) pure returns (uint40 result) {\\n    uint256 xUint = UD60x18.unwrap(x);\\n    if (xUint > MAX_UINT40) {\\n        revert CastingErrors.PRBMath_UD60x18_IntoUint40_Overflow(x);\\n    }\\n    result = uint40(xUint);\\n}\\n\\n/// @notice Alias for {wrap}.\\nfunction ud(uint256 x) pure returns (UD60x18 result) {\\n    result = UD60x18.wrap(x);\\n}\\n\\n/// @notice Alias for {wrap}.\\nfunction ud60x18(uint256 x) pure returns (UD60x18 result) {\\n    result = UD60x18.wrap(x);\\n}\\n\\n/// @notice Unwraps a UD60x18 number into uint256.\\nfunction unwrap(UD60x18 x) pure returns (uint256 result) {\\n    result = UD60x18.unwrap(x);\\n}\\n\\n/// @notice Wraps a uint256 number into the UD60x18 value type.\\nfunction wrap(uint256 x) pure returns (UD60x18 result) {\\n    result = UD60x18.wrap(x);\\n}\\n\",\"keccak256\":\"0x5bb532da36921cbdac64d1f16de5d366ef1f664502e3b7c07d0ad06917551f85\",\"license\":\"MIT\"},\"@prb/math/ud60x18/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { UD60x18 } from \\\"./ValueType.sol\\\";\\n\\n// NOTICE: the \\\"u\\\" prefix stands for \\\"unwrapped\\\".\\n\\n/// @dev Euler's number as a UD60x18 number.\\nUD60x18 constant E = UD60x18.wrap(2_718281828459045235);\\n\\n/// @dev The maximum input permitted in {exp}.\\nuint256 constant uEXP_MAX_INPUT = 133_084258667509499440;\\nUD60x18 constant EXP_MAX_INPUT = UD60x18.wrap(uEXP_MAX_INPUT);\\n\\n/// @dev The maximum input permitted in {exp2}.\\nuint256 constant uEXP2_MAX_INPUT = 192e18 - 1;\\nUD60x18 constant EXP2_MAX_INPUT = UD60x18.wrap(uEXP2_MAX_INPUT);\\n\\n/// @dev Half the UNIT number.\\nuint256 constant uHALF_UNIT = 0.5e18;\\nUD60x18 constant HALF_UNIT = UD60x18.wrap(uHALF_UNIT);\\n\\n/// @dev $log_2(10)$ as a UD60x18 number.\\nuint256 constant uLOG2_10 = 3_321928094887362347;\\nUD60x18 constant LOG2_10 = UD60x18.wrap(uLOG2_10);\\n\\n/// @dev $log_2(e)$ as a UD60x18 number.\\nuint256 constant uLOG2_E = 1_442695040888963407;\\nUD60x18 constant LOG2_E = UD60x18.wrap(uLOG2_E);\\n\\n/// @dev The maximum value a UD60x18 number can have.\\nuint256 constant uMAX_UD60x18 = 115792089237316195423570985008687907853269984665640564039457_584007913129639935;\\nUD60x18 constant MAX_UD60x18 = UD60x18.wrap(uMAX_UD60x18);\\n\\n/// @dev The maximum whole value a UD60x18 number can have.\\nuint256 constant uMAX_WHOLE_UD60x18 = 115792089237316195423570985008687907853269984665640564039457_000000000000000000;\\nUD60x18 constant MAX_WHOLE_UD60x18 = UD60x18.wrap(uMAX_WHOLE_UD60x18);\\n\\n/// @dev PI as a UD60x18 number.\\nUD60x18 constant PI = UD60x18.wrap(3_141592653589793238);\\n\\n/// @dev The unit number, which gives the decimal precision of UD60x18.\\nuint256 constant uUNIT = 1e18;\\nUD60x18 constant UNIT = UD60x18.wrap(uUNIT);\\n\\n/// @dev The unit number squared.\\nuint256 constant uUNIT_SQUARED = 1e36;\\nUD60x18 constant UNIT_SQUARED = UD60x18.wrap(uUNIT_SQUARED);\\n\\n/// @dev Zero as a UD60x18 number.\\nUD60x18 constant ZERO = UD60x18.wrap(0);\\n\",\"keccak256\":\"0x2b80d26153d3fdcfb3a9ca772d9309d31ed1275f5b8b54c3ffb54d3652b37d90\",\"license\":\"MIT\"},\"@prb/math/ud60x18/Conversions.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { uMAX_UD60x18, uUNIT } from \\\"./Constants.sol\\\";\\nimport { PRBMath_UD60x18_Convert_Overflow } from \\\"./Errors.sol\\\";\\nimport { UD60x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Converts a UD60x18 number to a simple integer by dividing it by `UNIT`.\\n/// @dev The result is rounded toward zero.\\n/// @param x The UD60x18 number to convert.\\n/// @return result The same number in basic integer form.\\nfunction convert(UD60x18 x) pure returns (uint256 result) {\\n    result = UD60x18.unwrap(x) / uUNIT;\\n}\\n\\n/// @notice Converts a simple integer to UD60x18 by multiplying it by `UNIT`.\\n///\\n/// @dev Requirements:\\n/// - x must be less than or equal to `MAX_UD60x18 / UNIT`.\\n///\\n/// @param x The basic integer to convert.\\n/// @param result The same number converted to UD60x18.\\nfunction convert(uint256 x) pure returns (UD60x18 result) {\\n    if (x > uMAX_UD60x18 / uUNIT) {\\n        revert PRBMath_UD60x18_Convert_Overflow(x);\\n    }\\n    unchecked {\\n        result = UD60x18.wrap(x * uUNIT);\\n    }\\n}\\n\",\"keccak256\":\"0xaf7fc2523413822de3b66ba339fe2884fb3b8c6f6cf38ec90a2c3e3aae71df6b\",\"license\":\"MIT\"},\"@prb/math/ud60x18/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { UD60x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Thrown when ceiling a number overflows UD60x18.\\nerror PRBMath_UD60x18_Ceil_Overflow(UD60x18 x);\\n\\n/// @notice Thrown when converting a basic integer to the fixed-point format overflows UD60x18.\\nerror PRBMath_UD60x18_Convert_Overflow(uint256 x);\\n\\n/// @notice Thrown when taking the natural exponent of a base greater than 133_084258667509499441.\\nerror PRBMath_UD60x18_Exp_InputTooBig(UD60x18 x);\\n\\n/// @notice Thrown when taking the binary exponent of a base greater than 192e18.\\nerror PRBMath_UD60x18_Exp2_InputTooBig(UD60x18 x);\\n\\n/// @notice Thrown when taking the geometric mean of two numbers and multiplying them overflows UD60x18.\\nerror PRBMath_UD60x18_Gm_Overflow(UD60x18 x, UD60x18 y);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in SD1x18.\\nerror PRBMath_UD60x18_IntoSD1x18_Overflow(UD60x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in SD59x18.\\nerror PRBMath_UD60x18_IntoSD59x18_Overflow(UD60x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in UD2x18.\\nerror PRBMath_UD60x18_IntoUD2x18_Overflow(UD60x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in uint128.\\nerror PRBMath_UD60x18_IntoUint128_Overflow(UD60x18 x);\\n\\n/// @notice Thrown when trying to cast a UD60x18 number that doesn't fit in uint40.\\nerror PRBMath_UD60x18_IntoUint40_Overflow(UD60x18 x);\\n\\n/// @notice Thrown when taking the logarithm of a number less than 1.\\nerror PRBMath_UD60x18_Log_InputTooSmall(UD60x18 x);\\n\\n/// @notice Thrown when calculating the square root overflows UD60x18.\\nerror PRBMath_UD60x18_Sqrt_Overflow(UD60x18 x);\\n\",\"keccak256\":\"0xa8c60d4066248df22c49c882873efbc017344107edabc48c52209abbc39cb1e3\",\"license\":\"MIT\"},\"@prb/math/ud60x18/Helpers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport { wrap } from \\\"./Casting.sol\\\";\\nimport { UD60x18 } from \\\"./ValueType.sol\\\";\\n\\n/// @notice Implements the checked addition operation (+) in the UD60x18 type.\\nfunction add(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(x.unwrap() + y.unwrap());\\n}\\n\\n/// @notice Implements the AND (&) bitwise operation in the UD60x18 type.\\nfunction and(UD60x18 x, uint256 bits) pure returns (UD60x18 result) {\\n    result = wrap(x.unwrap() & bits);\\n}\\n\\n/// @notice Implements the AND (&) bitwise operation in the UD60x18 type.\\nfunction and2(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(x.unwrap() & y.unwrap());\\n}\\n\\n/// @notice Implements the equal operation (==) in the UD60x18 type.\\nfunction eq(UD60x18 x, UD60x18 y) pure returns (bool result) {\\n    result = x.unwrap() == y.unwrap();\\n}\\n\\n/// @notice Implements the greater than operation (>) in the UD60x18 type.\\nfunction gt(UD60x18 x, UD60x18 y) pure returns (bool result) {\\n    result = x.unwrap() > y.unwrap();\\n}\\n\\n/// @notice Implements the greater than or equal to operation (>=) in the UD60x18 type.\\nfunction gte(UD60x18 x, UD60x18 y) pure returns (bool result) {\\n    result = x.unwrap() >= y.unwrap();\\n}\\n\\n/// @notice Implements a zero comparison check function in the UD60x18 type.\\nfunction isZero(UD60x18 x) pure returns (bool result) {\\n    // This wouldn't work if x could be negative.\\n    result = x.unwrap() == 0;\\n}\\n\\n/// @notice Implements the left shift operation (<<) in the UD60x18 type.\\nfunction lshift(UD60x18 x, uint256 bits) pure returns (UD60x18 result) {\\n    result = wrap(x.unwrap() << bits);\\n}\\n\\n/// @notice Implements the lower than operation (<) in the UD60x18 type.\\nfunction lt(UD60x18 x, UD60x18 y) pure returns (bool result) {\\n    result = x.unwrap() < y.unwrap();\\n}\\n\\n/// @notice Implements the lower than or equal to operation (<=) in the UD60x18 type.\\nfunction lte(UD60x18 x, UD60x18 y) pure returns (bool result) {\\n    result = x.unwrap() <= y.unwrap();\\n}\\n\\n/// @notice Implements the checked modulo operation (%) in the UD60x18 type.\\nfunction mod(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(x.unwrap() % y.unwrap());\\n}\\n\\n/// @notice Implements the not equal operation (!=) in the UD60x18 type.\\nfunction neq(UD60x18 x, UD60x18 y) pure returns (bool result) {\\n    result = x.unwrap() != y.unwrap();\\n}\\n\\n/// @notice Implements the NOT (~) bitwise operation in the UD60x18 type.\\nfunction not(UD60x18 x) pure returns (UD60x18 result) {\\n    result = wrap(~x.unwrap());\\n}\\n\\n/// @notice Implements the OR (|) bitwise operation in the UD60x18 type.\\nfunction or(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(x.unwrap() | y.unwrap());\\n}\\n\\n/// @notice Implements the right shift operation (>>) in the UD60x18 type.\\nfunction rshift(UD60x18 x, uint256 bits) pure returns (UD60x18 result) {\\n    result = wrap(x.unwrap() >> bits);\\n}\\n\\n/// @notice Implements the checked subtraction operation (-) in the UD60x18 type.\\nfunction sub(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(x.unwrap() - y.unwrap());\\n}\\n\\n/// @notice Implements the unchecked addition operation (+) in the UD60x18 type.\\nfunction uncheckedAdd(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    unchecked {\\n        result = wrap(x.unwrap() + y.unwrap());\\n    }\\n}\\n\\n/// @notice Implements the unchecked subtraction operation (-) in the UD60x18 type.\\nfunction uncheckedSub(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    unchecked {\\n        result = wrap(x.unwrap() - y.unwrap());\\n    }\\n}\\n\\n/// @notice Implements the XOR (^) bitwise operation in the UD60x18 type.\\nfunction xor(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(x.unwrap() ^ y.unwrap());\\n}\\n\",\"keccak256\":\"0xf5faff881391d2c060029499a666cc5f0bea90a213150bb476fae8f02a5df268\",\"license\":\"MIT\"},\"@prb/math/ud60x18/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport \\\"../Common.sol\\\" as Common;\\nimport \\\"./Errors.sol\\\" as Errors;\\nimport { wrap } from \\\"./Casting.sol\\\";\\nimport {\\n    uEXP_MAX_INPUT,\\n    uEXP2_MAX_INPUT,\\n    uHALF_UNIT,\\n    uLOG2_10,\\n    uLOG2_E,\\n    uMAX_UD60x18,\\n    uMAX_WHOLE_UD60x18,\\n    UNIT,\\n    uUNIT,\\n    uUNIT_SQUARED,\\n    ZERO\\n} from \\\"./Constants.sol\\\";\\nimport { UD60x18 } from \\\"./ValueType.sol\\\";\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                            MATHEMATICAL FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Calculates the arithmetic average of x and y using the following formula:\\n///\\n/// $$\\n/// avg(x, y) = (x & y) + ((xUint ^ yUint) / 2)\\n/// $$\\n///\\n/// In English, this is what this formula does:\\n///\\n/// 1. AND x and y.\\n/// 2. Calculate half of XOR x and y.\\n/// 3. Add the two results together.\\n///\\n/// This technique is known as SWAR, which stands for \\\"SIMD within a register\\\". You can read more about it here:\\n/// https://devblogs.microsoft.com/oldnewthing/20220207-00/?p=106223\\n///\\n/// @dev Notes:\\n/// - The result is rounded toward zero.\\n///\\n/// @param x The first operand as a UD60x18 number.\\n/// @param y The second operand as a UD60x18 number.\\n/// @return result The arithmetic average as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction avg(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    uint256 xUint = x.unwrap();\\n    uint256 yUint = y.unwrap();\\n    unchecked {\\n        result = wrap((xUint & yUint) + ((xUint ^ yUint) >> 1));\\n    }\\n}\\n\\n/// @notice Yields the smallest whole number greater than or equal to x.\\n///\\n/// @dev This is optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional\\n/// counterparts. See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n///\\n/// Requirements:\\n/// - x must be less than or equal to `MAX_WHOLE_UD60x18`.\\n///\\n/// @param x The UD60x18 number to ceil.\\n/// @param result The smallest whole number greater than or equal to x, as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction ceil(UD60x18 x) pure returns (UD60x18 result) {\\n    uint256 xUint = x.unwrap();\\n    if (xUint > uMAX_WHOLE_UD60x18) {\\n        revert Errors.PRBMath_UD60x18_Ceil_Overflow(x);\\n    }\\n\\n    assembly (\\\"memory-safe\\\") {\\n        // Equivalent to `x % UNIT`.\\n        let remainder := mod(x, uUNIT)\\n\\n        // Equivalent to `UNIT - remainder`.\\n        let delta := sub(uUNIT, remainder)\\n\\n        // Equivalent to `x + remainder > 0 ? delta : 0`.\\n        result := add(x, mul(delta, gt(remainder, 0)))\\n    }\\n}\\n\\n/// @notice Divides two UD60x18 numbers, returning a new UD60x18 number.\\n///\\n/// @dev Uses {Common.mulDiv} to enable overflow-safe multiplication and division.\\n///\\n/// Notes:\\n/// - Refer to the notes in {Common.mulDiv}.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {Common.mulDiv}.\\n///\\n/// @param x The numerator as a UD60x18 number.\\n/// @param y The denominator as a UD60x18 number.\\n/// @param result The quotient as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction div(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(Common.mulDiv(x.unwrap(), uUNIT, y.unwrap()));\\n}\\n\\n/// @notice Calculates the natural exponent of x using the following formula:\\n///\\n/// $$\\n/// e^x = 2^{x * log_2{e}}\\n/// $$\\n///\\n/// @dev Requirements:\\n/// - x must be less than 133_084258667509499441.\\n///\\n/// @param x The exponent as a UD60x18 number.\\n/// @return result The result as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction exp(UD60x18 x) pure returns (UD60x18 result) {\\n    uint256 xUint = x.unwrap();\\n\\n    // This check prevents values greater than 192e18 from being passed to {exp2}.\\n    if (xUint > uEXP_MAX_INPUT) {\\n        revert Errors.PRBMath_UD60x18_Exp_InputTooBig(x);\\n    }\\n\\n    unchecked {\\n        // Inline the fixed-point multiplication to save gas.\\n        uint256 doubleUnitProduct = xUint * uLOG2_E;\\n        result = exp2(wrap(doubleUnitProduct / uUNIT));\\n    }\\n}\\n\\n/// @notice Calculates the binary exponent of x using the binary fraction method.\\n///\\n/// @dev See https://ethereum.stackexchange.com/q/79903/24693\\n///\\n/// Requirements:\\n/// - x must be less than 192e18.\\n/// - The result must fit in UD60x18.\\n///\\n/// @param x The exponent as a UD60x18 number.\\n/// @return result The result as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction exp2(UD60x18 x) pure returns (UD60x18 result) {\\n    uint256 xUint = x.unwrap();\\n\\n    // Numbers greater than or equal to 192e18 don't fit in the 192.64-bit format.\\n    if (xUint > uEXP2_MAX_INPUT) {\\n        revert Errors.PRBMath_UD60x18_Exp2_InputTooBig(x);\\n    }\\n\\n    // Convert x to the 192.64-bit fixed-point format.\\n    uint256 x_192x64 = (xUint << 64) / uUNIT;\\n\\n    // Pass x to the {Common.exp2} function, which uses the 192.64-bit fixed-point number representation.\\n    result = wrap(Common.exp2(x_192x64));\\n}\\n\\n/// @notice Yields the greatest whole number less than or equal to x.\\n/// @dev Optimized for fractional value inputs, because every whole value has (1e18 - 1) fractional counterparts.\\n/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n/// @param x The UD60x18 number to floor.\\n/// @param result The greatest whole number less than or equal to x, as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction floor(UD60x18 x) pure returns (UD60x18 result) {\\n    assembly (\\\"memory-safe\\\") {\\n        // Equivalent to `x % UNIT`.\\n        let remainder := mod(x, uUNIT)\\n\\n        // Equivalent to `x - remainder > 0 ? remainder : 0)`.\\n        result := sub(x, mul(remainder, gt(remainder, 0)))\\n    }\\n}\\n\\n/// @notice Yields the excess beyond the floor of x using the odd function definition.\\n/// @dev See https://en.wikipedia.org/wiki/Fractional_part.\\n/// @param x The UD60x18 number to get the fractional part of.\\n/// @param result The fractional part of x as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction frac(UD60x18 x) pure returns (UD60x18 result) {\\n    assembly (\\\"memory-safe\\\") {\\n        result := mod(x, uUNIT)\\n    }\\n}\\n\\n/// @notice Calculates the geometric mean of x and y, i.e. $\\\\sqrt{x * y}$, rounding down.\\n///\\n/// @dev Requirements:\\n/// - x * y must fit in UD60x18.\\n///\\n/// @param x The first operand as a UD60x18 number.\\n/// @param y The second operand as a UD60x18 number.\\n/// @return result The result as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction gm(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    uint256 xUint = x.unwrap();\\n    uint256 yUint = y.unwrap();\\n    if (xUint == 0 || yUint == 0) {\\n        return ZERO;\\n    }\\n\\n    unchecked {\\n        // Checking for overflow this way is faster than letting Solidity do it.\\n        uint256 xyUint = xUint * yUint;\\n        if (xyUint / xUint != yUint) {\\n            revert Errors.PRBMath_UD60x18_Gm_Overflow(x, y);\\n        }\\n\\n        // We don't need to multiply the result by `UNIT` here because the x*y product picked up a factor of `UNIT`\\n        // during multiplication. See the comments in {Common.sqrt}.\\n        result = wrap(Common.sqrt(xyUint));\\n    }\\n}\\n\\n/// @notice Calculates the inverse of x.\\n///\\n/// @dev Notes:\\n/// - The result is rounded toward zero.\\n///\\n/// Requirements:\\n/// - x must not be zero.\\n///\\n/// @param x The UD60x18 number for which to calculate the inverse.\\n/// @return result The inverse as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction inv(UD60x18 x) pure returns (UD60x18 result) {\\n    unchecked {\\n        result = wrap(uUNIT_SQUARED / x.unwrap());\\n    }\\n}\\n\\n/// @notice Calculates the natural logarithm of x using the following formula:\\n///\\n/// $$\\n/// ln{x} = log_2{x} / log_2{e}\\n/// $$\\n///\\n/// @dev Notes:\\n/// - Refer to the notes in {log2}.\\n/// - The precision isn't sufficiently fine-grained to return exactly `UNIT` when the input is `E`.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {log2}.\\n///\\n/// @param x The UD60x18 number for which to calculate the natural logarithm.\\n/// @return result The natural logarithm as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction ln(UD60x18 x) pure returns (UD60x18 result) {\\n    unchecked {\\n        // Inline the fixed-point multiplication to save gas. This is overflow-safe because the maximum value that\\n        // {log2} can return is ~196_205294292027477728.\\n        result = wrap(log2(x).unwrap() * uUNIT / uLOG2_E);\\n    }\\n}\\n\\n/// @notice Calculates the common logarithm of x using the following formula:\\n///\\n/// $$\\n/// log_{10}{x} = log_2{x} / log_2{10}\\n/// $$\\n///\\n/// However, if x is an exact power of ten, a hard coded value is returned.\\n///\\n/// @dev Notes:\\n/// - Refer to the notes in {log2}.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {log2}.\\n///\\n/// @param x The UD60x18 number for which to calculate the common logarithm.\\n/// @return result The common logarithm as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction log10(UD60x18 x) pure returns (UD60x18 result) {\\n    uint256 xUint = x.unwrap();\\n    if (xUint < uUNIT) {\\n        revert Errors.PRBMath_UD60x18_Log_InputTooSmall(x);\\n    }\\n\\n    // Note that the `mul` in this assembly block is the standard multiplication operation, not {UD60x18.mul}.\\n    // prettier-ignore\\n    assembly (\\\"memory-safe\\\") {\\n        switch x\\n        case 1 { result := mul(uUNIT, sub(0, 18)) }\\n        case 10 { result := mul(uUNIT, sub(1, 18)) }\\n        case 100 { result := mul(uUNIT, sub(2, 18)) }\\n        case 1000 { result := mul(uUNIT, sub(3, 18)) }\\n        case 10000 { result := mul(uUNIT, sub(4, 18)) }\\n        case 100000 { result := mul(uUNIT, sub(5, 18)) }\\n        case 1000000 { result := mul(uUNIT, sub(6, 18)) }\\n        case 10000000 { result := mul(uUNIT, sub(7, 18)) }\\n        case 100000000 { result := mul(uUNIT, sub(8, 18)) }\\n        case 1000000000 { result := mul(uUNIT, sub(9, 18)) }\\n        case 10000000000 { result := mul(uUNIT, sub(10, 18)) }\\n        case 100000000000 { result := mul(uUNIT, sub(11, 18)) }\\n        case 1000000000000 { result := mul(uUNIT, sub(12, 18)) }\\n        case 10000000000000 { result := mul(uUNIT, sub(13, 18)) }\\n        case 100000000000000 { result := mul(uUNIT, sub(14, 18)) }\\n        case 1000000000000000 { result := mul(uUNIT, sub(15, 18)) }\\n        case 10000000000000000 { result := mul(uUNIT, sub(16, 18)) }\\n        case 100000000000000000 { result := mul(uUNIT, sub(17, 18)) }\\n        case 1000000000000000000 { result := 0 }\\n        case 10000000000000000000 { result := uUNIT }\\n        case 100000000000000000000 { result := mul(uUNIT, 2) }\\n        case 1000000000000000000000 { result := mul(uUNIT, 3) }\\n        case 10000000000000000000000 { result := mul(uUNIT, 4) }\\n        case 100000000000000000000000 { result := mul(uUNIT, 5) }\\n        case 1000000000000000000000000 { result := mul(uUNIT, 6) }\\n        case 10000000000000000000000000 { result := mul(uUNIT, 7) }\\n        case 100000000000000000000000000 { result := mul(uUNIT, 8) }\\n        case 1000000000000000000000000000 { result := mul(uUNIT, 9) }\\n        case 10000000000000000000000000000 { result := mul(uUNIT, 10) }\\n        case 100000000000000000000000000000 { result := mul(uUNIT, 11) }\\n        case 1000000000000000000000000000000 { result := mul(uUNIT, 12) }\\n        case 10000000000000000000000000000000 { result := mul(uUNIT, 13) }\\n        case 100000000000000000000000000000000 { result := mul(uUNIT, 14) }\\n        case 1000000000000000000000000000000000 { result := mul(uUNIT, 15) }\\n        case 10000000000000000000000000000000000 { result := mul(uUNIT, 16) }\\n        case 100000000000000000000000000000000000 { result := mul(uUNIT, 17) }\\n        case 1000000000000000000000000000000000000 { result := mul(uUNIT, 18) }\\n        case 10000000000000000000000000000000000000 { result := mul(uUNIT, 19) }\\n        case 100000000000000000000000000000000000000 { result := mul(uUNIT, 20) }\\n        case 1000000000000000000000000000000000000000 { result := mul(uUNIT, 21) }\\n        case 10000000000000000000000000000000000000000 { result := mul(uUNIT, 22) }\\n        case 100000000000000000000000000000000000000000 { result := mul(uUNIT, 23) }\\n        case 1000000000000000000000000000000000000000000 { result := mul(uUNIT, 24) }\\n        case 10000000000000000000000000000000000000000000 { result := mul(uUNIT, 25) }\\n        case 100000000000000000000000000000000000000000000 { result := mul(uUNIT, 26) }\\n        case 1000000000000000000000000000000000000000000000 { result := mul(uUNIT, 27) }\\n        case 10000000000000000000000000000000000000000000000 { result := mul(uUNIT, 28) }\\n        case 100000000000000000000000000000000000000000000000 { result := mul(uUNIT, 29) }\\n        case 1000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 30) }\\n        case 10000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 31) }\\n        case 100000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 32) }\\n        case 1000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 33) }\\n        case 10000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 34) }\\n        case 100000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 35) }\\n        case 1000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 36) }\\n        case 10000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 37) }\\n        case 100000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 38) }\\n        case 1000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 39) }\\n        case 10000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 40) }\\n        case 100000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 41) }\\n        case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 42) }\\n        case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 43) }\\n        case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 44) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 45) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 46) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 47) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 48) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 49) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 50) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 51) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 52) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 53) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 54) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 55) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 56) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 57) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 58) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 59) }\\n        default { result := uMAX_UD60x18 }\\n    }\\n\\n    if (result.unwrap() == uMAX_UD60x18) {\\n        unchecked {\\n            // Inline the fixed-point division to save gas.\\n            result = wrap(log2(x).unwrap() * uUNIT / uLOG2_10);\\n        }\\n    }\\n}\\n\\n/// @notice Calculates the binary logarithm of x using the iterative approximation algorithm:\\n///\\n/// $$\\n/// log_2{x} = n + log_2{y}, \\\\text{ where } y = x*2^{-n}, \\\\ y \\\\in [1, 2)\\n/// $$\\n///\\n/// For $0 \\\\leq x \\\\lt 1$, the input is inverted:\\n///\\n/// $$\\n/// log_2{x} = -log_2{\\\\frac{1}{x}}\\n/// $$\\n///\\n/// @dev See https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n///\\n/// Notes:\\n/// - Due to the lossy precision of the iterative approximation, the results are not perfectly accurate to the last decimal.\\n///\\n/// Requirements:\\n/// - x must be greater than zero.\\n///\\n/// @param x The UD60x18 number for which to calculate the binary logarithm.\\n/// @return result The binary logarithm as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction log2(UD60x18 x) pure returns (UD60x18 result) {\\n    uint256 xUint = x.unwrap();\\n\\n    if (xUint < uUNIT) {\\n        revert Errors.PRBMath_UD60x18_Log_InputTooSmall(x);\\n    }\\n\\n    unchecked {\\n        // Calculate the integer part of the logarithm.\\n        uint256 n = Common.msb(xUint / uUNIT);\\n\\n        // This is the integer part of the logarithm as a UD60x18 number. The operation can't overflow because n\\n        // n is at most 255 and UNIT is 1e18.\\n        uint256 resultUint = n * uUNIT;\\n\\n        // Calculate $y = x * 2^{-n}$.\\n        uint256 y = xUint >> n;\\n\\n        // If y is the unit number, the fractional part is zero.\\n        if (y == uUNIT) {\\n            return wrap(resultUint);\\n        }\\n\\n        // Calculate the fractional part via the iterative approximation.\\n        // The `delta >>= 1` part is equivalent to `delta /= 2`, but shifting bits is more gas efficient.\\n        uint256 DOUBLE_UNIT = 2e18;\\n        for (uint256 delta = uHALF_UNIT; delta > 0; delta >>= 1) {\\n            y = (y * y) / uUNIT;\\n\\n            // Is y^2 >= 2e18 and so in the range [2e18, 4e18)?\\n            if (y >= DOUBLE_UNIT) {\\n                // Add the 2^{-m} factor to the logarithm.\\n                resultUint += delta;\\n\\n                // Halve y, which corresponds to z/2 in the Wikipedia article.\\n                y >>= 1;\\n            }\\n        }\\n        result = wrap(resultUint);\\n    }\\n}\\n\\n/// @notice Multiplies two UD60x18 numbers together, returning a new UD60x18 number.\\n///\\n/// @dev Uses {Common.mulDiv} to enable overflow-safe multiplication and division.\\n///\\n/// Notes:\\n/// - Refer to the notes in {Common.mulDiv}.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {Common.mulDiv}.\\n///\\n/// @dev See the documentation in {Common.mulDiv18}.\\n/// @param x The multiplicand as a UD60x18 number.\\n/// @param y The multiplier as a UD60x18 number.\\n/// @return result The product as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction mul(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    result = wrap(Common.mulDiv18(x.unwrap(), y.unwrap()));\\n}\\n\\n/// @notice Raises x to the power of y.\\n///\\n/// For $1 \\\\leq x \\\\leq \\\\infty$, the following standard formula is used:\\n///\\n/// $$\\n/// x^y = 2^{log_2{x} * y}\\n/// $$\\n///\\n/// For $0 \\\\leq x \\\\lt 1$, since the unsigned {log2} is undefined, an equivalent formula is used:\\n///\\n/// $$\\n/// i = \\\\frac{1}{x}\\n/// w = 2^{log_2{i} * y}\\n/// x^y = \\\\frac{1}{w}\\n/// $$\\n///\\n/// @dev Notes:\\n/// - Refer to the notes in {log2} and {mul}.\\n/// - Returns `UNIT` for 0^0.\\n/// - It may not perform well with very small values of x. Consider using SD59x18 as an alternative.\\n///\\n/// Requirements:\\n/// - Refer to the requirements in {exp2}, {log2}, and {mul}.\\n///\\n/// @param x The base as a UD60x18 number.\\n/// @param y The exponent as a UD60x18 number.\\n/// @return result The result as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction pow(UD60x18 x, UD60x18 y) pure returns (UD60x18 result) {\\n    uint256 xUint = x.unwrap();\\n    uint256 yUint = y.unwrap();\\n\\n    // If both x and y are zero, the result is `UNIT`. If just x is zero, the result is always zero.\\n    if (xUint == 0) {\\n        return yUint == 0 ? UNIT : ZERO;\\n    }\\n    // If x is `UNIT`, the result is always `UNIT`.\\n    else if (xUint == uUNIT) {\\n        return UNIT;\\n    }\\n\\n    // If y is zero, the result is always `UNIT`.\\n    if (yUint == 0) {\\n        return UNIT;\\n    }\\n    // If y is `UNIT`, the result is always x.\\n    else if (yUint == uUNIT) {\\n        return x;\\n    }\\n\\n    // If x is greater than `UNIT`, use the standard formula.\\n    if (xUint > uUNIT) {\\n        result = exp2(mul(log2(x), y));\\n    }\\n    // Conversely, if x is less than `UNIT`, use the equivalent formula.\\n    else {\\n        UD60x18 i = wrap(uUNIT_SQUARED / xUint);\\n        UD60x18 w = exp2(mul(log2(i), y));\\n        result = wrap(uUNIT_SQUARED / w.unwrap());\\n    }\\n}\\n\\n/// @notice Raises x (a UD60x18 number) to the power y (an unsigned basic integer) using the well-known\\n/// algorithm \\\"exponentiation by squaring\\\".\\n///\\n/// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring.\\n///\\n/// Notes:\\n/// - Refer to the notes in {Common.mulDiv18}.\\n/// - Returns `UNIT` for 0^0.\\n///\\n/// Requirements:\\n/// - The result must fit in UD60x18.\\n///\\n/// @param x The base as a UD60x18 number.\\n/// @param y The exponent as a uint256.\\n/// @return result The result as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction powu(UD60x18 x, uint256 y) pure returns (UD60x18 result) {\\n    // Calculate the first iteration of the loop in advance.\\n    uint256 xUint = x.unwrap();\\n    uint256 resultUint = y & 1 > 0 ? xUint : uUNIT;\\n\\n    // Equivalent to `for(y /= 2; y > 0; y /= 2)`.\\n    for (y >>= 1; y > 0; y >>= 1) {\\n        xUint = Common.mulDiv18(xUint, xUint);\\n\\n        // Equivalent to `y % 2 == 1`.\\n        if (y & 1 > 0) {\\n            resultUint = Common.mulDiv18(resultUint, xUint);\\n        }\\n    }\\n    result = wrap(resultUint);\\n}\\n\\n/// @notice Calculates the square root of x using the Babylonian method.\\n///\\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n///\\n/// Notes:\\n/// - The result is rounded toward zero.\\n///\\n/// Requirements:\\n/// - x must be less than `MAX_UD60x18 / UNIT`.\\n///\\n/// @param x The UD60x18 number for which to calculate the square root.\\n/// @return result The result as a UD60x18 number.\\n/// @custom:smtchecker abstract-function-nondet\\nfunction sqrt(UD60x18 x) pure returns (UD60x18 result) {\\n    uint256 xUint = x.unwrap();\\n\\n    unchecked {\\n        if (xUint > uMAX_UD60x18 / uUNIT) {\\n            revert Errors.PRBMath_UD60x18_Sqrt_Overflow(x);\\n        }\\n        // Multiply x by `UNIT` to account for the factor of `UNIT` picked up when multiplying two UD60x18 numbers.\\n        // In this case, the two numbers are both the square root.\\n        result = wrap(Common.sqrt(xUint * uUNIT));\\n    }\\n}\\n\",\"keccak256\":\"0x462144667aac3f96d5f8dba7aa68fe4c5a3f61e1d7bbbc81bee21168817f9c09\",\"license\":\"MIT\"},\"@prb/math/ud60x18/ValueType.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.19;\\n\\nimport \\\"./Casting.sol\\\" as Casting;\\nimport \\\"./Helpers.sol\\\" as Helpers;\\nimport \\\"./Math.sol\\\" as Math;\\n\\n/// @notice The unsigned 60.18-decimal fixed-point number representation, which can have up to 60 digits and up to 18\\n/// decimals. The values of this are bound by the minimum and the maximum values permitted by the Solidity type uint256.\\n/// @dev The value type is defined here so it can be imported in all other files.\\ntype UD60x18 is uint256;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    CASTING\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nusing {\\n    Casting.intoSD1x18,\\n    Casting.intoUD2x18,\\n    Casting.intoSD59x18,\\n    Casting.intoUint128,\\n    Casting.intoUint256,\\n    Casting.intoUint40,\\n    Casting.unwrap\\n} for UD60x18 global;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                            MATHEMATICAL FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n// The global \\\"using for\\\" directive makes the functions in this library callable on the UD60x18 type.\\nusing {\\n    Math.avg,\\n    Math.ceil,\\n    Math.div,\\n    Math.exp,\\n    Math.exp2,\\n    Math.floor,\\n    Math.frac,\\n    Math.gm,\\n    Math.inv,\\n    Math.ln,\\n    Math.log10,\\n    Math.log2,\\n    Math.mul,\\n    Math.pow,\\n    Math.powu,\\n    Math.sqrt\\n} for UD60x18 global;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                HELPER FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n// The global \\\"using for\\\" directive makes the functions in this library callable on the UD60x18 type.\\nusing {\\n    Helpers.add,\\n    Helpers.and,\\n    Helpers.eq,\\n    Helpers.gt,\\n    Helpers.gte,\\n    Helpers.isZero,\\n    Helpers.lshift,\\n    Helpers.lt,\\n    Helpers.lte,\\n    Helpers.mod,\\n    Helpers.neq,\\n    Helpers.not,\\n    Helpers.or,\\n    Helpers.rshift,\\n    Helpers.sub,\\n    Helpers.uncheckedAdd,\\n    Helpers.uncheckedSub,\\n    Helpers.xor\\n} for UD60x18 global;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    OPERATORS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n// The global \\\"using for\\\" directive makes it possible to use these operators on the UD60x18 type.\\nusing {\\n    Helpers.add as +,\\n    Helpers.and2 as &,\\n    Math.div as /,\\n    Helpers.eq as ==,\\n    Helpers.gt as >,\\n    Helpers.gte as >=,\\n    Helpers.lt as <,\\n    Helpers.lte as <=,\\n    Helpers.or as |,\\n    Helpers.mod as %,\\n    Math.mul as *,\\n    Helpers.neq as !=,\\n    Helpers.not as ~,\\n    Helpers.sub as -,\\n    Helpers.xor as ^\\n} for UD60x18 global;\\n\",\"keccak256\":\"0xdd873b5124180d9b71498b3a7fe93b1c08c368bec741f7d5f8e17f78a0b70f31\",\"license\":\"MIT\"},\"account-abstraction/interfaces/PackedUserOperation.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity >=0.7.5;\\n\\n/**\\n * User Operation struct\\n * @param sender                - The sender account of this request.\\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\\n * @param initCode              - If set, the account contract will be created by this constructor/\\n * @param callData              - The method call to execute on this account.\\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\\n *                                Covers batch overhead.\\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\\n *                                The paymaster will pay for the transaction instead of the sender.\\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n */\\nstruct PackedUserOperation {\\n    address sender;\\n    uint256 nonce;\\n    bytes initCode;\\n    bytes callData;\\n    bytes32 accountGasLimits;\\n    uint256 preVerificationGas;\\n    bytes32 gasFees;\\n    bytes paymasterAndData;\\n    bytes signature;\\n}\\n\",\"keccak256\":\"0x1129b46381db68eddbc5cb49e50664667b66b03c480453858e7b25eabe444359\",\"license\":\"GPL-3.0\"},\"contracts/AutoDCA/AutoDCAModule.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.25;\\n\\nimport {\\n    ERC20Integration, ERC4626Integration, UniswapV3Integration\\n} from \\\"modulekit/Integrations.sol\\\";\\nimport { IERC20 } from \\\"forge-std/interfaces/IERC20.sol\\\";\\nimport { IERC4626 } from \\\"forge-std/interfaces/IERC4626.sol\\\";\\nimport { Execution } from \\\"modulekit/Accounts.sol\\\";\\nimport { ERC7579ExecutorBase } from \\\"../module-bases/ERC7579ExecutorBase.sol\\\";\\nimport { SentinelListLib, SENTINEL } from \\\"sentinellist/SentinelList.sol\\\";\\nimport { UD2x18 } from \\\"@prb/math/UD2x18.sol\\\";\\nimport { ud } from \\\"@prb/math/UD60x18.sol\\\";\\n\\n/**\\n * @title AutoDCAModule\\n * @dev Module that allows users to automatically save a percentage of their received tokens to a\\n * vault\\n */\\ncontract AutoDCAModule is ERC7579ExecutorBase {\\n    using SentinelListLib for SentinelListLib.SentinelList;\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                            CONSTANTS & STORAGE\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    error TooManyTokens();\\n    error InvalidSqrtPriceLimitX96();\\n\\n    uint256 internal constant MAX_TOKENS = 100;\\n\\n    struct Config {\\n        UD2x18 percentage; // percentage to be saved to the vault\\n        address vault; // address of the vault\\n        uint128 sqrtPriceLimitX96; // sqrtPriceLimitX96 for UniswapV3 swap\\n    }\\n\\n    struct ConfigWithToken {\\n        address token; // address of the token\\n        UD2x18 percentage; // percentage to be saved to the vault\\n        address vault; // address of the vault\\n        uint128 sqrtPriceLimitX96; // sqrtPriceLimitX96 for UniswapV3 swap\\n    }\\n\\n    // account => token => Config\\n    mapping(address account => mapping(address token => Config)) public config;\\n\\n    // account => tokens\\n    mapping(address account => SentinelListLib.SentinelList) tokens;\\n\\n    event ModuleInitialized(address indexed account);\\n    event ModuleUninitialized(address indexed account);\\n    event ConfigSet(address indexed account, address indexed token);\\n    event AutoSaveExecuted(address indexed smartAccount, address indexed token, uint256 amountIn);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                     CONFIG\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * Initializes the module with the tokens and their configurations\\n     * @dev data is encoded as follows: abi.encode([tokens], [configs])\\n     * @dev if there are more tokens than configs, the function will revert\\n     * @dev if there are more configs than tokens, the function will ignore the extra configs\\n     *\\n     * @param data encoded data containing the tokens and their configurations\\n     */\\n    function onInstall(bytes calldata data) external override {\\n        // cache the account address\\n        address account = msg.sender;\\n\\n        // decode the data to get the tokens and their configurations\\n        (ConfigWithToken[] memory _configs) = abi.decode(data, (ConfigWithToken[]));\\n\\n        // initialize the sentinel list\\n        tokens[account].init();\\n\\n        // get the length of the tokens\\n        uint256 length = _configs.length;\\n\\n        // check that the length of tokens is less than max\\n        if (length > MAX_TOKENS) revert TooManyTokens();\\n\\n        // loop through the tokens, add them to the list and set their configurations\\n        for (uint256 i; i < length; i++) {\\n            address _token = _configs[i].token;\\n            Config memory _config = Config({\\n                percentage: _configs[i].percentage,\\n                vault: _configs[i].vault,\\n                sqrtPriceLimitX96: _configs[i].sqrtPriceLimitX96\\n            });\\n\\n            // check that sqrtPriceLimitX96 > 0\\n            // sqrtPriceLimitX96 = 0 means unlimitted slippage\\n            if (_config.sqrtPriceLimitX96 == 0) {\\n                revert InvalidSqrtPriceLimitX96();\\n            }\\n\\n            config[account][_token] = _config;\\n            tokens[account].push(_token);\\n        }\\n\\n        emit ModuleInitialized(account);\\n    }\\n\\n    /**\\n     * Handles the uninstallation of the module and clears the tokens and configurations\\n     * @dev the data parameter is not used\\n     */\\n    function onUninstall(bytes calldata) external override {\\n        // cache the account address\\n        address account = msg.sender;\\n\\n        // clear the configurations\\n        (address[] memory tokensArray,) = tokens[account].getEntriesPaginated(SENTINEL, MAX_TOKENS);\\n        uint256 tokenLength = tokensArray.length;\\n        for (uint256 i; i < tokenLength; i++) {\\n            delete config[account][tokensArray[i]];\\n        }\\n\\n        // clear the tokens\\n        tokens[account].popAll();\\n\\n        emit ModuleUninitialized(account);\\n    }\\n\\n    /**\\n     * Checks if the module is initialized\\n     *\\n     * @param smartAccount address of the smart account\\n     * @return true if the module is initialized, false otherwise\\n     */\\n    function isInitialized(address smartAccount) public view returns (bool) {\\n        // check if the linked list is initialized for the smart account\\n        return tokens[smartAccount].alreadyInitialized();\\n    }\\n\\n    /**\\n     * Sets the configuration for a token\\n     * @dev the function will revert if the module is not initialized\\n     * @dev this function can be used to set a new configuration or update an existing one\\n     *\\n     * @param token address of the token\\n     * @param _config Config struct containing the configuration\\n     */\\n    function setConfig(address token, Config memory _config) public {\\n        // cache the account address\\n        address account = msg.sender;\\n        // check if the module is not initialized and revert if it is not\\n        if (!isInitialized(account)) revert NotInitialized(account);\\n\\n        // check that sqrtPriceLimitX96 > 0\\n        // sqrtPriceLimitX96 = 0 means unlimitted slippage\\n        if (_config.sqrtPriceLimitX96 == 0) {\\n            revert InvalidSqrtPriceLimitX96();\\n        }\\n\\n        // set the configuration for the token\\n        config[account][token] = _config;\\n\\n        // add the token to the list if it is not already there\\n        if (!tokens[account].contains(token)) {\\n            tokens[account].push(token);\\n        }\\n\\n        emit ConfigSet(account, token);\\n    }\\n\\n    /**\\n     * Deletes the configuration for a token\\n     * @dev the function will revert if the module is not initialized\\n     *\\n     * @param prevToken address of the token stored before the token to be deleted\\n     * @param token address of the token to be deleted\\n     */\\n    function deleteConfig(address prevToken, address token) public {\\n        // cache the account address\\n        address account = msg.sender;\\n\\n        // delete the configuration for the token\\n        delete config[account][token];\\n\\n        // remove the token from the list\\n        tokens[account].pop(prevToken, token);\\n\\n        emit ConfigSet(account, token);\\n    }\\n\\n    /**\\n     * Gets a list of all tokens\\n     * @dev the function will revert if the module is not initialized\\n     *\\n     * @param account address of the account\\n     */\\n    function getTokens(address account) external view returns (address[] memory tokensArray) {\\n        // return the tokens from the list\\n        (tokensArray,) = tokens[account].getEntriesPaginated(SENTINEL, MAX_TOKENS);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                     MODULE LOGIC\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * Calculates the amount to be saved to the vault\\n     *\\n     * @param amountReceived amount received by the user\\n     * @param percentage percentage to be saved to the vault\\n     *\\n     * @return amount to be saved to the vault\\n     */\\n    function calcDepositAmount(\\n        uint256 amountReceived,\\n        UD2x18 percentage\\n    )\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        // calculate the amount to be saved which is the\\n        // percentage of the amount received\\n        return ud(amountReceived).mul(percentage.intoUD60x18()).intoUint256();\\n    }\\n\\n    /**\\n     * Executes the auto save logic\\n     *\\n     * @param token address of the token received\\n     * @param amountReceived amount received by the user\\n     */\\n    function autoSave(address token, uint256 amountReceived) external {\\n        // cache the account address\\n        address account = msg.sender;\\n\\n        // get the configuration for the token\\n        Config memory conf = config[account][token];\\n        // get the vault\\n        IERC4626 vault = IERC4626(conf.vault);\\n\\n        // check if the config exists and revert if not\\n        if (address(vault) == address(0)) {\\n            revert NotInitialized(account);\\n        }\\n\\n        // calculate amount that is subject to be saved\\n        uint256 amountIn = calcDepositAmount(amountReceived, conf.percentage);\\n        IERC20 tokenToSave;\\n\\n        // get the underlying token of the vault\\n        address underlying = vault.asset();\\n\\n        // if token is not the underlying token, swap it\\n        if (token != underlying) {\\n            // create swap from received token to underlying token\\n            Execution[] memory swap = UniswapV3Integration.approveAndSwap({\\n                smartAccount: account,\\n                tokenIn: IERC20(token),\\n                tokenOut: IERC20(underlying),\\n                amountIn: amountIn,\\n                sqrtPriceLimitX96: conf.sqrtPriceLimitX96\\n            });\\n\\n            // execute swap on account\\n            bytes[] memory results = _execute(swap);\\n\\n            // get return data of swap, and set it as amountIn.\\n            // this will be the actual amount that is subject to be saved\\n            amountIn = abi.decode(results[2], (uint256));\\n\\n            // change tokenToSave to underlying\\n            tokenToSave = IERC20(underlying);\\n        } else {\\n            // set tokenToSave to token since no swap was needed\\n            tokenToSave = IERC20(token);\\n        }\\n\\n        // approve and deposit to vault\\n        // Execution[] memory approveAndDeposit = new Execution[](3);\\n        // (approveAndDeposit[0], approveAndDeposit[1]) =\\n        //     ERC20Integration.safeApprove(tokenToSave, address(vault), amountIn);\\n        // approveAndDeposit[2] = ERC4626Integration.deposit(vault, amountIn, account);\\n\\n        // execute deposit to vault on account\\n        // _execute(approveAndDeposit);\\n\\n        // emit event\\n        emit AutoSaveExecuted(account, token, amountIn);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                     METADATA\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * Returns the type of the module\\n     *\\n     * @param typeID type of the module\\n     *\\n     * @return true if the type is a module type, false otherwise\\n     */\\n    function isModuleType(uint256 typeID) external pure override returns (bool) {\\n        return typeID == TYPE_EXECUTOR;\\n    }\\n\\n    /**\\n     * Returns the name of the module\\n     *\\n     * @return name of the module\\n     */\\n    function name() external pure virtual returns (string memory) {\\n        return \\\"AutoDCAModule\\\";\\n    }\\n\\n    /**\\n     * Returns the version of the module\\n     *\\n     * @return version of the module\\n     */\\n    function version() external pure virtual returns (string memory) {\\n        return \\\"1.0.0\\\";\\n    }\\n}\\n\",\"keccak256\":\"0xcf5bea9808f8b6037fad692fef9e986579a0b189f2ffedabd7149329f5cf502f\",\"license\":\"AGPL-3.0-only\"},\"contracts/module-bases/ERC7579ExecutorBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport \\\"../safe7579/external/ERC7579.sol\\\";\\nimport { ERC7579ModuleBase } from \\\"./ERC7579ModuleBase.sol\\\";\\n\\nabstract contract ERC7579ExecutorBase is IERC7579Executor, ERC7579ModuleBase {\\n    function _execute(\\n        address account,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    )\\n        internal\\n        returns (bytes memory result)\\n    {\\n        ModeCode modeCode = ERC7579ModeLib.encode({\\n            callType: CALLTYPE_SINGLE,\\n            execType: EXECTYPE_DEFAULT,\\n            mode: MODE_DEFAULT,\\n            payload: ModePayload.wrap(bytes22(0))\\n        });\\n\\n        return IERC7579Account(account).executeFromExecutor(\\n            modeCode, ERC7579ExecutionLib.encodeSingle(to, value, data)\\n        )[0];\\n    }\\n\\n    function _execute(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    )\\n        internal\\n        returns (bytes memory result)\\n    {\\n        return _execute(msg.sender, to, value, data);\\n    }\\n\\n    function _execute(\\n        address account,\\n        Execution[] memory execs\\n    )\\n        internal\\n        returns (bytes[] memory results)\\n    {\\n        ModeCode modeCode = ERC7579ModeLib.encode({\\n            callType: CALLTYPE_BATCH,\\n            execType: EXECTYPE_DEFAULT,\\n            mode: MODE_DEFAULT,\\n            payload: ModePayload.wrap(bytes22(0))\\n        });\\n        results = IERC7579Account(account).executeFromExecutor(\\n            modeCode, ERC7579ExecutionLib.encodeBatch(execs)\\n        );\\n    }\\n\\n    function _execute(Execution[] memory execs) internal returns (bytes[] memory results) {\\n        return _execute(msg.sender, execs);\\n    }\\n\\n    // Note: Not every account will support delegatecalls\\n    function _executeDelegateCall(\\n        address account,\\n        address delegateTarget,\\n        bytes memory callData\\n    )\\n        internal\\n        returns (bytes[] memory results)\\n    {\\n        ModeCode modeCode = ERC7579ModeLib.encode({\\n            callType: CALLTYPE_DELEGATECALL,\\n            execType: EXECTYPE_DEFAULT,\\n            mode: MODE_DEFAULT,\\n            payload: ModePayload.wrap(bytes22(0))\\n        });\\n        results = IERC7579Account(account).executeFromExecutor(\\n            modeCode, abi.encodePacked(delegateTarget, callData)\\n        );\\n    }\\n\\n    // Note: Not every account will support delegatecalls\\n    function _executeDelegateCall(\\n        address delegateTarget,\\n        bytes memory callData\\n    )\\n        internal\\n        returns (bytes[] memory results)\\n    {\\n        return _executeDelegateCall(msg.sender, delegateTarget, callData);\\n    }\\n}\",\"keccak256\":\"0xa4729b5793bfae51db97ecd2706ce1cb652cd0ff43fd9ba1fe6793438b1301f2\",\"license\":\"MIT\"},\"contracts/module-bases/ERC7579ModuleBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { IERC7579Module } from \\\"../safe7579/external/ERC7579.sol\\\";\\n\\nabstract contract ERC7579ModuleBase is IERC7579Module {\\n    uint256 constant TYPE_VALIDATOR = 1;\\n    uint256 constant TYPE_EXECUTOR = 2;\\n    uint256 constant TYPE_FALLBACK = 3;\\n    uint256 constant TYPE_HOOK = 4;\\n}\",\"keccak256\":\"0x44e42a9254211dc12fc684d8d3a18363368244007ac4348f24e270376521cf9c\",\"license\":\"MIT\"},\"contracts/safe7579/external/ERC7579.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable no-unused-import */\\nimport { MSAFactory as ERC7579AccountFactory } from \\\"erc7579/MSAFactory.sol\\\";\\nimport { MSAAdvanced as ERC7579Account } from \\\"erc7579/MSAAdvanced.sol\\\";\\nimport { Execution, IERC7579Account } from \\\"erc7579/interfaces/IERC7579Account.sol\\\";\\nimport {\\n    IModule as IERC7579Module,\\n    IValidator as IERC7579Validator,\\n    IExecutor as IERC7579Executor,\\n    IHook as IERC7579Hook,\\n    IFallback as IERC7579Fallback,\\n    MODULE_TYPE_VALIDATOR,\\n    MODULE_TYPE_EXECUTOR,\\n    MODULE_TYPE_HOOK,\\n    MODULE_TYPE_FALLBACK\\n} from \\\"erc7579/interfaces/IERC7579Module.sol\\\";\\n\\nimport {\\n    ModeLib as ERC7579ModeLib,\\n    ModeCode,\\n    CallType,\\n    ExecType,\\n    ModePayload,\\n    CALLTYPE_SINGLE,\\n    CALLTYPE_BATCH,\\n    CALLTYPE_DELEGATECALL,\\n    EXECTYPE_DEFAULT,\\n    MODE_DEFAULT\\n} from \\\"erc7579/lib/ModeLib.sol\\\";\\nimport { Execution, ExecutionLib as ERC7579ExecutionLib } from \\\"erc7579/lib/ExecutionLib.sol\\\";\\n\\nimport {\\n    Bootstrap as ERC7579Bootstrap,\\n    BootstrapConfig as ERC7579BootstrapConfig\\n} from \\\"erc7579/utils/Bootstrap.sol\\\";\\n/* solhint-enable no-unused-import */\",\"keccak256\":\"0x1b7b6abd1abcb25b27f79008941523c83f0965817c0d9384419c2423acc1fac0\",\"license\":\"MIT\"},\"erc7579/MSAAdvanced.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport \\\"./lib/ModeLib.sol\\\";\\nimport { ExecutionLib } from \\\"./lib/ExecutionLib.sol\\\";\\nimport { ExecutionHelper } from \\\"./core/ExecutionHelper.sol\\\";\\nimport { PackedUserOperation } from \\\"account-abstraction/interfaces/PackedUserOperation.sol\\\";\\nimport \\\"./interfaces/IERC7579Module.sol\\\";\\nimport { IERC7579Account } from \\\"./interfaces/IERC7579Account.sol\\\";\\nimport { IMSA } from \\\"./interfaces/IMSA.sol\\\";\\nimport { ModuleManager } from \\\"./core/ModuleManager.sol\\\";\\nimport { HookManager } from \\\"./core/HookManager.sol\\\";\\n\\n/**\\n * @author zeroknots.eth | rhinestone.wtf\\n * Reference implementation of a very simple ERC7579 Account.\\n * This account implements CallType: SINGLE, BATCH and DELEGATECALL.\\n * This account implements ExecType: DEFAULT and TRY.\\n * Hook support is implemented\\n */\\ncontract MSAAdvanced is IMSA, ExecutionHelper, ModuleManager, HookManager {\\n    using ExecutionLib for bytes;\\n    using ModeLib for ModeCode;\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     * @dev this function is only callable by the entry point or the account itself\\n     * @dev this function demonstrates how to implement\\n     * CallType SINGLE and BATCH and ExecType DEFAULT and TRY\\n     * @dev this function demonstrates how to implement hook support (modifier)\\n     */\\n    function execute(\\n        ModeCode mode,\\n        bytes calldata executionCalldata\\n    )\\n        external\\n        payable\\n        onlyEntryPointOrSelf\\n        withHook\\n    {\\n        (CallType callType, ExecType execType,,) = mode.decode();\\n\\n        // check if calltype is batch or single\\n        if (callType == CALLTYPE_BATCH) {\\n            // destructure executionCallData according to batched exec\\n            Execution[] calldata executions = executionCalldata.decodeBatch();\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) _execute(executions);\\n            else if (execType == EXECTYPE_TRY) _tryExecute(executions);\\n            else revert UnsupportedExecType(execType);\\n        } else if (callType == CALLTYPE_SINGLE) {\\n            // destructure executionCallData according to single exec\\n            (address target, uint256 value, bytes calldata callData) =\\n                executionCalldata.decodeSingle();\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) _execute(target, value, callData);\\n            // TODO: implement event emission for tryExecute singleCall\\n            else if (execType == EXECTYPE_TRY) _tryExecute(target, value, callData);\\n            else revert UnsupportedExecType(execType);\\n        } else if (callType == CALLTYPE_DELEGATECALL) {\\n            // destructure executionCallData according to single exec\\n            address delegate = address(uint160(bytes20(executionCalldata[0:20])));\\n            bytes calldata callData = executionCalldata[20:];\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) _executeDelegatecall(delegate, callData);\\n            else if (execType == EXECTYPE_TRY) _tryExecuteDelegatecall(delegate, callData);\\n            else revert UnsupportedExecType(execType);\\n        } else {\\n            revert UnsupportedCallType(callType);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     * @dev this function is only callable by an installed executor module\\n     * @dev this function demonstrates how to implement\\n     * CallType SINGLE and BATCH and ExecType DEFAULT and TRY\\n     * @dev this function demonstrates how to implement hook support (modifier)\\n     */\\n    function executeFromExecutor(\\n        ModeCode mode,\\n        bytes calldata executionCalldata\\n    )\\n        external\\n        payable\\n        onlyExecutorModule\\n        withHook\\n        returns (\\n            bytes[] memory returnData // TODO returnData is not used\\n        )\\n    {\\n        (CallType callType, ExecType execType,,) = mode.decode();\\n\\n        // check if calltype is batch or single\\n        if (callType == CALLTYPE_BATCH) {\\n            // destructure executionCallData according to batched exec\\n            Execution[] calldata executions = executionCalldata.decodeBatch();\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) returnData = _execute(executions);\\n            else if (execType == EXECTYPE_TRY) returnData = _tryExecute(executions);\\n            else revert UnsupportedExecType(execType);\\n        } else if (callType == CALLTYPE_SINGLE) {\\n            // destructure executionCallData according to single exec\\n            (address target, uint256 value, bytes calldata callData) =\\n                executionCalldata.decodeSingle();\\n            returnData = new bytes[](1);\\n            bool success;\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) {\\n                returnData[0] = _execute(target, value, callData);\\n            }\\n            // TODO: implement event emission for tryExecute singleCall\\n            else if (execType == EXECTYPE_TRY) {\\n                (success, returnData[0]) = _tryExecute(target, value, callData);\\n                if (!success) emit TryExecuteUnsuccessful(0, returnData[0]);\\n            } else {\\n                revert UnsupportedExecType(execType);\\n            }\\n        } else if (callType == CALLTYPE_DELEGATECALL) {\\n            // destructure executionCallData according to single exec\\n            address delegate = address(uint160(bytes20(executionCalldata[0:20])));\\n            bytes calldata callData = executionCalldata[20:];\\n            // check if execType is revert or try\\n            if (execType == EXECTYPE_DEFAULT) _executeDelegatecall(delegate, callData);\\n            else if (execType == EXECTYPE_TRY) _tryExecuteDelegatecall(delegate, callData);\\n            else revert UnsupportedExecType(execType);\\n        } else {\\n            revert UnsupportedCallType(callType);\\n        }\\n    }\\n\\n    /**\\n     * @dev ERC-4337 executeUserOp according to ERC-4337 v0.7\\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\\n     *      The implementation of the function is OPTIONAL\\n     *\\n     * @param userOp PackedUserOperation struct (see ERC-4337 v0.7+)\\n     */\\n    function executeUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash\\n    )\\n        external\\n        payable\\n        onlyEntryPoint\\n    {\\n        bytes calldata callData = userOp.callData[4:];\\n        (bool success,) = address(this).delegatecall(callData);\\n        if (!success) revert ExecutionFailed();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function installModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata initData\\n    )\\n        external\\n        payable\\n        onlyEntryPointOrSelf\\n        withHook\\n    {\\n        if (!IModule(module).isModuleType(moduleTypeId)) revert MismatchModuleTypeId(moduleTypeId);\\n\\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) _installValidator(module, initData);\\n        else if (moduleTypeId == MODULE_TYPE_EXECUTOR) _installExecutor(module, initData);\\n        else if (moduleTypeId == MODULE_TYPE_FALLBACK) _installFallbackHandler(module, initData);\\n        else if (moduleTypeId == MODULE_TYPE_HOOK) _installHook(module, initData);\\n        else revert UnsupportedModuleType(moduleTypeId);\\n        emit ModuleInstalled(moduleTypeId, module);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function uninstallModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata deInitData\\n    )\\n        external\\n        payable\\n        onlyEntryPointOrSelf\\n        withHook\\n    {\\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\\n            _uninstallValidator(module, deInitData);\\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\\n            _uninstallExecutor(module, deInitData);\\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\\n            _uninstallFallbackHandler(module, deInitData);\\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\\n            _uninstallHook(module, deInitData);\\n        } else {\\n            revert UnsupportedModuleType(moduleTypeId);\\n        }\\n        emit ModuleUninstalled(moduleTypeId, module);\\n    }\\n\\n    /**\\n     * @dev ERC-4337 validateUserOp according to ERC-4337 v0.7\\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\\n     * this validation function should decode / sload the validator module to validate the userOp\\n     * and call it.\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * @param userOp PackedUserOperation struct (see ERC-4337 v0.7+)\\n     */\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 missingAccountFunds\\n    )\\n        external\\n        payable\\n        virtual\\n        onlyEntryPoint\\n        payPrefund(missingAccountFunds)\\n        returns (uint256 validSignature)\\n    {\\n        address validator;\\n        // @notice validator encoding in nonce is just an example!\\n        // @notice this is not part of the standard!\\n        // Account Vendors may choose any other way to implement validator selection\\n        uint256 nonce = userOp.nonce;\\n        assembly {\\n            validator := shr(96, nonce)\\n        }\\n\\n        // check if validator is enabled. If not terminate the validation phase.\\n        if (!_isValidatorInstalled(validator)) return VALIDATION_FAILED;\\n\\n        // bubble up the return value of the validator module\\n        validSignature = IValidator(validator).validateUserOp(userOp, userOpHash);\\n    }\\n\\n    /**\\n     * @dev ERC-1271 isValidSignature\\n     *         This function is intended to be used to validate a smart account signature\\n     * and may forward the call to a validator module\\n     *\\n     * @param hash The hash of the data that is signed\\n     * @param data The data that is signed\\n     */\\n    function isValidSignature(\\n        bytes32 hash,\\n        bytes calldata data\\n    )\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bytes4)\\n    {\\n        address validator = address(bytes20(data[0:20]));\\n        if (!_isValidatorInstalled(validator)) revert InvalidModule(validator);\\n        return IValidator(validator).isValidSignatureWithSender(msg.sender, hash, data[20:]);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function isModuleInstalled(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata additionalContext\\n    )\\n        external\\n        view\\n        override\\n        returns (bool)\\n    {\\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\\n            return _isValidatorInstalled(module);\\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\\n            return _isExecutorInstalled(module);\\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\\n            return _isFallbackHandlerInstalled(abi.decode(additionalContext, (bytes4)), module);\\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\\n            return _isHookInstalled(module);\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function accountId() external view virtual override returns (string memory) {\\n        // vendor.flavour.SemVer\\n        return \\\"uMSA.advanced/withHook.v0.1\\\";\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function supportsExecutionMode(ModeCode mode)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bool isSupported)\\n    {\\n        (CallType callType, ExecType execType,,) = mode.decode();\\n        if (callType == CALLTYPE_BATCH) isSupported = true;\\n        else if (callType == CALLTYPE_SINGLE) isSupported = true;\\n        else if (callType == CALLTYPE_DELEGATECALL) isSupported = true;\\n        // if callType is not single, batch or delegatecall return false\\n        else return false;\\n\\n        if (execType == EXECTYPE_DEFAULT) isSupported = true;\\n        else if (execType == EXECTYPE_TRY) isSupported = true;\\n        // if execType is not default or try, return false\\n        else return false;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC7579Account\\n     */\\n    function supportsModule(uint256 modulTypeId) external view virtual override returns (bool) {\\n        if (modulTypeId == MODULE_TYPE_VALIDATOR) return true;\\n        else if (modulTypeId == MODULE_TYPE_EXECUTOR) return true;\\n        else if (modulTypeId == MODULE_TYPE_FALLBACK) return true;\\n        else if (modulTypeId == MODULE_TYPE_HOOK) return true;\\n        else return false;\\n    }\\n\\n    /**\\n     * @dev Initializes the account. Function might be called directly, or by a Factory\\n     * @param data. encoded data that can be used during the initialization phase\\n     */\\n    function initializeAccount(bytes calldata data) public payable virtual {\\n        // checks if already initialized and reverts before setting the state to initialized\\n        _initModuleManager();\\n\\n        // this is just implemented for demonstration purposes. You can use any other initialization\\n        // logic here.\\n        (address bootstrap, bytes memory bootstrapCall) = abi.decode(data, (address, bytes));\\n        (bool success,) = bootstrap.delegatecall(bootstrapCall);\\n        if (!success) revert();\\n    }\\n}\\n\",\"keccak256\":\"0x4e9527aaf0860dcb4e97c73f282795236672c807b6c3b25f6fa1773071d01ff4\",\"license\":\"MIT\"},\"erc7579/MSAFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { LibClone } from \\\"solady/utils/LibClone.sol\\\";\\nimport { IMSA } from \\\"./interfaces/IMSA.sol\\\";\\n\\ncontract MSAFactory {\\n    address public immutable implementation;\\n\\n    constructor(address _msaImplementation) {\\n        implementation = _msaImplementation;\\n    }\\n\\n    function createAccount(\\n        bytes32 salt,\\n        bytes calldata initCode\\n    )\\n        public\\n        payable\\n        virtual\\n        returns (address)\\n    {\\n        bytes32 _salt = _getSalt(salt, initCode);\\n        (bool alreadyDeployed, address account) =\\n            LibClone.createDeterministicERC1967(msg.value, implementation, _salt);\\n\\n        if (!alreadyDeployed) {\\n            IMSA(account).initializeAccount(initCode);\\n        }\\n        return account;\\n    }\\n\\n    function getAddress(\\n        bytes32 salt,\\n        bytes calldata initcode\\n    )\\n        public\\n        view\\n        virtual\\n        returns (address)\\n    {\\n        bytes32 _salt = _getSalt(salt, initcode);\\n        return LibClone.predictDeterministicAddressERC1967(implementation, _salt, address(this));\\n    }\\n\\n    function _getSalt(\\n        bytes32 _salt,\\n        bytes calldata initCode\\n    )\\n        public\\n        pure\\n        virtual\\n        returns (bytes32 salt)\\n    {\\n        salt = keccak256(abi.encodePacked(_salt, initCode));\\n    }\\n}\\n\",\"keccak256\":\"0x59cf4ab16a3c0ce97f3b619be9521292628d21539783ed1b057d45f08c488dd6\",\"license\":\"MIT\"},\"erc7579/core/AccountBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\n/**\\n * @title reference implementation of the minimal modular smart account with Hook Extension\\n * @author zeroknots.eth | rhinestone.wtf\\n */\\ncontract AccountBase {\\n    error AccountAccessUnauthorized();\\n\\n    /////////////////////////////////////////////////////\\n    // Access Control\\n    ////////////////////////////////////////////////////\\n\\n    modifier onlyEntryPointOrSelf() virtual {\\n        if (!(msg.sender == entryPoint() || msg.sender == address(this))) {\\n            revert AccountAccessUnauthorized();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyEntryPoint() virtual {\\n        if (msg.sender != entryPoint()) {\\n            revert AccountAccessUnauthorized();\\n        }\\n        _;\\n    }\\n\\n    function entryPoint() public view virtual returns (address) {\\n        return 0x0000000071727De22E5E9d8BAf0edAc6f37da032;\\n    }\\n\\n    /// @dev Sends to the EntryPoint (i.e. `msg.sender`) the missing funds for this transaction.\\n    /// Subclass MAY override this modifier for better funds management.\\n    /// (e.g. send to the EntryPoint more than the minimum required, so that in future transactions\\n    /// it will not be required to send again)\\n    ///\\n    /// `missingAccountFunds` is the minimum value this modifier should send the EntryPoint,\\n    /// which MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\\n    modifier payPrefund(uint256 missingAccountFunds) virtual {\\n        _;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if missingAccountFunds {\\n                // Ignore failure (it's EntryPoint's job to verify, not the account's).\\n                pop(call(gas(), caller(), missingAccountFunds, codesize(), 0x00, codesize(), 0x00))\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x11805c609cfd00250d52f440983ea54daaddc2d2bd0da83676ffef6192fecb82\",\"license\":\"MIT\"},\"erc7579/core/ExecutionHelper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { Execution } from \\\"../interfaces/IERC7579Account.sol\\\";\\n\\n/**\\n * @title Execution\\n * @dev This contract executes calls in the context of this contract.\\n * @author zeroknots.eth | rhinestone.wtf\\n * shoutout to solady (vectorized, ross) for this code\\n * https://github.com/Vectorized/solady/blob/main/src/accounts/ERC4337.sol\\n */\\ncontract ExecutionHelper {\\n    error ExecutionFailed();\\n\\n    event TryExecuteUnsuccessful(uint256 batchExecutionindex, bytes result);\\n\\n    function _execute(Execution[] calldata executions) internal returns (bytes[] memory result) {\\n        uint256 length = executions.length;\\n        result = new bytes[](length);\\n\\n        for (uint256 i; i < length; i++) {\\n            Execution calldata _exec = executions[i];\\n            result[i] = _execute(_exec.target, _exec.value, _exec.callData);\\n        }\\n    }\\n\\n    function _tryExecute(Execution[] calldata executions)\\n        internal\\n        returns (bytes[] memory result)\\n    {\\n        uint256 length = executions.length;\\n        result = new bytes[](length);\\n\\n        for (uint256 i; i < length; i++) {\\n            Execution calldata _exec = executions[i];\\n            bool success;\\n            (success, result[i]) = _tryExecute(_exec.target, _exec.value, _exec.callData);\\n            if (!success) emit TryExecuteUnsuccessful(i, result[i]);\\n        }\\n    }\\n\\n    function _execute(\\n        address target,\\n        uint256 value,\\n        bytes calldata callData\\n    )\\n        internal\\n        virtual\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, callData.offset, callData.length)\\n            if iszero(call(gas(), target, value, result, callData.length, codesize(), 0x00)) {\\n                // Bubble up the revert if the call reverts.\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n\\n    function _tryExecute(\\n        address target,\\n        uint256 value,\\n        bytes calldata callData\\n    )\\n        internal\\n        virtual\\n        returns (bool success, bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, callData.offset, callData.length)\\n            success := call(gas(), target, value, result, callData.length, codesize(), 0x00)\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Execute a delegatecall with `delegate` on this account.\\n    function _executeDelegatecall(\\n        address delegate,\\n        bytes calldata callData\\n    )\\n        internal\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, callData.offset, callData.length)\\n            // Forwards the `data` to `delegate` via delegatecall.\\n            if iszero(delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)) {\\n                // Bubble up the revert if the call reverts.\\n                returndatacopy(result, 0x00, returndatasize())\\n                revert(result, returndatasize())\\n            }\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Execute a delegatecall with `delegate` on this account and catch reverts.\\n    function _tryExecuteDelegatecall(\\n        address delegate,\\n        bytes calldata callData\\n    )\\n        internal\\n        returns (bool success, bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            calldatacopy(result, callData.offset, callData.length)\\n            // Forwards the `data` to `delegate` via delegatecall.\\n            success := delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)\\n            mstore(result, returndatasize()) // Store the length.\\n            let o := add(result, 0x20)\\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa8ccc4cdddbcbb51594644a6a3b96657bae861da6461a149ca8e4c2678da0b20\",\"license\":\"MIT\"},\"erc7579/core/HookManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport \\\"./ModuleManager.sol\\\";\\nimport \\\"../interfaces/IERC7579Account.sol\\\";\\nimport \\\"../interfaces/IERC7579Module.sol\\\";\\n\\n/**\\n * @title reference implementation of HookManager\\n * @author zeroknots.eth | rhinestone.wtf\\n */\\nabstract contract HookManager {\\n    /// @custom:storage-location erc7201:hookmanager.storage.msa\\n    struct HookManagerStorage {\\n        IHook _hook;\\n    }\\n\\n    // keccak256(\\\"hookmanager.storage.msa\\\");\\n    bytes32 constant HOOKMANAGER_STORAGE_LOCATION =\\n        0x36e05829dd1b9a4411d96a3549582172d7f071c1c0db5c573fcf94eb28431608;\\n\\n    error HookPostCheckFailed();\\n    error HookAlreadyInstalled(address currentHook);\\n\\n    modifier withHook() {\\n        address hook = _getHook();\\n        if (hook == address(0)) {\\n            _;\\n        } else {\\n            bytes memory hookData = IHook(hook).preCheck(msg.sender, msg.value, msg.data);\\n            _;\\n            IHook(hook).postCheck(hookData);\\n        }\\n    }\\n\\n    function _setHook(address hook) internal virtual {\\n        bytes32 slot = HOOKMANAGER_STORAGE_LOCATION;\\n        assembly {\\n            sstore(slot, hook)\\n        }\\n    }\\n\\n    function _installHook(address hook, bytes calldata data) internal virtual {\\n        address currentHook = _getHook();\\n        if (currentHook != address(0)) {\\n            revert HookAlreadyInstalled(currentHook);\\n        }\\n        _setHook(hook);\\n        IHook(hook).onInstall(data);\\n    }\\n\\n    function _uninstallHook(address hook, bytes calldata data) internal virtual {\\n        _setHook(address(0));\\n        IHook(hook).onUninstall(data);\\n    }\\n\\n    function _getHook() internal view returns (address _hook) {\\n        bytes32 slot = HOOKMANAGER_STORAGE_LOCATION;\\n        assembly {\\n            _hook := sload(slot)\\n        }\\n    }\\n\\n    function _isHookInstalled(address module) internal view returns (bool) {\\n        return _getHook() == module;\\n    }\\n\\n    function getActiveHook() external view returns (address hook) {\\n        return _getHook();\\n    }\\n}\\n\",\"keccak256\":\"0xea44de4892ede553b9642b7bbcfe35745e5129d5a02bd04c90cfa2e15c5ece77\",\"license\":\"MIT\"},\"erc7579/core/ModuleManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { SentinelListLib, SENTINEL } from \\\"sentinellist/SentinelList.sol\\\";\\nimport {\\n    CallType, CALLTYPE_SINGLE, CALLTYPE_DELEGATECALL, CALLTYPE_STATIC\\n} from \\\"../lib/ModeLib.sol\\\";\\nimport { AccountBase } from \\\"./AccountBase.sol\\\";\\nimport \\\"../interfaces/IERC7579Module.sol\\\";\\nimport \\\"forge-std/interfaces/IERC165.sol\\\";\\nimport \\\"./Receiver.sol\\\";\\n\\n/**\\n * @title ModuleManager\\n * @author zeroknots.eth | rhinestone.wtf\\n * @dev This contract manages Validator, Executor and Fallback modules for the MSA\\n * @dev it uses SentinelList to manage the linked list of modules\\n * NOTE: the linked list is just an example. accounts may implement this differently\\n */\\nabstract contract ModuleManager is AccountBase, Receiver {\\n    using SentinelListLib for SentinelListLib.SentinelList;\\n\\n    error InvalidModule(address module);\\n    error NoFallbackHandler(bytes4 selector);\\n    error CannotRemoveLastValidator();\\n\\n    // keccak256(\\\"modulemanager.storage.msa\\\");\\n    bytes32 internal constant MODULEMANAGER_STORAGE_LOCATION =\\n        0xf88ce1fdb7fb1cbd3282e49729100fa3f2d6ee9f797961fe4fb1871cea89ea02;\\n\\n    struct FallbackHandler {\\n        address handler;\\n        CallType calltype;\\n    }\\n\\n    /// @custom:storage-location erc7201:modulemanager.storage.msa\\n    struct ModuleManagerStorage {\\n        // linked list of validators. List is initialized by initializeAccount()\\n        SentinelListLib.SentinelList $valdiators;\\n        // linked list of executors. List is initialized by initializeAccount()\\n        SentinelListLib.SentinelList $executors;\\n        // single fallback handler for all fallbacks\\n        // account vendors may implement this differently. This is just a reference implementation\\n        mapping(bytes4 selector => FallbackHandler fallbackHandler) $fallbacks;\\n    }\\n\\n    function $moduleManager() internal pure virtual returns (ModuleManagerStorage storage $ims) {\\n        bytes32 position = MODULEMANAGER_STORAGE_LOCATION;\\n        assembly {\\n            $ims.slot := position\\n        }\\n    }\\n\\n    modifier onlyExecutorModule() {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\\n        if (!$executors.contains(msg.sender)) revert InvalidModule(msg.sender);\\n        _;\\n    }\\n\\n    modifier onlyValidatorModule(address validator) {\\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\\n        if (!$valdiators.contains(validator)) revert InvalidModule(validator);\\n        _;\\n    }\\n\\n    function _initModuleManager() internal virtual {\\n        ModuleManagerStorage storage $ims = $moduleManager();\\n        $ims.$executors.init();\\n        $ims.$valdiators.init();\\n    }\\n\\n    function isAlreadyInitialized() internal view virtual returns (bool) {\\n        ModuleManagerStorage storage $ims = $moduleManager();\\n        return $ims.$valdiators.alreadyInitialized();\\n    }\\n\\n    /////////////////////////////////////////////////////\\n    //  Manage Validators\\n    ////////////////////////////////////////////////////\\n    function _installValidator(address validator, bytes calldata data) internal virtual {\\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\\n        $valdiators.push(validator);\\n        IValidator(validator).onInstall(data);\\n    }\\n\\n    function _uninstallValidator(address validator, bytes calldata data) internal {\\n        // TODO: check if its the last validator. this might brick the account\\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\\n        (address prev, bytes memory disableModuleData) = abi.decode(data, (address, bytes));\\n        $valdiators.pop(prev, validator);\\n        IValidator(validator).onUninstall(disableModuleData);\\n    }\\n\\n    function _isValidatorInstalled(address validator) internal view virtual returns (bool) {\\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\\n        return $valdiators.contains(validator);\\n    }\\n\\n    /**\\n     * THIS IS NOT PART OF THE STANDARD\\n     * Helper Function to access linked list\\n     */\\n    function getValidatorPaginated(\\n        address cursor,\\n        uint256 size\\n    )\\n        external\\n        view\\n        virtual\\n        returns (address[] memory array, address next)\\n    {\\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\\n        return $valdiators.getEntriesPaginated(cursor, size);\\n    }\\n\\n    /////////////////////////////////////////////////////\\n    //  Manage Executors\\n    ////////////////////////////////////////////////////\\n\\n    function _installExecutor(address executor, bytes calldata data) internal {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\\n        $executors.push(executor);\\n        IExecutor(executor).onInstall(data);\\n    }\\n\\n    function _uninstallExecutor(address executor, bytes calldata data) internal {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\\n        (address prev, bytes memory disableModuleData) = abi.decode(data, (address, bytes));\\n        $executors.pop(prev, executor);\\n        IExecutor(executor).onUninstall(disableModuleData);\\n    }\\n\\n    function _isExecutorInstalled(address executor) internal view virtual returns (bool) {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\\n        return $executors.contains(executor);\\n    }\\n\\n    /**\\n     * THIS IS NOT PART OF THE STANDARD\\n     * Helper Function to access linked list\\n     */\\n    function getExecutorsPaginated(\\n        address cursor,\\n        uint256 size\\n    )\\n        external\\n        view\\n        virtual\\n        returns (address[] memory array, address next)\\n    {\\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\\n        return $executors.getEntriesPaginated(cursor, size);\\n    }\\n\\n    /////////////////////////////////////////////////////\\n    //  Manage Fallback\\n    ////////////////////////////////////////////////////\\n\\n    function _installFallbackHandler(address handler, bytes calldata params) internal virtual {\\n        bytes4 selector = bytes4(params[0:4]);\\n        CallType calltype = CallType.wrap(bytes1(params[4]));\\n        bytes memory initData = params[5:];\\n\\n        if (_isFallbackHandlerInstalled(selector)) {\\n            revert(\\\"Function selector already used\\\");\\n        }\\n        $moduleManager().$fallbacks[selector] = FallbackHandler(handler, calltype);\\n        IFallback(handler).onInstall(initData);\\n    }\\n\\n    function _uninstallFallbackHandler(\\n        address handler,\\n        bytes calldata deInitData\\n    )\\n        internal\\n        virtual\\n    {\\n        bytes4 selector = bytes4(deInitData[0:4]);\\n        bytes memory _deInitData = deInitData[4:];\\n\\n        if (!_isFallbackHandlerInstalled(selector)) {\\n            revert(\\\"Function selector not used\\\");\\n        }\\n\\n        FallbackHandler memory activeFallback = $moduleManager().$fallbacks[selector];\\n\\n        if (activeFallback.handler != handler) {\\n            revert(\\\"Function selector not used by this handler\\\");\\n        }\\n\\n        CallType callType = activeFallback.calltype;\\n\\n        $moduleManager().$fallbacks[selector] = FallbackHandler(address(0), CallType.wrap(0x00));\\n\\n        IFallback(handler).onUninstall(_deInitData);\\n    }\\n\\n    function _isFallbackHandlerInstalled(bytes4 functionSig) internal view virtual returns (bool) {\\n        FallbackHandler storage $fallback = $moduleManager().$fallbacks[functionSig];\\n        return $fallback.handler != address(0);\\n    }\\n\\n    function _isFallbackHandlerInstalled(\\n        bytes4 functionSig,\\n        address _handler\\n    )\\n        internal\\n        view\\n        virtual\\n        returns (bool)\\n    {\\n        FallbackHandler storage $fallback = $moduleManager().$fallbacks[functionSig];\\n        return $fallback.handler == _handler;\\n    }\\n\\n    function getActiveFallbackHandler(bytes4 functionSig)\\n        external\\n        view\\n        virtual\\n        returns (FallbackHandler memory)\\n    {\\n        return $moduleManager().$fallbacks[functionSig];\\n    }\\n\\n    // FALLBACK\\n    fallback() external payable override(Receiver) receiverFallback {\\n        FallbackHandler storage $fallbackHandler = $moduleManager().$fallbacks[msg.sig];\\n        address handler = $fallbackHandler.handler;\\n        CallType calltype = $fallbackHandler.calltype;\\n        if (handler == address(0)) revert NoFallbackHandler(msg.sig);\\n\\n        if (calltype == CALLTYPE_STATIC) {\\n            assembly {\\n                function allocate(length) -> pos {\\n                    pos := mload(0x40)\\n                    mstore(0x40, add(pos, length))\\n                }\\n\\n                let calldataPtr := allocate(calldatasize())\\n                calldatacopy(calldataPtr, 0, calldatasize())\\n\\n                // The msg.sender address is shifted to the left by 12 bytes to remove the padding\\n                // Then the address without padding is stored right after the calldata\\n                let senderPtr := allocate(20)\\n                mstore(senderPtr, shl(96, caller()))\\n\\n                // Add 20 bytes for the address appended add the end\\n                let success :=\\n                    staticcall(gas(), handler, calldataPtr, add(calldatasize(), 20), 0, 0)\\n\\n                let returnDataPtr := allocate(returndatasize())\\n                returndatacopy(returnDataPtr, 0, returndatasize())\\n                if iszero(success) { revert(returnDataPtr, returndatasize()) }\\n                return(returnDataPtr, returndatasize())\\n            }\\n        }\\n        if (calltype == CALLTYPE_SINGLE) {\\n            assembly {\\n                function allocate(length) -> pos {\\n                    pos := mload(0x40)\\n                    mstore(0x40, add(pos, length))\\n                }\\n\\n                let calldataPtr := allocate(calldatasize())\\n                calldatacopy(calldataPtr, 0, calldatasize())\\n\\n                // The msg.sender address is shifted to the left by 12 bytes to remove the padding\\n                // Then the address without padding is stored right after the calldata\\n                let senderPtr := allocate(20)\\n                mstore(senderPtr, shl(96, caller()))\\n\\n                // Add 20 bytes for the address appended add the end\\n                let success := call(gas(), handler, 0, calldataPtr, add(calldatasize(), 20), 0, 0)\\n\\n                let returnDataPtr := allocate(returndatasize())\\n                returndatacopy(returnDataPtr, 0, returndatasize())\\n                if iszero(success) { revert(returnDataPtr, returndatasize()) }\\n                return(returnDataPtr, returndatasize())\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe74e93d4912692c5fc816e8706030eb8401ec8b862c98c3566230dfd3ed8791f\",\"license\":\"MIT\"},\"erc7579/core/Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/**\\n * @title Receiver\\n * @dev This contract receives safe-transferred ERC721 and ERC1155 tokens.\\n * @author Modified from Solady\\n * (https://github.com/Vectorized/solady/blob/main/src/accounts/Receiver.sol)\\n */\\nabstract contract Receiver {\\n    /// @dev For receiving ETH.\\n    receive() external payable virtual { }\\n\\n    /// @dev Fallback function with the `receiverFallback` modifier.\\n    fallback() external payable virtual receiverFallback { }\\n\\n    /// @dev Modifier for the fallback function to handle token callbacks.\\n    modifier receiverFallback() virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let s := shr(224, calldataload(0))\\n            // 0x150b7a02: `onERC721Received(address,address,uint256,bytes)`.\\n            // 0xf23a6e61: `onERC1155Received(address,address,uint256,uint256,bytes)`.\\n            // 0xbc197c81: `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\\n            if or(eq(s, 0x150b7a02), or(eq(s, 0xf23a6e61), eq(s, 0xbc197c81))) {\\n                mstore(0x20, s) // Store `msg.sig`.\\n                return(0x3c, 0x20) // Return `msg.sig`.\\n            }\\n        }\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x42d41b30a6582d95d737fd75122b621a8af1ec3123782d91a29385b67612b9e4\",\"license\":\"MIT\"},\"erc7579/interfaces/IERC4337Account.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { PackedUserOperation } from \\\"account-abstraction/interfaces/PackedUserOperation.sol\\\";\\n\\ninterface IERC4337Account {\\n    /**\\n     * Validate user's signature and nonce\\n     * the entryPoint will make the call to the recipient only if this validation call returns\\n     * successfully.\\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\\n     * This allows making a \\\"simulation call\\\" without a valid signature\\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to\\n     * signal failure.\\n     *\\n     * @dev Must validate caller is the entryPoint.\\n     *      Must validate the signature and nonce\\n     * @param userOp              - The operation that is about to be executed.\\n     * @param userOpHash          - Hash of the user's request data. can be used as the basis for\\n     * signature.\\n     * @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\\n     *                              This is the minimum amount to transfer to the sender(entryPoint)\\n     * to be\\n     *                              able to make the call. The excess is left as a deposit in the\\n     * entrypoint\\n     *                              for future calls. Can be withdrawn anytime using\\n     * \\\"entryPoint.withdrawTo()\\\".\\n     *                              In case there is a paymaster in the request (or the current\\n     * deposit is high\\n     *                              enough), this value will be zero.\\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData`\\n     * and\\n     *                              `_unpackValidationData` to encode and decode.\\n     *                              <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark\\n     * signature failure,\\n     *                                 otherwise, an address of an \\\"authorizer\\\" contract.\\n     *                              <6-byte> validUntil - Last timestamp this operation is valid. 0\\n     * for \\\"indefinite\\\"\\n     *                              <6-byte> validAfter - First timestamp this operation is valid\\n     *                                                    If an account doesn't use time-range, it\\n     * is enough to\\n     *                                                    return SIG_VALIDATION_FAILED value (1) for\\n     * signature failure.\\n     *                              Note that the validation code cannot use block.timestamp (or\\n     * block.number) directly.\\n     */\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 missingAccountFunds\\n    )\\n        external\\n        payable\\n        returns (uint256 validationData);\\n\\n    /**\\n     * Account may implement this execute method.\\n     * passing this methodSig at the beginning of callData will cause the entryPoint to pass the\\n     * full UserOp (and hash)\\n     * to the account.\\n     * The account should skip the methodSig, and use the callData (and optionally, other UserOp\\n     * fields)\\n     *\\n     * @param userOp              - The operation that was just validated.\\n     * @param userOpHash          - Hash of the user's request data.\\n     */\\n    function executeUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash\\n    )\\n        external\\n        payable;\\n}\\n\",\"keccak256\":\"0x55f4a9fe65535a8b3f6db727c764aad1eb237a22828f2565941d0c079e9b7e3e\",\"license\":\"MIT\"},\"erc7579/interfaces/IERC7579Account.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { CallType, ExecType, ModeCode } from \\\"../lib/ModeLib.sol\\\";\\n\\nstruct Execution {\\n    address target;\\n    uint256 value;\\n    bytes callData;\\n}\\n\\ninterface IERC7579Account {\\n    event ModuleInstalled(uint256 moduleTypeId, address module);\\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\\n\\n    /**\\n     * @dev Executes a transaction on behalf of the account.\\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * If a mode is requested that is not supported by the Account, it MUST revert\\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\\n     * @param executionCalldata The encoded execution call data\\n     */\\n    function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\\n\\n    /**\\n     * @dev Executes a transaction on behalf of the account.\\n     *         This function is intended to be called by Executor Modules\\n     * @dev Ensure adequate authorization control: i.e. onlyExecutorModule\\n     *\\n     * @dev MSA MUST implement this function signature.\\n     * If a mode is requested that is not supported by the Account, it MUST revert\\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\\n     * @param executionCalldata The encoded execution call data\\n     */\\n    function executeFromExecutor(\\n        ModeCode mode,\\n        bytes calldata executionCalldata\\n    )\\n        external\\n        payable\\n        returns (bytes[] memory returnData);\\n\\n    /**\\n     * @dev ERC-1271 isValidSignature\\n     *         This function is intended to be used to validate a smart account signature\\n     * and may forward the call to a validator module\\n     *\\n     * @param hash The hash of the data that is signed\\n     * @param data The data that is signed\\n     */\\n    function isValidSignature(bytes32 hash, bytes calldata data) external view returns (bytes4);\\n\\n    /**\\n     * @dev installs a Module of a certain type on the smart account\\n     * @dev Implement Authorization control of your chosing\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     * @param module the module address\\n     * @param initData arbitrary data that may be required on the module during `onInstall`\\n     * initialization.\\n     */\\n    function installModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata initData\\n    )\\n        external\\n        payable;\\n\\n    /**\\n     * @dev uninstalls a Module of a certain type on the smart account\\n     * @dev Implement Authorization control of your chosing\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     * @param module the module address\\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\\n     * de-initialization.\\n     */\\n    function uninstallModule(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata deInitData\\n    )\\n        external\\n        payable;\\n\\n    /**\\n     * Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\\n     * @param encodedMode the encoded mode\\n     */\\n    function supportsExecutionMode(ModeCode encodedMode) external view returns (bool);\\n\\n    /**\\n     * Function to check if the account supports installation of a certain module type Id\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     */\\n    function supportsModule(uint256 moduleTypeId) external view returns (bool);\\n\\n    /**\\n     * Function to check if the account has a certain module installed\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\\n     *            thus may be necessary to query multiple module types\\n     * @param module the module address\\n     * @param additionalContext additional context data that the smart account may interpret to\\n     *                          identifiy conditions under which the module is installed.\\n     *                          usually this is not necessary, but for some special hooks that\\n     *                          are stored in mappings, this param might be needed\\n     */\\n    function isModuleInstalled(\\n        uint256 moduleTypeId,\\n        address module,\\n        bytes calldata additionalContext\\n    )\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the account id of the smart account\\n     * @return accountImplementationId the account id of the smart account\\n     * the accountId should be structured like so:\\n     *        \\\"vendorname.accountname.semver\\\"\\n     */\\n    function accountId() external view returns (string memory accountImplementationId);\\n}\\n\",\"keccak256\":\"0x08368aba5f1bb83eb57e9f8d31a04edee4be69159b4844a6443f65100917011c\",\"license\":\"MIT\"},\"erc7579/interfaces/IERC7579Module.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { PackedUserOperation } from \\\"account-abstraction/interfaces/PackedUserOperation.sol\\\";\\n\\nuint256 constant VALIDATION_SUCCESS = 0;\\nuint256 constant VALIDATION_FAILED = 1;\\n\\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\\nuint256 constant MODULE_TYPE_FALLBACK = 3;\\nuint256 constant MODULE_TYPE_HOOK = 4;\\n\\ninterface IModule {\\n    error AlreadyInitialized(address smartAccount);\\n    error NotInitialized(address smartAccount);\\n\\n    /**\\n     * @dev This function is called by the smart account during installation of the module\\n     * @param data arbitrary data that may be required on the module during `onInstall`\\n     * initialization\\n     *\\n     * MUST revert on error (i.e. if module is already enabled)\\n     */\\n    function onInstall(bytes calldata data) external;\\n\\n    /**\\n     * @dev This function is called by the smart account during uninstallation of the module\\n     * @param data arbitrary data that may be required on the module during `onUninstall`\\n     * de-initialization\\n     *\\n     * MUST revert on error\\n     */\\n    function onUninstall(bytes calldata data) external;\\n\\n    /**\\n     * @dev Returns boolean value if module is a certain type\\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\\n     *\\n     * MUST return true if the module is of the given type and false otherwise\\n     */\\n    function isModuleType(uint256 moduleTypeId) external view returns (bool);\\n\\n    /**\\n     * @dev Returns if the module was already initialized for a provided smartaccount\\n     */\\n    function isInitialized(address smartAccount) external view returns (bool);\\n}\\n\\ninterface IValidator is IModule {\\n    error InvalidTargetAddress(address target);\\n\\n    /**\\n     * @dev Validates a transaction on behalf of the account.\\n     *         This function is intended to be called by the MSA during the ERC-4337 validaton phase\\n     *         Note: solely relying on bytes32 hash and signature is not suffcient for some\\n     * validation implementations (i.e. SessionKeys often need access to userOp.calldata)\\n     * @param userOp The user operation to be validated. The userOp MUST NOT contain any metadata.\\n     * The MSA MUST clean up the userOp before sending it to the validator.\\n     * @param userOpHash The hash of the user operation to be validated\\n     * @return return value according to ERC-4337\\n     */\\n    function validateUserOp(\\n        PackedUserOperation calldata userOp,\\n        bytes32 userOpHash\\n    )\\n        external\\n        returns (uint256);\\n\\n    /**\\n     * Validator can be used for ERC-1271 validation\\n     */\\n    function isValidSignatureWithSender(\\n        address sender,\\n        bytes32 hash,\\n        bytes calldata data\\n    )\\n        external\\n        view\\n        returns (bytes4);\\n}\\n\\ninterface IExecutor is IModule { }\\n\\ninterface IHook is IModule {\\n    function preCheck(\\n        address msgSender,\\n        uint256 msgValue,\\n        bytes calldata msgData\\n    )\\n        external\\n        returns (bytes memory hookData);\\n\\n    function postCheck(bytes calldata hookData) external;\\n}\\n\\ninterface IFallback is IModule { }\\n\",\"keccak256\":\"0x78ab984fc364972382a73a0d793c558f52800999d5e0e69c4df326a1de840604\",\"license\":\"MIT\"},\"erc7579/interfaces/IMSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport { IERC7579Account } from \\\"./IERC7579Account.sol\\\";\\nimport { IERC4337Account } from \\\"./IERC4337Account.sol\\\";\\n\\nimport { CallType, ExecType, ModeCode } from \\\"../lib/ModeLib.sol\\\";\\n\\ninterface IMSA is IERC7579Account, IERC4337Account {\\n    // Error thrown when an unsupported ModuleType is requested\\n    error UnsupportedModuleType(uint256 moduleTypeId);\\n    // Error thrown when an execution with an unsupported CallType was made\\n    error UnsupportedCallType(CallType callType);\\n    // Error thrown when an execution with an unsupported ExecType was made\\n    error UnsupportedExecType(ExecType execType);\\n    // Error thrown when account initialization fails\\n    error AccountInitializationFailed();\\n    // Error thrown when account installs/unistalls module with mismatched input `moduleTypeId`\\n    error MismatchModuleTypeId(uint256 moduleTypeId);\\n\\n    /**\\n     * @dev Initializes the account. Function might be called directly, or by a Factory\\n     * @param data. encoded data that can be used during the initialization phase\\n     */\\n    function initializeAccount(bytes calldata data) external payable;\\n}\\n\",\"keccak256\":\"0x649ef44dfc5ba9b485b31cda765335e96f35aa6e595fd8d86c28a62aa8982cbe\",\"license\":\"MIT\"},\"erc7579/lib/ExecutionLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { Execution } from \\\"../interfaces/IERC7579Account.sol\\\";\\n\\n/**\\n * Helper Library for decoding Execution calldata\\n * malloc for memory allocation is bad for gas. use this assembly instead\\n */\\nlibrary ExecutionLib {\\n    function decodeBatch(bytes calldata callData)\\n        internal\\n        pure\\n        returns (Execution[] calldata executionBatch)\\n    {\\n        /*\\n         * Batch Call Calldata Layout\\n         * Offset (in bytes)    | Length (in bytes) | Contents\\n         * 0x0                  | 0x4               | bytes4 function selector\\n        *  0x4                  | -                 |\\n        abi.encode(IERC7579Execution.Execution[])\\n         */\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly (\\\"memory-safe\\\") {\\n            let dataPointer := add(callData.offset, calldataload(callData.offset))\\n\\n            // Extract the ERC7579 Executions\\n            executionBatch.offset := add(dataPointer, 32)\\n            executionBatch.length := calldataload(dataPointer)\\n        }\\n    }\\n\\n    function encodeBatch(Execution[] memory executions)\\n        internal\\n        pure\\n        returns (bytes memory callData)\\n    {\\n        callData = abi.encode(executions);\\n    }\\n\\n    function decodeSingle(bytes calldata executionCalldata)\\n        internal\\n        pure\\n        returns (address target, uint256 value, bytes calldata callData)\\n    {\\n        target = address(bytes20(executionCalldata[0:20]));\\n        value = uint256(bytes32(executionCalldata[20:52]));\\n        callData = executionCalldata[52:];\\n    }\\n\\n    function encodeSingle(\\n        address target,\\n        uint256 value,\\n        bytes memory callData\\n    )\\n        internal\\n        pure\\n        returns (bytes memory userOpCalldata)\\n    {\\n        userOpCalldata = abi.encodePacked(target, value, callData);\\n    }\\n}\\n\",\"keccak256\":\"0xa6d41aa7532a4bff83a8c335a8050ebe0c7a73c456d70594d2123dc293892c5c\",\"license\":\"MIT\"},\"erc7579/lib/ModeLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/**\\n * @title ModeLib\\n * To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\\n * encoding is used.\\n *    Function Signature of execute function:\\n *           function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\\n * This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\\n * context.\\n * NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\\n * implement\\n * more complex execution modes may use the entire bytes32.\\n *\\n * |--------------------------------------------------------------------|\\n * | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\\n * |--------------------------------------------------------------------|\\n * | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\\n * |--------------------------------------------------------------------|\\n *\\n * CALLTYPE: 1 byte\\n * CallType is used to determine how the executeCalldata paramter of the execute function has to be\\n * decoded.\\n * It can be either single, batch or delegatecall. In the future different calls could be added.\\n * CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\\n *\\n * EXECTYPE: 1 byte\\n * ExecType is used to determine how the account should handle the execution.\\n * It can indicate if the execution should revert on failure or continue execution.\\n * In the future more execution modes may be added.\\n * Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\\n * a batch fails, the entire batch is reverted\\n *\\n * UNUSED: 4 bytes\\n * Unused bytes are reserved for future use.\\n *\\n * ModeSelector: bytes4\\n * The \\\"optional\\\" mode selector can be used by account vendors, to implement custom behavior in\\n * their accounts.\\n * the way a ModeSelector is to be calculated is bytes4(keccak256(\\\"vendorname.featurename\\\"))\\n * this is to prevent collisions between different vendors, while allowing innovation and the\\n * development of new features without coordination between ERC-7579 implementing accounts\\n *\\n * ModePayload: 22 bytes\\n * Mode payload is used to pass additional data to the smart account execution, this may be\\n * interpreted depending on the ModeSelector\\n *\\n * ExecutionCallData: n bytes\\n * single, delegatecall or batch exec abi.encoded as bytes\\n */\\nimport { Execution } from \\\"../interfaces/IERC7579Account.sol\\\";\\n\\n// Custom type for improved developer experience\\ntype ModeCode is bytes32;\\n\\ntype CallType is bytes1;\\n\\ntype ExecType is bytes1;\\n\\ntype ModeSelector is bytes4;\\n\\ntype ModePayload is bytes22;\\n\\n// Default CallType\\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\\n// Batched CallType\\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\\n// @dev Implementing delegatecall is OPTIONAL!\\n// implement delegatecall with extreme care.\\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\\n\\n// @dev default behavior is to revert on failure\\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\\n// Since this is value 0x00, no additional encoding is required for simple accounts\\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\\n// @dev account may elect to change execution behavior. For example \\\"try exec\\\" / \\\"allow fail\\\"\\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\\n\\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\\n// Example declaration of a custom mode selector\\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\\\"default.mode.offset\\\")));\\n\\n/**\\n * @dev ModeLib is a helper library to encode/decode ModeCodes\\n */\\nlibrary ModeLib {\\n    function decode(ModeCode mode)\\n        internal\\n        pure\\n        returns (\\n            CallType _calltype,\\n            ExecType _execType,\\n            ModeSelector _modeSelector,\\n            ModePayload _modePayload\\n        )\\n    {\\n        assembly {\\n            _calltype := mode\\n            _execType := shl(8, mode)\\n            _modeSelector := shl(48, mode)\\n            _modePayload := shl(80, mode)\\n        }\\n    }\\n\\n    function encode(\\n        CallType callType,\\n        ExecType execType,\\n        ModeSelector mode,\\n        ModePayload payload\\n    )\\n        internal\\n        pure\\n        returns (ModeCode)\\n    {\\n        return ModeCode.wrap(\\n            bytes32(\\n                abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)\\n            )\\n        );\\n    }\\n\\n    function encodeSimpleBatch() internal pure returns (ModeCode mode) {\\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\\n    }\\n\\n    function encodeSimpleSingle() internal pure returns (ModeCode mode) {\\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\\n    }\\n\\n    function getCallType(ModeCode mode) internal pure returns (CallType calltype) {\\n        assembly {\\n            calltype := mode\\n        }\\n    }\\n}\\n\\nusing { eqModeSelector as == } for ModeSelector global;\\nusing { eqCallType as == } for CallType global;\\nusing { eqExecType as == } for ExecType global;\\n\\nfunction eqCallType(CallType a, CallType b) pure returns (bool) {\\n    return CallType.unwrap(a) == CallType.unwrap(b);\\n}\\n\\nfunction eqExecType(ExecType a, ExecType b) pure returns (bool) {\\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\\n}\\n\\nfunction eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\\n}\\n\",\"keccak256\":\"0x02ce0fc8805d1427841f32e2335157e3fae18e99d5c49ba46d53e12fcd1a5185\",\"license\":\"MIT\"},\"erc7579/utils/Bootstrap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\nimport \\\"../core/ModuleManager.sol\\\";\\nimport \\\"../core/HookManager.sol\\\";\\n\\nimport \\\"../interfaces/IERC7579Module.sol\\\";\\n\\nstruct BootstrapConfig {\\n    address module;\\n    bytes data;\\n}\\n\\ncontract Bootstrap is ModuleManager, HookManager {\\n    function singleInitMSA(IModule validator, bytes calldata data) external {\\n        // init validator\\n        _installValidator(address(validator), data);\\n    }\\n\\n    /**\\n     * This function is intended to be called by the MSA with a delegatecall.\\n     * Make sure that the MSA already initilazed the linked lists in the ModuleManager prior to\\n     * calling this function\\n     */\\n    function initMSA(\\n        BootstrapConfig[] calldata $valdiators,\\n        BootstrapConfig[] calldata $executors,\\n        BootstrapConfig calldata _hook,\\n        BootstrapConfig[] calldata _fallbacks\\n    )\\n        external\\n    {\\n        // init validators\\n        for (uint256 i; i < $valdiators.length; i++) {\\n            _installValidator($valdiators[i].module, $valdiators[i].data);\\n        }\\n\\n        // init executors\\n        for (uint256 i; i < $executors.length; i++) {\\n            if ($executors[i].module == address(0)) continue;\\n            _installExecutor($executors[i].module, $executors[i].data);\\n        }\\n\\n        // init hook\\n        if (_hook.module != address(0)) {\\n            _installHook(_hook.module, _hook.data);\\n        }\\n\\n        // init fallback\\n        for (uint256 i; i < _fallbacks.length; i++) {\\n            if (_fallbacks[i].module == address(0)) continue;\\n            _installFallbackHandler(_fallbacks[i].module, _fallbacks[i].data);\\n        }\\n    }\\n\\n    function _getInitMSACalldata(\\n        BootstrapConfig[] calldata $valdiators,\\n        BootstrapConfig[] calldata $executors,\\n        BootstrapConfig calldata _hook,\\n        BootstrapConfig[] calldata _fallbacks\\n    )\\n        external\\n        view\\n        returns (bytes memory init)\\n    {\\n        init = abi.encode(\\n            address(this),\\n            abi.encodeCall(this.initMSA, ($valdiators, $executors, _hook, _fallbacks))\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x0f1474b9f03cc19e781766784dc28d701036d2a06145c16fb3b88e7746249ef3\",\"license\":\"MIT\"},\"forge-std/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    /// uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x414b2861b1acbf816ccb7346d3f16cf6c1e002e9e5e40d2f1f26fa5ddc2ea600\",\"license\":\"MIT\"},\"forge-std/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\n/// @dev Interface of the ERC20 standard as defined in the EIP.\\n/// @dev This includes the optional name, symbol, and decimals metadata.\\ninterface IERC20 {\\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\\n    /// is the new allowance.\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice Returns the amount of tokens in existence.\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Returns the amount of tokens owned by `account`.\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\\n    /// to spend on behalf of `owner`\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\\n    /// `amount` is then deducted from the caller's allowance.\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Returns the name of the token.\\n    function name() external view returns (string memory);\\n\\n    /// @notice Returns the symbol of the token.\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Returns the decimals places of the token.\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x4cab887298790f908c27de107e4e2907ca5413aee482ef776f8d2f353c5ef947\",\"license\":\"MIT\"},\"forge-std/interfaces/IERC4626.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/// @dev Interface of the ERC4626 \\\"Tokenized Vault Standard\\\", as defined in\\n/// https://eips.ethereum.org/EIPS/eip-4626\\ninterface IERC4626 is IERC20 {\\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\\n    );\\n\\n    /// @notice Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\\n    /// @dev\\n    /// - MUST be an ERC-20 token contract.\\n    /// - MUST NOT revert.\\n    function asset() external view returns (address assetTokenAddress);\\n\\n    /// @notice Returns the total amount of the underlying asset that is \\u201cmanaged\\u201d by Vault.\\n    /// @dev\\n    /// - SHOULD include any compounding that occurs from yield.\\n    /// - MUST be inclusive of any fees that are charged against assets in the Vault.\\n    /// - MUST NOT revert.\\n    function totalAssets() external view returns (uint256 totalManagedAssets);\\n\\n    /// @notice Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\\n    /// scenario where all the conditions are met.\\n    /// @dev\\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n    /// - MUST NOT show any variations depending on the caller.\\n    /// - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: This calculation MAY NOT reflect the \\u201cper-user\\u201d price-per-share, and instead should reflect the\\n    /// \\u201caverage-user\\u2019s\\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n    /// from.\\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\\n\\n    /// @notice Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\\n    /// scenario where all the conditions are met.\\n    /// @dev\\n    /// - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n    /// - MUST NOT show any variations depending on the caller.\\n    /// - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: This calculation MAY NOT reflect the \\u201cper-user\\u201d price-per-share, and instead should reflect the\\n    /// \\u201caverage-user\\u2019s\\u201d price-per-share, meaning what the average user should expect to see when exchanging to and\\n    /// from.\\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n\\n    /// @notice Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\\n    /// through a deposit call.\\n    /// @dev\\n    /// - MUST return a limited value if receiver is subject to some deposit limit.\\n    /// - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\\n    /// - MUST NOT revert.\\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\\n\\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\\n    /// current on-chain conditions.\\n    /// @dev\\n    /// - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\\n    ///   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\\n    ///   in the same transaction.\\n    /// - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\\n    ///   deposit would be accepted, regardless if the user has enough tokens approved, etc.\\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\\n    /// share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\\n\\n    /// @notice Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\\n    /// @dev\\n    /// - MUST emit the Deposit event.\\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n    ///   deposit execution, and are accounted for during deposit.\\n    /// - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\\n    ///   approving enough underlying tokens to the Vault contract, etc).\\n    ///\\n    /// NOTE: most implementations will require pre-approval of the Vault with the Vault\\u2019s underlying asset token.\\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\\n\\n    /// @notice Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\\n    /// @dev\\n    /// - MUST return a limited value if receiver is subject to some mint limit.\\n    /// - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\\n    /// - MUST NOT revert.\\n    function maxMint(address receiver) external view returns (uint256 maxShares);\\n\\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\\n    /// current on-chain conditions.\\n    /// @dev\\n    /// - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\\n    ///   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\\n    ///   same transaction.\\n    /// - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\\n    ///   would be accepted, regardless if the user has enough tokens approved, etc.\\n    /// - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\\n    /// share price or some other type of condition, meaning the depositor will lose assets by minting.\\n    function previewMint(uint256 shares) external view returns (uint256 assets);\\n\\n    /// @notice Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\\n    /// @dev\\n    /// - MUST emit the Deposit event.\\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\\n    ///   execution, and are accounted for during mint.\\n    /// - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\\n    ///   approving enough underlying tokens to the Vault contract, etc).\\n    ///\\n    /// NOTE: most implementations will require pre-approval of the Vault with the Vault\\u2019s underlying asset token.\\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\\n\\n    /// @notice Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\\n    /// Vault, through a withdraw call.\\n    /// @dev\\n    /// - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n    /// - MUST NOT revert.\\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\\n\\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\\n    /// given current on-chain conditions.\\n    /// @dev\\n    /// - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\\n    ///   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\\n    ///   called\\n    ///   in the same transaction.\\n    /// - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\\n    ///   the withdrawal would be accepted, regardless if the user has enough shares, etc.\\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\\n    /// share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\\n\\n    /// @notice Burns shares from owner and sends exactly assets of underlying tokens to receiver.\\n    /// @dev\\n    /// - MUST emit the Withdraw event.\\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n    ///   withdraw execution, and are accounted for during withdraw.\\n    /// - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\\n    ///   not having enough shares, etc).\\n    ///\\n    /// Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n    /// Those methods should be performed separately.\\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\\n\\n    /// @notice Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\\n    /// through a redeem call.\\n    /// @dev\\n    /// - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n    /// - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\\n    /// - MUST NOT revert.\\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\\n\\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\\n    /// given current on-chain conditions.\\n    /// @dev\\n    /// - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\\n    ///   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\\n    ///   same transaction.\\n    /// - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\\n    ///   redemption would be accepted, regardless if the user has enough shares, etc.\\n    /// - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n    /// - MUST NOT revert.\\n    ///\\n    /// NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\\n    /// share price or some other type of condition, meaning the depositor will lose assets by redeeming.\\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\\n\\n    /// @notice Burns exactly shares from owner and sends assets of underlying tokens to receiver.\\n    /// @dev\\n    /// - MUST emit the Withdraw event.\\n    /// - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n    ///   redeem execution, and are accounted for during redeem.\\n    /// - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\\n    ///   not having enough shares, etc).\\n    ///\\n    /// NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n    /// Those methods should be performed separately.\\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\\n}\\n\",\"keccak256\":\"0x324b43bdb94d78fe11220102056ba27362b7083fbc394fddc86dd68f75c0e46e\",\"license\":\"MIT\"},\"forge-std/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/// @title ERC-721 Non-Fungible Token Standard\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// Note: the ERC-165 identifier for this interface is 0x80ac58cd.\\ninterface IERC721 is IERC165 {\\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\\n    /// This event emits when NFTs are created (`from` == 0) and destroyed\\n    /// (`to` == 0). Exception: during contract creation, any number of NFTs\\n    /// may be created and assigned without emitting Transfer. At the time of\\n    /// any transfer, the approved address for that NFT (if any) is reset to none.\\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\\n\\n    /// @dev This emits when the approved address for an NFT is changed or\\n    /// reaffirmed. The zero address indicates there is no approved address.\\n    /// When a Transfer event emits, this also indicates that the approved\\n    /// address for that NFT (if any) is reset to none.\\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\\n\\n    /// @dev This emits when an operator is enabled or disabled for an owner.\\n    /// The operator can manage all NFTs of the owner.\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n    /// @notice Count all NFTs assigned to an owner\\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\\n    /// function throws for queries about the zero address.\\n    /// @param _owner An address for whom to query the balance\\n    /// @return The number of NFTs owned by `_owner`, possibly zero\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    /// @notice Find the owner of an NFT\\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\\n    /// about them do throw.\\n    /// @param _tokenId The identifier for an NFT\\n    /// @return The address of the owner of the NFT\\n    function ownerOf(uint256 _tokenId) external view returns (address);\\n\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n    /// operator, or the approved address for this NFT. Throws if `_from` is\\n    /// not the current owner. Throws if `_to` is the zero address. Throws if\\n    /// `_tokenId` is not a valid NFT. When transfer is complete, this function\\n    /// checks if `_to` is a smart contract (code size > 0). If so, it calls\\n    /// `onERC721Received` on `_to` and throws if the return value is not\\n    /// `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    /// @param data Additional data with no specified format, sent in call to `_to`\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\\n\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\n    /// @dev This works identically to the other function with an extra data parameter,\\n    /// except this function just sets data to \\\"\\\".\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\\n\\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\n    /// TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\n    /// THEY MAY BE PERMANENTLY LOST\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n    /// operator, or the approved address for this NFT. Throws if `_from` is\\n    /// not the current owner. Throws if `_to` is the zero address. Throws if\\n    /// `_tokenId` is not a valid NFT.\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\\n\\n    /// @notice Change or reaffirm the approved address for an NFT\\n    /// @dev The zero address indicates there is no approved address.\\n    /// Throws unless `msg.sender` is the current NFT owner, or an authorized\\n    /// operator of the current owner.\\n    /// @param _approved The new approved NFT controller\\n    /// @param _tokenId The NFT to approve\\n    function approve(address _approved, uint256 _tokenId) external payable;\\n\\n    /// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\n    /// all of `msg.sender`'s assets\\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\\n    /// multiple operators per owner.\\n    /// @param _operator Address to add to the set of authorized operators\\n    /// @param _approved True if the operator is approved, false to revoke approval\\n    function setApprovalForAll(address _operator, bool _approved) external;\\n\\n    /// @notice Get the approved address for a single NFT\\n    /// @dev Throws if `_tokenId` is not a valid NFT.\\n    /// @param _tokenId The NFT to find the approved address for\\n    /// @return The approved address for this NFT, or the zero address if there is none\\n    function getApproved(uint256 _tokenId) external view returns (address);\\n\\n    /// @notice Query if an address is an authorized operator for another address\\n    /// @param _owner The address that owns the NFTs\\n    /// @param _operator The address that acts on behalf of the owner\\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\\n}\\n\\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\\ninterface IERC721TokenReceiver {\\n    /// @notice Handle the receipt of an NFT\\n    /// @dev The ERC721 smart contract calls this function on the recipient\\n    /// after a `transfer`. This function MAY throw to revert and reject the\\n    /// transfer. Return of other than the magic value MUST result in the\\n    /// transaction being reverted.\\n    /// Note: the contract address is always the message sender.\\n    /// @param _operator The address which called `safeTransferFrom` function\\n    /// @param _from The address which previously owned the token\\n    /// @param _tokenId The NFT identifier which is being transferred\\n    /// @param _data Additional data with no specified format\\n    /// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    ///  unless throwing\\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data)\\n        external\\n        returns (bytes4);\\n}\\n\\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// Note: the ERC-165 identifier for this interface is 0x5b5e139f.\\ninterface IERC721Metadata is IERC721 {\\n    /// @notice A descriptive name for a collection of NFTs in this contract\\n    function name() external view returns (string memory _name);\\n\\n    /// @notice An abbreviated name for NFTs in this contract\\n    function symbol() external view returns (string memory _symbol);\\n\\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\\n    /// 3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\n    /// Metadata JSON Schema\\\".\\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\\n}\\n\\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n/// Note: the ERC-165 identifier for this interface is 0x780e9d63.\\ninterface IERC721Enumerable is IERC721 {\\n    /// @notice Count NFTs tracked by this contract\\n    /// @return A count of valid NFTs tracked by this contract, where each one of\\n    /// them has an assigned and queryable owner not equal to the zero address\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Enumerate valid NFTs\\n    /// @dev Throws if `_index` >= `totalSupply()`.\\n    /// @param _index A counter less than `totalSupply()`\\n    /// @return The token identifier for the `_index`th NFT,\\n    /// (sort order not specified)\\n    function tokenByIndex(uint256 _index) external view returns (uint256);\\n\\n    /// @notice Enumerate NFTs assigned to an owner\\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\\n    /// `_owner` is the zero address, representing invalid NFTs.\\n    /// @param _owner An address where we are interested in NFTs owned by them\\n    /// @param _index A counter less than `balanceOf(_owner)`\\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\\n    /// (sort order not specified)\\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xf069262a264fdb69f8f37a10d2df7374649e9ba73f8414c9c8a3b51184625f15\",\"license\":\"MIT\"},\"modulekit/Accounts.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable no-unused-import */\\nimport { Execution, IERC7579Account } from \\\"./external/ERC7579.sol\\\";\\n\",\"keccak256\":\"0xbebda0e48bf4fe679dedb8a413cce6591b671a165d7ed534ca1a4a10e5e1e169\",\"license\":\"MIT\"},\"modulekit/Integrations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable no-unused-import */\\nimport { ERC20Integration } from \\\"./integrations/ERC20.sol\\\";\\nimport { ERC721Integration } from \\\"./integrations/ERC721.sol\\\";\\nimport { ERC4626Integration } from \\\"./integrations/ERC4626.sol\\\";\\nimport { UniswapV3Integration, SWAPROUTER_ADDRESS } from \\\"./integrations/uniswap/v3/Uniswap.sol\\\";\\n\",\"keccak256\":\"0x88dc1c5c76d3e00df19a173bd71632240bfcac5d2edaff628d1ac38f8e1af9bb\",\"license\":\"MIT\"},\"modulekit/external/ERC7579.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\n/* solhint-disable no-unused-import */\\nimport { MSAFactory as ERC7579AccountFactory } from \\\"erc7579/MSAFactory.sol\\\";\\nimport { MSAAdvanced as ERC7579Account } from \\\"erc7579/MSAAdvanced.sol\\\";\\nimport { Execution, IERC7579Account } from \\\"erc7579/interfaces/IERC7579Account.sol\\\";\\nimport { IMSA } from \\\"erc7579/interfaces/IMSA.sol\\\";\\nimport {\\n    IModule as IERC7579Module,\\n    IValidator as IERC7579Validator,\\n    IExecutor as IERC7579Executor,\\n    IHook as IERC7579Hook,\\n    IFallback as IERC7579Fallback,\\n    MODULE_TYPE_VALIDATOR,\\n    MODULE_TYPE_EXECUTOR,\\n    MODULE_TYPE_HOOK,\\n    MODULE_TYPE_FALLBACK\\n} from \\\"erc7579/interfaces/IERC7579Module.sol\\\";\\n\\nimport {\\n    ModeLib as ERC7579ModeLib,\\n    ModeCode,\\n    CallType,\\n    ExecType,\\n    ModePayload,\\n    CALLTYPE_SINGLE,\\n    CALLTYPE_BATCH,\\n    CALLTYPE_DELEGATECALL,\\n    EXECTYPE_DEFAULT,\\n    MODE_DEFAULT,\\n    CALLTYPE_STATIC\\n} from \\\"erc7579/lib/ModeLib.sol\\\";\\nimport { Execution, ExecutionLib as ERC7579ExecutionLib } from \\\"erc7579/lib/ExecutionLib.sol\\\";\\n\\nimport {\\n    Bootstrap as ERC7579Bootstrap,\\n    BootstrapConfig as ERC7579BootstrapConfig\\n} from \\\"erc7579/utils/Bootstrap.sol\\\";\\n/* solhint-enable no-unused-import */\\n\",\"keccak256\":\"0x485f6b18d331a6a77ea7ae61d4a100e2bd4c3575e1acc46b83c9a512a7135f00\",\"license\":\"MIT\"},\"modulekit/integrations/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { IERC20 } from \\\"forge-std/interfaces/IERC20.sol\\\";\\nimport { Execution } from \\\"../Accounts.sol\\\";\\nimport { ERC7579Exec } from \\\"./ERC7579Exec.sol\\\";\\n\\nlibrary ERC20Integration {\\n    using ERC7579Exec for address;\\n\\n    error SafeERC20TransferFailed();\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 amount\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec0, Execution memory exec1)\\n    {\\n        exec0 = Execution({\\n            target: address(token),\\n            value: 0,\\n            callData: abi.encodeCall(IERC20.approve, (spender, 0))\\n        });\\n        exec1 = Execution({\\n            target: address(token),\\n            value: 0,\\n            callData: abi.encodeCall(IERC20.approve, (spender, amount))\\n        });\\n    }\\n\\n    function approve(\\n        IERC20 token,\\n        address spender,\\n        uint256 amount\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(token),\\n            value: 0,\\n            callData: abi.encodeCall(IERC20.approve, (spender, amount))\\n        });\\n    }\\n\\n    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\\n        safeTransfer(token, msg.sender, to, amount);\\n    }\\n\\n    function safeTransfer(IERC20 token, address account, address to, uint256 amount) internal {\\n        bytes memory ret = account.exec7579({\\n            to: address(token),\\n            value: 0,\\n            data: abi.encodeCall(IERC20.transfer, (to, amount))\\n        });\\n        if (ret.length != 0) {\\n            bool success = abi.decode(ret, (bool));\\n            if (!success) revert SafeERC20TransferFailed();\\n        }\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\\n        safeTransferFrom(token, msg.sender, from, to, amount);\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address account,\\n        address from,\\n        address to,\\n        uint256 amount\\n    )\\n        internal\\n    {\\n        bytes memory ret = account.exec7579({\\n            to: address(token),\\n            value: 0,\\n            data: abi.encodeCall(IERC20.transferFrom, (from, to, amount))\\n        });\\n\\n        bytes[] memory retValues = abi.decode(ret, (bytes[]));\\n        if (retValues[0].length != 0) {\\n            bool success = abi.decode(retValues[0], (bool));\\n            if (!success) revert SafeERC20TransferFailed();\\n        }\\n    }\\n\\n    function transfer(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(token),\\n            value: 0,\\n            callData: abi.encodeCall(IERC20.transfer, (to, amount))\\n        });\\n    }\\n\\n    function transferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(token),\\n            value: 0,\\n            callData: abi.encodeCall(IERC20.transferFrom, (from, to, amount))\\n        });\\n    }\\n}\\n\",\"keccak256\":\"0x9d7b52e2e6ec3a1a3490c33da159d6c8a3da811f74934dbc78373bebd8303279\",\"license\":\"MIT\"},\"modulekit/integrations/ERC4626.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { IERC4626 } from \\\"forge-std/interfaces/IERC4626.sol\\\";\\nimport { Execution } from \\\"../Accounts.sol\\\";\\n\\nlibrary ERC4626Integration {\\n    function deposit(\\n        IERC4626 vault,\\n        uint256 assets,\\n        address receiver\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(vault),\\n            value: 0,\\n            callData: abi.encodeCall(IERC4626.deposit, (assets, receiver))\\n        });\\n    }\\n\\n    function mint(\\n        IERC4626 vault,\\n        uint256 shares,\\n        address receiver\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(vault),\\n            value: 0,\\n            callData: abi.encodeCall(IERC4626.mint, (shares, receiver))\\n        });\\n    }\\n\\n    function withdraw(\\n        IERC4626 vault,\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(vault),\\n            value: 0,\\n            callData: abi.encodeCall(IERC4626.withdraw, (assets, receiver, owner))\\n        });\\n    }\\n\\n    function redeem(\\n        IERC4626 vault,\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(vault),\\n            value: 0,\\n            callData: abi.encodeCall(IERC4626.redeem, (shares, receiver, owner))\\n        });\\n    }\\n}\\n\",\"keccak256\":\"0xb6abc217507eb5400a9a3442a6dfc590f17828484409c011736165ddefff9d11\",\"license\":\"MIT\"},\"modulekit/integrations/ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport { IERC721 } from \\\"forge-std/interfaces/IERC721.sol\\\";\\nimport { Execution } from \\\"../Accounts.sol\\\";\\n\\nlibrary ERC721Integration {\\n    function approve(\\n        IERC721 token,\\n        address spender,\\n        uint256 tokenId\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(token),\\n            value: 0,\\n            callData: abi.encodeCall(IERC721.approve, (spender, tokenId))\\n        });\\n    }\\n\\n    function transferFrom(\\n        IERC721 token,\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    )\\n        internal\\n        pure\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: address(token),\\n            value: 0,\\n            callData: abi.encodeCall(IERC721.transferFrom, (from, to, tokenId))\\n        });\\n    }\\n}\\n\",\"keccak256\":\"0x8df645b376135530e56438175589ed57396a9f4495c2360685ead1cf5da39b76\",\"license\":\"MIT\"},\"modulekit/integrations/ERC7579Exec.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.25;\\n\\nimport \\\"../external/ERC7579.sol\\\";\\n\\nlibrary ERC7579Exec {\\n    function exec7579(\\n        address account,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    )\\n        internal\\n        returns (bytes memory result)\\n    {\\n        ModeCode modeCode = ERC7579ModeLib.encode({\\n            callType: CALLTYPE_SINGLE,\\n            execType: EXECTYPE_DEFAULT,\\n            mode: MODE_DEFAULT,\\n            payload: ModePayload.wrap(bytes22(0))\\n        });\\n\\n        return IERC7579Account(account).executeFromExecutor(\\n            modeCode, ERC7579ExecutionLib.encodeSingle(to, value, data)\\n        )[0];\\n    }\\n\\n    function exec7579(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    )\\n        internal\\n        returns (bytes memory result)\\n    {\\n        return exec7579(msg.sender, to, value, data);\\n    }\\n\\n    function exec7579(\\n        address account,\\n        Execution[] memory execs\\n    )\\n        internal\\n        returns (bytes[] memory results)\\n    {\\n        ModeCode modeCode = ERC7579ModeLib.encode({\\n            callType: CALLTYPE_BATCH,\\n            execType: EXECTYPE_DEFAULT,\\n            mode: MODE_DEFAULT,\\n            payload: ModePayload.wrap(bytes22(0))\\n        });\\n        results = IERC7579Account(account).executeFromExecutor(\\n            modeCode, ERC7579ExecutionLib.encodeBatch(execs)\\n        );\\n    }\\n\\n    function exec7579(Execution[] memory execs) internal returns (bytes[] memory results) {\\n        return exec7579(msg.sender, execs);\\n    }\\n\\n    // Note: Not every account will support delegatecalls\\n    function exec7579(\\n        address account,\\n        address delegateTarget,\\n        bytes memory callData\\n    )\\n        internal\\n        returns (bytes[] memory results)\\n    {\\n        ModeCode modeCode = ERC7579ModeLib.encode({\\n            callType: CALLTYPE_DELEGATECALL,\\n            execType: EXECTYPE_DEFAULT,\\n            mode: MODE_DEFAULT,\\n            payload: ModePayload.wrap(bytes22(0))\\n        });\\n        results = IERC7579Account(account).executeFromExecutor(\\n            modeCode, abi.encodePacked(delegateTarget, callData)\\n        );\\n    }\\n\\n    // Note: Not every account will support delegatecalls\\n    function exec7579(\\n        address delegateTarget,\\n        bytes memory callData\\n    )\\n        internal\\n        returns (bytes[] memory results)\\n    {\\n        return exec7579(msg.sender, delegateTarget, callData);\\n    }\\n}\\n\",\"keccak256\":\"0x4105e4d8e78e8ed28c92d70dcb551ae68a5763822e9a990164a2adc4f4d23143\",\"license\":\"AGPL-3.0-only\"},\"modulekit/integrations/interfaces/uniswap/v3/ISwapRouter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.4;\\npragma abicoder v2;\\n\\nimport { IUniswapV3SwapCallback } from \\\"./IUniswapV3SwapCallback.sol\\\";\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter is IUniswapV3SwapCallback {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in\\n    /// calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(\\n        ExactInputSingleParams calldata params\\n    )\\n        external\\n        payable\\n        returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified\\n    /// path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams`\\n    /// in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(\\n        ExactInputParams calldata params\\n    )\\n        external\\n        payable\\n        returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in\\n    /// calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(\\n        ExactOutputSingleParams calldata params\\n    )\\n        external\\n        payable\\n        returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the\\n    /// specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as\\n    /// `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(\\n        ExactOutputParams calldata params\\n    )\\n        external\\n        payable\\n        returns (uint256 amountIn);\\n}\\n\",\"keccak256\":\"0x69e1bac2845466d8117eb5855c84ee730c571c3a93d3066fb5c22755f50b6d5c\",\"license\":\"GPL-2.0-or-later\"},\"modulekit/integrations/interfaces/uniswap/v3/IUniswapV3Factory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\nabstract contract IUniswapV3Factory {\\n    function getPool(\\n        address token0,\\n        address token1,\\n        uint24 fee\\n    )\\n        external\\n        view\\n        virtual\\n        returns (address poolAddress);\\n}\\n\",\"keccak256\":\"0x4d305c2ff3c3350153da53f01e95d091648f561db67322b1af5e1eb418d03906\",\"license\":\"MIT\"},\"modulekit/integrations/interfaces/uniswap/v3/IUniswapV3Pool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\nabstract contract IUniswapV3Pool {\\n    struct Slot0 {\\n        // the current price\\n        uint160 sqrtPriceX96;\\n        // the current tick\\n        int24 tick;\\n        // the most-recently updated index of the observations array\\n        uint16 observationIndex;\\n        // the current maximum number of observations that are being stored\\n        uint16 observationCardinality;\\n        // the next maximum number of observations to store, triggered in observations.write\\n        uint16 observationCardinalityNext;\\n        // the current protocol fee as a percentage of the swap fee taken on withdrawal\\n        // represented as an integer denominator (1/x)%\\n        uint8 feeProtocol;\\n        // whether the pool is locked\\n        bool unlocked;\\n    }\\n\\n    function slot0() external view virtual returns (Slot0 memory);\\n\\n    function fee() external view virtual returns (uint24 fee);\\n\\n    function flash(\\n        address recipient,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes memory data\\n    )\\n        external\\n        virtual;\\n\\n    function token0() external view virtual returns (address);\\n    function token1() external view virtual returns (address);\\n}\\n\",\"keccak256\":\"0xe3bb1a1c66f5362d892b9dc81ac9560a951873116856268a25f6bf98609fbe9a\",\"license\":\"MIT\"},\"modulekit/integrations/interfaces/uniswap/v3/IUniswapV3SwapCallback.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical\\n    /// UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received\\n    /// (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received\\n    /// (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    )\\n        external;\\n}\\n\",\"keccak256\":\"0x923496e539a4b65b83344d901ad1402c5fe29258646ecfdd5e145d95bac3ee4b\",\"license\":\"GPL-2.0-or-later\"},\"modulekit/integrations/uniswap/helpers/MainnetAddresses.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\naddress payable constant SWAPROUTER_ADDRESS = payable(0xE592427A0AEce92De3Edee1F18E0157C05861564);\\nuint24 constant SWAPROUTER_DEFAULTFEE = 3000;\\naddress constant QUOTER_ADDRESS = 0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6;\\naddress constant FACTORY_ADDRESS = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\\n\",\"keccak256\":\"0xb116979986a1694219a669ed3b2dcd8802387d7f83ed3882b67190bfd8f74844\",\"license\":\"MIT\"},\"modulekit/integrations/uniswap/v3/Uniswap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.23;\\n\\nimport {\\n    SWAPROUTER_ADDRESS,\\n    SWAPROUTER_DEFAULTFEE,\\n    FACTORY_ADDRESS\\n} from \\\"../helpers/MainnetAddresses.sol\\\";\\nimport { ISwapRouter } from \\\"../../interfaces/uniswap/v3/ISwapRouter.sol\\\";\\nimport { IUniswapV3Factory } from \\\"../../interfaces/uniswap/v3/IUniswapV3Factory.sol\\\";\\nimport { IUniswapV3Pool } from \\\"../../interfaces/uniswap/v3/IUniswapV3Pool.sol\\\";\\nimport { IERC20 } from \\\"forge-std/interfaces/IERC20.sol\\\";\\nimport { ERC20Integration } from \\\"../../ERC20.sol\\\";\\nimport { Execution } from \\\"../../../Accounts.sol\\\";\\n\\n/// @author zeroknots\\nlibrary UniswapV3Integration {\\n    using ERC20Integration for IERC20;\\n\\n    error PoolDoesNotExist();\\n\\n    function approveAndSwap(\\n        address smartAccount,\\n        IERC20 tokenIn,\\n        IERC20 tokenOut,\\n        uint256 amountIn,\\n        uint160 sqrtPriceLimitX96\\n    )\\n        internal\\n        view\\n        returns (Execution[] memory exec)\\n    {\\n        exec = new Execution[](3);\\n        (exec[0], exec[1]) = ERC20Integration.safeApprove(tokenIn, SWAPROUTER_ADDRESS, amountIn);\\n        exec[2] = swapExactInputSingle(smartAccount, tokenIn, tokenOut, amountIn, sqrtPriceLimitX96);\\n    }\\n\\n    function swapExactInputSingle(\\n        address smartAccount,\\n        IERC20 tokenIn,\\n        IERC20 tokenOut,\\n        uint256 amountIn,\\n        uint160 sqrtPriceLimitX96\\n    )\\n        internal\\n        view\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: SWAPROUTER_ADDRESS,\\n            value: 0,\\n            callData: abi.encodeCall(\\n                ISwapRouter.exactInputSingle,\\n                (\\n                    ISwapRouter.ExactInputSingleParams({\\n                        tokenIn: address(tokenIn),\\n                        tokenOut: address(tokenOut),\\n                        fee: SWAPROUTER_DEFAULTFEE,\\n                        recipient: smartAccount,\\n                        deadline: block.timestamp,\\n                        amountIn: amountIn,\\n                        amountOutMinimum: 0,\\n                        sqrtPriceLimitX96: sqrtPriceLimitX96\\n                    })\\n                )\\n            )\\n        });\\n    }\\n\\n    function swapExactOutputSingle(\\n        address smartAccount,\\n        IERC20 tokenIn,\\n        IERC20 tokenOut,\\n        uint256 amountOut,\\n        uint256 amountInMaximum\\n    )\\n        internal\\n        view\\n        returns (Execution memory exec)\\n    {\\n        exec = Execution({\\n            target: SWAPROUTER_ADDRESS,\\n            value: 0,\\n            callData: abi.encodeCall(\\n                ISwapRouter.exactOutputSingle,\\n                (\\n                    ISwapRouter.ExactOutputSingleParams({\\n                        tokenIn: address(tokenIn),\\n                        tokenOut: address(tokenOut),\\n                        fee: SWAPROUTER_DEFAULTFEE,\\n                        recipient: smartAccount,\\n                        deadline: block.timestamp,\\n                        amountOut: amountOut,\\n                        amountInMaximum: amountInMaximum,\\n                        sqrtPriceLimitX96: 0\\n                    })\\n                )\\n            )\\n        });\\n    }\\n\\n    function getPoolAddress(\\n        address token0,\\n        address token1\\n    )\\n        public\\n        view\\n        returns (address poolAddress)\\n    {\\n        IUniswapV3Factory factory = IUniswapV3Factory(FACTORY_ADDRESS);\\n        address poolAddress = factory.getPool(token0, token1, SWAPROUTER_DEFAULTFEE);\\n        if (poolAddress == address(0)) {\\n            revert PoolDoesNotExist();\\n        }\\n        return poolAddress;\\n    }\\n\\n    function getSqrtPriceX96(address poolAddress) public view returns (uint160 sqrtPriceX96) {\\n        IUniswapV3Pool pool = IUniswapV3Pool(poolAddress);\\n        IUniswapV3Pool.Slot0 memory slot0 = pool.slot0();\\n        uint160 sqrtPriceX96 = slot0.sqrtPriceX96;\\n        return sqrtPriceX96;\\n    }\\n\\n    function sqrtPriceX96toPriceRatio(\\n        uint160 sqrtPriceX96\\n    )\\n        internal\\n        pure\\n        returns (uint256 priceRatio)\\n    {\\n        uint256 decodedSqrtPrice = sqrtPriceX96 / (2 ** 96);\\n        uint256 priceRatio = decodedSqrtPrice * decodedSqrtPrice;\\n        return priceRatio;\\n    }\\n\\n    function priceRatioToPrice(\\n        uint256 priceRatio,\\n        address poolAddress,\\n        address tokenSwappedFrom\\n    )\\n        internal\\n        view\\n        returns (uint256 price)\\n    {\\n        IUniswapV3Pool pool = IUniswapV3Pool(poolAddress);\\n        address poolToken0 = pool.token0();\\n        address poolToken1 = pool.token1();\\n        uint256 token0Decimals = IERC20(poolToken0).decimals();\\n        uint256 token1Decimals = IERC20(poolToken1).decimals();\\n\\n        bool swapToken0to1 = (tokenSwappedFrom == poolToken0);\\n        if (swapToken0to1) {\\n            price = 10 ** token1Decimals / priceRatio;\\n        } else {\\n            price = priceRatio * 10 ** token0Decimals;\\n        }\\n        return price;\\n    }\\n\\n    function priceRatioToSqrtPriceX96(uint256 priceRatio) internal pure returns (uint160) {\\n        uint256 sqrtPriceRatio = sqrt256(priceRatio * 1e18); // Scale priceRatio to 18 decimals for\\n            // precision\\n\\n        uint256 sqrtPriceX96 = (sqrtPriceRatio * 2 ** 96) / 1e9; // Adjust back from the scaling\\n\\n        return uint160(sqrtPriceX96);\\n    }\\n\\n    function checkTokenOrder(\\n        address tokenSwappedFrom,\\n        address poolAddress\\n    )\\n        internal\\n        view\\n        returns (bool swapToken0to1)\\n    {\\n        address poolToken0 = IUniswapV3Pool(poolAddress).token0();\\n        bool swapToken0to1 = (tokenSwappedFrom == poolToken0);\\n        return swapToken0to1;\\n    }\\n\\n    function sqrt256(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x00674841391db093b9af74bee6660a7ae603bc254b6b3706071b38bbbc5361c2\",\"license\":\"MIT\"},\"sentinellist/SentinelList.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\naddress constant SENTINEL = address(0x1);\\naddress constant ZERO_ADDRESS = address(0x0);\\n\\nlibrary SentinelListLib {\\n    struct SentinelList {\\n        mapping(address => address) entries;\\n    }\\n\\n    error LinkedList_AlreadyInitialized();\\n    error LinkedList_InvalidPage();\\n    error LinkedList_InvalidEntry(address entry);\\n    error LinkedList_EntryAlreadyInList(address entry);\\n\\n    function init(SentinelList storage self) internal {\\n        if (alreadyInitialized(self)) revert LinkedList_AlreadyInitialized();\\n        self.entries[SENTINEL] = SENTINEL;\\n    }\\n\\n    function alreadyInitialized(SentinelList storage self) internal view returns (bool) {\\n        return self.entries[SENTINEL] != ZERO_ADDRESS;\\n    }\\n\\n    function getNext(SentinelList storage self, address entry) internal view returns (address) {\\n        if (entry == ZERO_ADDRESS) {\\n            revert LinkedList_InvalidEntry(entry);\\n        }\\n        return self.entries[entry];\\n    }\\n\\n    function push(SentinelList storage self, address newEntry) internal {\\n        if (newEntry == ZERO_ADDRESS || newEntry == SENTINEL) {\\n            revert LinkedList_InvalidEntry(newEntry);\\n        }\\n        if (self.entries[newEntry] != ZERO_ADDRESS) revert LinkedList_EntryAlreadyInList(newEntry);\\n        self.entries[newEntry] = self.entries[SENTINEL];\\n        self.entries[SENTINEL] = newEntry;\\n    }\\n\\n    function pop(SentinelList storage self, address prevEntry, address popEntry) internal {\\n        if (popEntry == ZERO_ADDRESS || popEntry == SENTINEL) {\\n            revert LinkedList_InvalidEntry(prevEntry);\\n        }\\n        if (self.entries[prevEntry] != popEntry) revert LinkedList_InvalidEntry(popEntry);\\n        self.entries[prevEntry] = self.entries[popEntry];\\n        self.entries[popEntry] = ZERO_ADDRESS;\\n    }\\n\\n    function popAll(SentinelList storage self) internal {\\n        address next = self.entries[SENTINEL];\\n        while (next != ZERO_ADDRESS) {\\n            address current = next;\\n            next = self.entries[next];\\n            self.entries[current] = ZERO_ADDRESS;\\n        }\\n        self.entries[SENTINEL] = ZERO_ADDRESS;\\n    }\\n\\n    function contains(SentinelList storage self, address entry) internal view returns (bool) {\\n        return SENTINEL != entry && self.entries[entry] != ZERO_ADDRESS;\\n    }\\n\\n    function getEntriesPaginated(\\n        SentinelList storage self,\\n        address start,\\n        uint256 pageSize\\n    )\\n        internal\\n        view\\n        returns (address[] memory array, address next)\\n    {\\n        if (start != SENTINEL && !contains(self, start)) revert LinkedList_InvalidEntry(start);\\n        if (pageSize == 0) revert LinkedList_InvalidPage();\\n        // Init array with max page size\\n        array = new address[](pageSize);\\n\\n        // Populate return array\\n        uint256 entryCount = 0;\\n        next = self.entries[start];\\n        while (next != ZERO_ADDRESS && next != SENTINEL && entryCount < pageSize) {\\n            array[entryCount] = next;\\n            next = self.entries[next];\\n            entryCount++;\\n        }\\n\\n        /**\\n         * Because of the argument validation, we can assume that the loop will always iterate over\\n         * the valid entry list values\\n         *       and the `next` variable will either be an enabled entry or a sentinel address\\n         * (signalling the end).\\n         *\\n         *       If we haven't reached the end inside the loop, we need to set the next pointer to\\n         * the last element of the entry array\\n         *       because the `next` variable (which is a entry by itself) acting as a pointer to the\\n         * start of the next page is neither\\n         *       incSENTINELrent page, nor will it be included in the next one if you pass it as a\\n         * start.\\n         */\\n        if (next != SENTINEL && entryCount > 0) {\\n            next = array[entryCount - 1];\\n        }\\n        // Set correct size of returned array\\n        // solhint-disable-next-line no-inline-assembly\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(array, entryCount)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0fdb07d60acf6c8272517b2cf9a7ce36cef7dabd3acfc61e7424662818044da2\",\"license\":\"MIT\"},\"solady/utils/LibClone.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Minimal proxy library.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\\n/// @author Minimal proxy by 0age (https://github.com/0age)\\n/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie\\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\\n/// @author Minimal ERC1967 proxy by jtriley-eth (https://github.com/jtriley-eth/minimum-viable-proxy)\\n///\\n/// @dev Minimal proxy:\\n/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,\\n/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,\\n/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.\\n///\\n/// @dev Minimal proxy (PUSH0 variant):\\n/// This is a new minimal proxy that uses the PUSH0 opcode introduced during Shanghai.\\n/// It is optimized first for minimal runtime gas, then for minimal bytecode.\\n/// The PUSH0 clone functions are intentionally postfixed with a jarring \\\"_PUSH0\\\" as\\n/// many EVM chains may not support the PUSH0 opcode in the early months after Shanghai.\\n/// Please use with caution.\\n///\\n/// @dev Clones with immutable args (CWIA):\\n/// The implementation of CWIA here implements a `receive()` method that emits the\\n/// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,\\n/// enabling us to accept hard gas-capped `sends` & `transfers` for maximum backwards\\n/// composability. The minimal proxy implementation does not offer this feature.\\n///\\n/// @dev Minimal ERC1967 proxy:\\n/// An minimal ERC1967 proxy, intended to be upgraded with UUPS.\\n/// This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\\n/// This proxy is automatically verified on Etherscan.\\n///\\n/// @dev ERC1967I proxy:\\n/// An variant of the minimal ERC1967 proxy, with a special code path that activates\\n/// if `calldatasize() == 1`. This code path skips the delegatecall and directly returns the\\n/// `implementation` address. The returned implementation is guaranteed to be valid if the\\n/// keccak256 of the proxy's code is equal to `ERC1967I_CODE_HASH`.\\nlibrary LibClone {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The keccak256 of the deployed code for the ERC1967 proxy.\\n    bytes32 internal constant ERC1967_CODE_HASH =\\n        0xaaa52c8cc8a0e3fd27ce756cc6b4e70c51423e9b597b11f32d3e49f8b1fc890d;\\n\\n    /// @dev The keccak256 of the deployed code for the ERC1967I proxy.\\n    bytes32 internal constant ERC1967I_CODE_HASH =\\n        0xce700223c0d4cea4583409accfc45adac4a093b3519998a9cbbe1504dadba6f7;\\n\\n    /// @dev The keccak256 of the deployed code for the ERC1967 beacon proxy.\\n    bytes32 internal constant ERC1967_BEACON_PROXY_CODE_HASH =\\n        0x14044459af17bc4f0f5aa2f658cb692add77d1302c29fe2aebab005eea9d1162;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Unable to deploy the clone.\\n    error DeploymentFailed();\\n\\n    /// @dev The salt must start with either the zero address or `by`.\\n    error SaltDoesNotStartWith();\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                  MINIMAL PROXY OPERATIONS                  */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Deploys a clone of `implementation`.\\n    function clone(address implementation) internal returns (address instance) {\\n        instance = clone(0, implementation);\\n    }\\n\\n    /// @dev Deploys a clone of `implementation`.\\n    /// Deposits `value` ETH during deployment.\\n    function clone(uint256 value, address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * --------------------------------------------------------------------------+\\n             * CREATION (9 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\\n             * --------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize     | r         |                              |\\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\\n             * 81         | DUP2              | r 0 r     |                              |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\\n             * --------------------------------------------------------------------------|\\n             * RUNTIME (44 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\\n             * --------------------------------------------------------------------------|\\n             *                                                                           |\\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | 0                      |                       |\\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\\n             *                                                                           |\\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\\n             *                                                                           |\\n             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * fd      | REVERT         |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\\n             * f3      | RETURN         |                        | [0..rds): returndata  |\\n             * --------------------------------------------------------------------------+\\n             */\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            instance := create(value, 0x0c, 0x35)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\\n    function cloneDeterministic(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = cloneDeterministic(0, implementation, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    function cloneDeterministic(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            instance := create2(value, 0x0c, 0x35, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code of the clone of `implementation`.\\n    function initCode(address implementation) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(add(result, 0x40), 0x5af43d3d93803e602a57fd5bf30000000000000000000000)\\n            mstore(add(result, 0x28), implementation)\\n            mstore(add(result, 0x14), 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            mstore(result, 0x35) // Store the length.\\n            mstore(0x40, add(result, 0x60)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            hash := keccak256(0x0c, 0x35)\\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic clone of `implementation`,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)\\n        internal\\n        pure\\n        returns (address predicted)\\n    {\\n        bytes32 hash = initCodeHash(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*          MINIMAL PROXY OPERATIONS (PUSH0 VARIANT)          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Deploys a PUSH0 clone of `implementation`.\\n    function clone_PUSH0(address implementation) internal returns (address instance) {\\n        instance = clone_PUSH0(0, implementation);\\n    }\\n\\n    /// @dev Deploys a PUSH0 clone of `implementation`.\\n    /// Deposits `value` ETH during deployment.\\n    function clone_PUSH0(uint256 value, address implementation)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * --------------------------------------------------------------------------+\\n             * CREATION (9 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\\n             * --------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize     | r         |                              |\\n             * 5f         | PUSH0             | 0 r       |                              |\\n             * 81         | DUP2              | r 0 r     |                              |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\\n             * 5f         | PUSH0             | 0 o r 0 r |                              |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\\n             * --------------------------------------------------------------------------|\\n             * RUNTIME (45 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\\n             * --------------------------------------------------------------------------|\\n             *                                                                           |\\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5f      | PUSH0          | 0                      |                       |\\n             * 5f      | PUSH0          | 0 0                    |                       |\\n             *                                                                           |\\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0                |                       |\\n             * 5f      | PUSH0          | 0 cds 0 0              |                       |\\n             * 5f      | PUSH0          | 0 0 cds 0 0            |                       |\\n             * 37      | CALLDATACOPY   | 0 0                    | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0                | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 cds 0 0              | [0..cds): calldata    |\\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0         | [0..cds): calldata    |\\n             * 5a      | GAS            | gas addr 0 cds 0 0     | [0..cds): calldata    |\\n             * f4      | DELEGATECALL   | success                | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds success            | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 rds success          | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 0 rds success        | [0..cds): calldata    |\\n             * 3e      | RETURNDATACOPY | success                | [0..rds): returndata  |\\n             *                                                                           |\\n             * 60 0x29 | PUSH1 0x29     | 0x29 success           | [0..rds): returndata  |\\n             * 57      | JUMPI          |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\\n             * fd      | REVERT         |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b      | JUMPDEST       |                        | [0..rds): returndata  |\\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\\n             * f3      | RETURN         |                        | [0..rds): returndata  |\\n             * --------------------------------------------------------------------------+\\n             */\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            instance := create(value, 0x0e, 0x36)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\\n    function cloneDeterministic_PUSH0(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = cloneDeterministic_PUSH0(0, implementation, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    function cloneDeterministic_PUSH0(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            instance := create2(value, 0x0e, 0x36, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code of the PUSH0 clone of `implementation`.\\n    function initCode_PUSH0(address implementation) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(add(result, 0x40), 0x5af43d5f5f3e6029573d5ffd5b3d5ff300000000000000000000) // 16\\n            mstore(add(result, 0x26), implementation) // 20\\n            mstore(add(result, 0x12), 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            mstore(result, 0x36) // Store the length.\\n            mstore(0x40, add(result, 0x60)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the PUSH0 clone of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash_PUSH0(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            hash := keccak256(0x0e, 0x36)\\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic PUSH0 clone of `implementation`,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress_PUSH0(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHash_PUSH0(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*           CLONES WITH IMMUTABLE ARGS OPERATIONS            */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: This implementation of CWIA differs from the original implementation.\\n    // If the calldata is empty, it will emit a `ReceiveETH(uint256)` event and skip the `DELEGATECALL`.\\n\\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.\\n    function clone(address implementation, bytes memory data) internal returns (address instance) {\\n        instance = clone(0, implementation, data);\\n    }\\n\\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.\\n    /// Deposits `value` ETH during deployment.\\n    function clone(uint256 value, address implementation, bytes memory data)\\n        internal\\n        returns (address instance)\\n    {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n            // The `creationSize` is `extraLength + 108`\\n            // The `runSize` is `creationSize - 10`.\\n\\n            /**\\n             * ---------------------------------------------------------------------------------------------------+\\n             * CREATION (10 bytes)                                                                                |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                                                |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * 61 runSize | PUSH2 runSize     | r         |                                                       |\\n             * 3d         | RETURNDATASIZE    | 0 r       |                                                       |\\n             * 81         | DUP2              | r 0 r     |                                                       |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                                                       |\\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                                                       |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code                            |\\n             * f3         | RETURN            |           | [0..runSize): runtime code                            |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * RUNTIME (98 bytes + extraLength)                                                                   |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * Opcode   | Mnemonic       | Stack                    | Memory                                      |\\n             * ---------------------------------------------------------------------------------------------------|\\n             *                                                                                                    |\\n             * ::: if no calldata, emit event & return w/o `DELEGATECALL` ::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds                      |                                             |\\n             * 60 0x2c  | PUSH1 0x2c     | 0x2c cds                 |                                             |\\n             * 57       | JUMPI          |                          |                                             |\\n             * 34       | CALLVALUE      | cv                       |                                             |\\n             * 3d       | RETURNDATASIZE | 0 cv                     |                                             |\\n             * 52       | MSTORE         |                          | [0..0x20): callvalue                        |\\n             * 7f sig   | PUSH32 0x9e..  | sig                      | [0..0x20): callvalue                        |\\n             * 59       | MSIZE          | 0x20 sig                 | [0..0x20): callvalue                        |\\n             * 3d       | RETURNDATASIZE | 0 0x20 sig               | [0..0x20): callvalue                        |\\n             * a1       | LOG1           |                          | [0..0x20): callvalue                        |\\n             * 00       | STOP           |                          | [0..0x20): callvalue                        |\\n             * 5b       | JUMPDEST       |                          |                                             |\\n             *                                                                                                    |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds                      |                                             |\\n             * 3d       | RETURNDATASIZE | 0 cds                    |                                             |\\n             * 3d       | RETURNDATASIZE | 0 0 cds                  |                                             |\\n             * 37       | CALLDATACOPY   |                          | [0..cds): calldata                          |\\n             *                                                                                                    |\\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d       | RETURNDATASIZE | 0                        | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0                      | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0 0                    | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0 0 0                  | [0..cds): calldata                          |\\n             * 61 extra | PUSH2 extra    | e 0 0 0 0                | [0..cds): calldata                          |\\n             *                                                                                                    |\\n             * ::: copy extra data to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 80       | DUP1           | e e 0 0 0 0              | [0..cds): calldata                          |\\n             * 60 0x62  | PUSH1 0x62     | 0x62 e e 0 0 0 0         | [0..cds): calldata                          |\\n             * 36       | CALLDATASIZE   | cds 0x62 e e 0 0 0 0     | [0..cds): calldata                          |\\n             * 39       | CODECOPY       | e 0 0 0 0                | [0..cds): calldata, [cds..cds+e): extraData |\\n             *                                                                                                    |\\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 01       | ADD            | cds+e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3d       | RETURNDATASIZE | 0 cds+e 0 0 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 73 addr  | PUSH20 addr    | addr 0 cds+e 0 0 0 0     | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 5a       | GAS            | gas addr 0 cds+e 0 0 0 0 | [0..cds): calldata, [cds..cds+e): extraData |\\n             * f4       | DELEGATECALL   | success 0 0              | [0..cds): calldata, [cds..cds+e): extraData |\\n             *                                                                                                    |\\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d       | RETURNDATASIZE | rds success 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3d       | RETURNDATASIZE | rds rds success 0 0      | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 93       | SWAP4          | 0 rds success 0 rds      | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 80       | DUP1           | 0 0 rds success 0 rds    | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3e       | RETURNDATACOPY | success 0 rds            | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * 60 0x60  | PUSH1 0x60     | 0x60 success 0 rds       | [0..rds): returndata                        |\\n             * 57       | JUMPI          | 0 rds                    | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * fd       | REVERT         |                          | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b       | JUMPDEST       | 0 rds                    | [0..rds): returndata                        |\\n             * f3       | RETURN         |                          | [0..rds): returndata                        |\\n             * ---------------------------------------------------------------------------------------------------+\\n             */\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\\n                // The actual EVM limit may be smaller and may change over time.\\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            instance := create(value, sub(data, 0x4c), add(extraLength, 0x6c))\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation`\\n    /// with immutable arguments encoded in `data` and `salt`.\\n    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = cloneDeterministic(0, implementation, data, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation`\\n    /// with immutable arguments encoded in `data` and `salt`.\\n    function cloneDeterministic(\\n        uint256 value,\\n        address implementation,\\n        bytes memory data,\\n        bytes32 salt\\n    ) internal returns (address instance) {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\\n                // The actual EVM limit may be smaller and may change over time.\\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            instance := create2(value, sub(data, 0x4c), add(extraLength, 0x6c), salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`\\n    /// using immutable arguments encoded in `data`.\\n    function initCode(address implementation, bytes memory data)\\n        internal\\n        pure\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let dataLength := mload(data)\\n\\n            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.\\n            // The actual EVM limit may be smaller and may change over time.\\n            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))\\n\\n            let o := add(result, 0x8c)\\n            let end := add(o, dataLength)\\n\\n            // Copy the `data` into `result`.\\n            for { let d := sub(add(data, 0x20), o) } 1 {} {\\n                mstore(o, mload(add(o, d)))\\n                o := add(o, 0x20)\\n                if iszero(lt(o, end)) { break }\\n            }\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            mstore(add(result, 0x6c), 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\\n            mstore(add(result, 0x5f), implementation) // Write the address of the implementation.\\n            // Write the rest of the bytecode.\\n            mstore(\\n                add(result, 0x4b),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                add(result, 0x32),\\n                0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                add(result, 0x12),\\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(end, shl(0xf0, extraLength))\\n            mstore(add(end, 0x02), 0) // Zeroize the slot after the result.\\n            mstore(result, add(extraLength, 0x6c)) // Store the length.\\n            mstore(0x40, add(0x22, end)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`\\n    /// using immutable arguments encoded in `data`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash(address implementation, bytes memory data)\\n        internal\\n        pure\\n        returns (bytes32 hash)\\n    {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.\\n            // The actual EVM limit may be smaller and may change over time.\\n            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                sub(data, 0x5a),\\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic clone of\\n    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes memory data,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHash(implementation, data);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*              MINIMAL ERC1967 PROXY OPERATIONS              */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: The ERC1967 proxy here is intended to be upgraded with UUPS.\\n    // This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\\n\\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\\n    function deployERC1967(address implementation) internal returns (address instance) {\\n        instance = deployERC1967(0, implementation);\\n    }\\n\\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\\n    /// Deposits `value` ETH during deployment.\\n    function deployERC1967(uint256 value, address implementation)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * ---------------------------------------------------------------------------------+\\n             * CREATION (34 bytes)                                                              |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\\n             * 81         | DUP2           | r 0 r            |                                 |\\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\\n             * ---------------------------------------------------------------------------------|\\n             * RUNTIME (61 bytes)                                                               |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             *                                                                                  |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36         | CALLDATASIZE   | cds              |                                 |\\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | 0                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 60 0x38    | PUSH1 0x38     | dest succ        | [0..returndatasize): returndata |\\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\\n             * ---------------------------------------------------------------------------------+\\n             */\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\\n            mstore(0x20, 0x6009)\\n            mstore(0x1e, implementation)\\n            mstore(0x0a, 0x603d3d8160223d3973)\\n            instance := create(value, 0x21, 0x5f)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\\n    function deployDeterministicERC1967(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = deployDeterministicERC1967(0, implementation, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    function deployDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\\n            mstore(0x20, 0x6009)\\n            mstore(0x1e, implementation)\\n            mstore(0x0a, 0x603d3d8160223d3973)\\n            instance := create2(value, 0x21, 0x5f, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967(address implementation, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        return createDeterministicERC1967(0, implementation, salt);\\n    }\\n\\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\\n            mstore(0x20, 0x6009)\\n            mstore(0x1e, implementation)\\n            mstore(0x0a, 0x603d3d8160223d3973)\\n            // Compute and store the bytecode hash.\\n            mstore(add(m, 0x35), keccak256(0x21, 0x5f))\\n            mstore(m, shl(88, address()))\\n            mstore8(m, 0xff) // Write the prefix.\\n            mstore(add(m, 0x15), salt)\\n            instance := keccak256(m, 0x55)\\n            for {} 1 {} {\\n                if iszero(extcodesize(instance)) {\\n                    instance := create2(value, 0x21, 0x5f, salt)\\n                    if iszero(instance) {\\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    break\\n                }\\n                alreadyDeployed := 1\\n                if iszero(value) { break }\\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                break\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation`.\\n    function initCodeERC1967(address implementation) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(\\n                add(result, 0x60),\\n                0x3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f300\\n            )\\n            mstore(\\n                add(result, 0x40),\\n                0x55f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076cc\\n            )\\n            mstore(add(result, 0x20), or(shl(24, implementation), 0x600951))\\n            mstore(add(result, 0x09), 0x603d3d8160223d3973)\\n            mstore(result, 0x5f) // Store the length.\\n            mstore(0x40, add(result, 0x80)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHashERC1967(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\\n            mstore(0x20, 0x6009)\\n            mstore(0x1e, implementation)\\n            mstore(0x0a, 0x603d3d8160223d3973)\\n            hash := keccak256(0x21, 0x5f)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic ERC1967 proxy of `implementation`,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddressERC1967(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHashERC1967(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                 ERC1967I PROXY OPERATIONS                  */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: This proxy has a special code path that activates if `calldatasize() == 1`.\\n    // This code path skips the delegatecall and directly returns the `implementation` address.\\n    // The returned implementation is guaranteed to be valid if the keccak256 of the\\n    // proxy's code is equal to `ERC1967I_CODE_HASH`.\\n\\n    /// @dev Deploys a minimal ERC1967I proxy with `implementation`.\\n    function deployERC1967I(address implementation) internal returns (address instance) {\\n        instance = deployERC1967I(0, implementation);\\n    }\\n\\n    /// @dev Deploys a ERC1967I proxy with `implementation`.\\n    /// Deposits `value` ETH during deployment.\\n    function deployERC1967I(uint256 value, address implementation)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * ---------------------------------------------------------------------------------+\\n             * CREATION (34 bytes)                                                              |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\\n             * 81         | DUP2           | r 0 r            |                                 |\\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\\n             * ---------------------------------------------------------------------------------|\\n             * RUNTIME (82 bytes)                                                               |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             *                                                                                  |\\n             * ::: check calldatasize ::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36         | CALLDATASIZE   | cds              |                                 |\\n             * 58         | PC             | 1 cds            |                                 |\\n             * 14         | EQ             | eqs              |                                 |\\n             * 60 0x43    | PUSH1 0x43     | dest eqs         |                                 |\\n             * 57         | JUMPI          |                  |                                 |\\n             *                                                                                  |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36         | CALLDATASIZE   | cds              |                                 |\\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | 0                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 60 0x3E    | PUSH1 0x3E     | dest succ        | [0..returndatasize): returndata |\\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: implementation , return :::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b         | JUMPDEST       |                  |                                 |\\n             * 60 0x20    | PUSH1 0x20     | 32               |                                 |\\n             * 60 0x0F    | PUSH1 0x0F     | o 32             |                                 |\\n             * 3d         | RETURNDATASIZE | 0 o 32           |                                 |\\n             * 39         | CODECOPY       |                  | [0..32): implementation slot    |\\n             * 3d         | RETURNDATASIZE | 0                | [0..32): implementation slot    |\\n             * 51         | MLOAD          | slot             | [0..32): implementation slot    |\\n             * 54         | SLOAD          | impl             | [0..32): implementation slot    |\\n             * 3d         | RETURNDATASIZE | 0 impl           | [0..32): implementation slot    |\\n             * 52         | MSTORE         |                  | [0..32): implementation address |\\n             * 59         | MSIZE          | 32               | [0..32): implementation address |\\n             * 3d         | RETURNDATASIZE | 0 32             | [0..32): implementation address |\\n             * f3         | RETURN         |                  | [0..32): implementation address |\\n             * ---------------------------------------------------------------------------------+\\n             */\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\\n            instance := create(value, 0x0c, 0x74)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.\\n    function deployDeterministicERC1967I(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = deployDeterministicERC1967I(0, implementation, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    function deployDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\\n            instance := create2(value, 0x0c, 0x74, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967I(address implementation, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        return createDeterministicERC1967I(0, implementation, salt);\\n    }\\n\\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\\n            // Compute and store the bytecode hash.\\n            mstore(add(m, 0x35), keccak256(0x0c, 0x74))\\n            mstore(m, shl(88, address()))\\n            mstore8(m, 0xff) // Write the prefix.\\n            mstore(add(m, 0x15), salt)\\n            instance := keccak256(m, 0x55)\\n            for {} 1 {} {\\n                if iszero(extcodesize(instance)) {\\n                    instance := create2(value, 0x0c, 0x74, salt)\\n                    if iszero(instance) {\\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    break\\n                }\\n                alreadyDeployed := 1\\n                if iszero(value) { break }\\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                break\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation`.\\n    function initCodeERC1967I(address implementation) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(\\n                add(result, 0x74),\\n                0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3\\n            )\\n            mstore(\\n                add(result, 0x54),\\n                0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4\\n            )\\n            mstore(add(result, 0x34), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\\n            mstore(add(result, 0x1d), implementation)\\n            mstore(add(result, 0x09), 0x60523d8160223d3973)\\n            mstore(add(result, 0x94), 0)\\n            mstore(result, 0x74) // Store the length.\\n            mstore(0x40, add(result, 0xa0)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHashERC1967I(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\\n            hash := keccak256(0x0c, 0x74)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic ERC1967I proxy of `implementation`,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddressERC1967I(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHashERC1967I(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*            CONSTANT ERC1967 BOOTSTRAP OPERATIONS           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: This enables an ERC1967 proxy to be deployed at a deterministic address\\n    // independent of the implementation:\\n    // ```\\n    //     address bootstrap = LibClone.constantERC1967Bootstrap();\\n    //     address instance = LibClone.deployDeterministicERC1967(0, bootstrap, salt);\\n    //     LibClone.bootstrapConstantERC1967(bootstrap, implementation);\\n    // ```\\n\\n    /// @dev Deploys the constant ERC1967 bootstrap if it has not been deployed.\\n    function constantERC1967Bootstrap() internal returns (address bootstrap) {\\n        bootstrap = constantERC1967BootstrapAddress();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(extcodesize(bootstrap)) {\\n                mstore(0x20, 0x0894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc55)\\n                mstore(0x00, 0x60258060093d393df358357f36)\\n                if iszero(create2(0, 0x13, 0x2e, 0)) {\\n                    mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the implementation address of the ERC1967 bootstrap for this contract.\\n    function constantERC1967BootstrapAddress() internal view returns (address bootstrap) {\\n        bytes32 hash = 0xfe1a42b9c571a6a8c083c94ac67b9cfd74e2582923426aa3b762e3431d717cd1;\\n        bootstrap = predictDeterministicAddress(hash, bytes32(0), address(this));\\n    }\\n\\n    /// @dev Replaces the implementation at `instance`.\\n    function bootstrapERC1967(address instance, address implementation) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, shr(96, shl(96, implementation)))\\n            if iszero(call(gas(), instance, 0, 0x00, 0x20, codesize(), 0x00)) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*          MINIMAL ERC1967 BEACON PROXY OPERATIONS           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // Note: If you use this proxy, you MUST make sure that the beacon is a\\n    // valid ERC1967 beacon. This means that the beacon must always return a valid\\n    // address upon a staticcall to `implementation()`, given sufficient gas.\\n    // For performance, the deployment operations and the proxy assumes that the\\n    // beacon is always valid and will NOT validate it.\\n\\n    /// @dev Deploys a minimal ERC1967 beacon proxy.\\n    function deployERC1967BeaconProxy(address beacon) internal returns (address instance) {\\n        instance = deployERC1967BeaconProxy(0, beacon);\\n    }\\n\\n    /// @dev Deploys a minimal ERC1967 beacon proxy.\\n    /// Deposits `value` ETH during deployment.\\n    function deployERC1967BeaconProxy(uint256 value, address beacon)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * ---------------------------------------------------------------------------------+\\n             * CREATION (34 bytes)                                                              |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\\n             * 81         | DUP2           | r 0 r            |                                 |\\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\\n             * 73 beac    | PUSH20 beac    | beac 0 r         | [0..runSize): runtime code      |\\n             * 60 slotPos | PUSH1 slotPos  | slotPos beac 0 r | [0..runSize): runtime code      |\\n             * 51         | MLOAD          | slot beac 0 r    | [0..runSize): runtime code      |\\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\\n             * ---------------------------------------------------------------------------------|\\n             * RUNTIME (82 bytes)                                                               |\\n             * ---------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\\n             * ---------------------------------------------------------------------------------|\\n             *                                                                                  |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36         | CALLDATASIZE   | cds              |                                 |\\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | 0                |                                 |\\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ~~~~~~~ beacon staticcall sub procedure ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\\n             * 60 0x20       | PUSH1 0x20       | 32                          |                 |\\n             * 36            | CALLDATASIZE     | cds 32                      |                 |\\n             * 60 0x04       | PUSH1 0x04       | 4 cds 32                    |                 |\\n             * 36            | CALLDATASIZE     | cds 4 cds 32                |                 |\\n             * 63 0x5c60da1b | PUSH4 0x5c60da1b | 0x5c60da1b cds 4 cds 32     |                 |\\n             * 60 0xe0       | PUSH1 0xe0       | 224 0x5c60da1b cds 4 cds 32 |                 |\\n             * 1b            | SHL              | sel cds 4 cds 32            |                 |\\n             * 36            | CALLDATASIZE     | cds sel cds 4 cds 32        |                 |\\n             * 52            | MSTORE           | cds 4 cds 32                | sel             |\\n             * 7f slot       | PUSH32 slot      | s cds 4 cds 32              | sel             |\\n             * 54            | SLOAD            | beac cds 4 cds 32           | sel             |\\n             * 5a            | GAS              | g beac cds 4 cds 32         | sel             |\\n             * fa            | STATICCALL       | succ                        | impl            |\\n             * 50            | POP              |                             | impl            |\\n             * 36            | CALLDATASIZE     | cds                         | impl            |\\n             * 51            | MLOAD            | impl                        | impl            |\\n             * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\\n             * 5a         | GAS            | g impl 0 cds 0 0 | [0..calldatasize): calldata     |\\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\\n             *                                                                                  |\\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 60 0x4d    | PUSH1 0x4d     | dest succ        | [0..returndatasize): returndata |\\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\\n             *                                                                                  |\\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\\n             * ---------------------------------------------------------------------------------+\\n             */\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\\n            instance := create(value, 0x0c, 0x74)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic minimal ERC1967 beacon proxy with `salt`.\\n    function deployDeterministicERC1967BeaconProxy(address beacon, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        instance = deployDeterministicERC1967BeaconProxy(0, beacon, salt);\\n    }\\n\\n    /// @dev Deploys a deterministic minimal ERC1967 beacon proxy with `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    function deployDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\\n            instance := create2(value, 0x0c, 0x74, salt)\\n            if iszero(instance) {\\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                revert(0x1c, 0x04)\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Creates a deterministic minimal ERC1967 beacon proxy with `salt`.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967BeaconProxy(address beacon, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        return createDeterministicERC1967BeaconProxy(0, beacon, salt);\\n    }\\n\\n    /// @dev Creates a deterministic minimal ERC1967 beacon proxy with `salt`.\\n    /// Deposits `value` ETH during deployment.\\n    /// Note: This method is intended for use in ERC4337 factories,\\n    /// which are expected to NOT revert if the proxy is already deployed.\\n    function createDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes32 salt)\\n        internal\\n        returns (bool alreadyDeployed, address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\\n            // Compute and store the bytecode hash.\\n            mstore(add(m, 0x35), keccak256(0x0c, 0x74))\\n            mstore(m, shl(88, address()))\\n            mstore8(m, 0xff) // Write the prefix.\\n            mstore(add(m, 0x15), salt)\\n            instance := keccak256(m, 0x55)\\n            for {} 1 {} {\\n                if iszero(extcodesize(instance)) {\\n                    instance := create2(value, 0x0c, 0x74, salt)\\n                    if iszero(instance) {\\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\\n                        revert(0x1c, 0x04)\\n                    }\\n                    break\\n                }\\n                alreadyDeployed := 1\\n                if iszero(value) { break }\\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                break\\n            }\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code of the minimal ERC1967 beacon proxy.\\n    function initCodeERC1967BeaconProxy(address beacon)\\n        internal\\n        pure\\n        returns (bytes memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            mstore(\\n                add(result, 0x74),\\n                0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3\\n            )\\n            mstore(\\n                add(result, 0x54),\\n                0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c\\n            )\\n            mstore(add(result, 0x34), 0x60195155f3363d3d373d3d363d602036600436635c60da)\\n            mstore(add(result, 0x1d), beacon)\\n            mstore(add(result, 0x09), 0x60523d8160223d3973)\\n            mstore(add(result, 0x94), 0)\\n            mstore(result, 0x74) // Store the length.\\n            mstore(0x40, add(result, 0xa0)) // Allocate memory.\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the minimal ERC1967 beacon proxy.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHashERC1967BeaconProxy(address beacon) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\\n            hash := keccak256(0x0c, 0x74)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero slot.\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic ERC1967 beacon proxy,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddressERC1967BeaconProxy(\\n        address beacon,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHashERC1967BeaconProxy(beacon);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      OTHER OPERATIONS                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the address when a contract with initialization code hash,\\n    /// `hash`, is deployed with `salt`, by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\\n        internal\\n        pure\\n        returns (address predicted)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and store the bytecode hash.\\n            mstore8(0x00, 0xff) // Write the prefix.\\n            mstore(0x35, hash)\\n            mstore(0x01, shl(96, deployer))\\n            mstore(0x15, salt)\\n            predicted := keccak256(0x00, 0x55)\\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Requires that `salt` starts with either the zero address or `by`.\\n    function checkStartsWith(bytes32 salt, address by) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the salt does not start with the zero address or `by`.\\n            if iszero(or(iszero(shr(96, salt)), eq(shr(96, shl(96, by)), shr(96, salt)))) {\\n                mstore(0x00, 0x0c4549ef) // `SaltDoesNotStartWith()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xeef85d149b91730bbcf9a657bcd716de80ad0919b9e085beb9c018eb451c0aa1\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608080604052346015576115b3908161001b8239f35b600080fdfe608080604052600436101561001357600080fd5b60003560e01c90816306fdde03146110da5750806337d0f1eb14610f0d578063450efe2114610e91578063541e683314610e5957806354fd4d5014610df757806361d9a3001461070f5780636d61fe70146103e55780638a91b0e3146102c7578063cbf75c9a14610242578063d60b347f146101e8578063e1f2f9fb146100c85763ecd05961146100a357600080fd5b346100c35760203660031901126100c35760206040516002600435148152f35b600080fd5b346100c35760403660031901126100c3576100e161117e565b6100e9611194565b903360005260006020526040600020916001600160a01b03809116928360005260205260006001604082208281550155336000526001602052604060002091831580156101de575b6101c5578116918260005280602052838260406000205416036101ad5783600052602052604060002054169060005260406000206001600160a01b03199182825416179055816000526040600020908154169055337f5d29cb23b5ad294992752fd5187119f150168eb0673b9d5d8599deab0e4d7df4600080a3005b60248460405190637c84ecfb60e01b82526004820152fd5b60249160405191637c84ecfb60e01b8352166004820152fd5b5060018414610131565b346100c35760203660031901126100c3576001600160a01b0361020961117e565b1660005260016020526020610238604060002060016000526020526001600160a01b0360406000205416151590565b6040519015158152f35b346100c35760403660031901126100c357606061025d61117e565b610265611194565b6001600160a01b03809216600052600060205281604060002091166000526020526040600020906fffffffffffffffffffffffffffffffff6001835493015416906040519267ffffffffffffffff8116845260401c1660208301526040820152f35b346100c3576102d53661124b565b505033600052600160208181526102ef6040600020611389565b508051908360005b8381106103ab57508333600052818152604060002091806000528282526001600160a01b03818160406000205416905b61036d575b50506000525260406000206001600160a01b03198154169055337f9d00629762554452d03c3b45626436df6ca1c3795d05d04df882f6db481b1be0600080a2005b8181169081156103a5579060005284845281806040600020541691166000528260406000206001600160a01b03198154169055610327565b5061032c565b336000526000855260406000206001600160a01b036103ca83866112a5565b511660005285526000826040822082815501550184906102f7565b346100c3576103f33661124b565b810160209081838203126100c357823567ffffffffffffffff938482116100c3570181601f820112156100c357803561042b816112b9565b926104396040519485611212565b818452848085019260071b840101928184116100c3578501915b838310610678575050505033600052600192838352604060002091846000528284526001600160a01b0392836040600020541661064e578560005284526040600020856001600160a01b0319825416179055805193606485116106245760005b8581106104e257337f27b541a16df0902e262f34789782092ab25125513b8ed73608e802951771b928600080a2005b846104ed82856112a5565b5151169084836104fd83876112a5565b5101511686604061050e84886112a5565b51015116926fffffffffffffffffffffffffffffffff806060610531868a6112a5565b510151169060405193610543856111be565b84528684019586526040840191808352156105fa578b6105f49481973360005260008a526040600020866000528a528b60406000209251167fffffffff000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffff00000000000000008454935160401b16921617178155019151166fffffffffffffffffffffffffffffffff198254161790553360005283855260406000206112d1565b016104b3565b60046040517f8582dc3d000000000000000000000000000000000000000000000000000000008152fd5b60046040517f748e67b2000000000000000000000000000000000000000000000000000000008152fd5b60046040517f53c85e66000000000000000000000000000000000000000000000000000000008152fd5b60809081848403126100c357604051918201828110898211176106f9576040526106a1846111aa565b82528684013588811681036100c357878301526106c0604085016111aa565b604083015260609081850135926fffffffffffffffffffffffffffffffff841684036100c3576080938993820152815201920191610453565b634e487b7160e01b600052604160045260246000fd5b346100c35760403660031901126100c35761072861117e565b33600052600060205260406000206001600160a01b0382166000526020526040600020604051610757816111be565b60016001600160a01b03835467ffffffffffffffff8116845260401c16928360208401526fffffffffffffffffffffffffffffffff918291015416604083019081528315610dc75760206107ba67ffffffffffffffff60049551166024356114ce565b94604051948580927f38d52e0f0000000000000000000000000000000000000000000000000000000082525afa928315610cd757600093610d83575b506001600160a01b0385811690841614610d7157511660405192610819846111f6565b6003845260005b60608110610d5a57506108316114ad565b5061083a6114ad565b5060405163095ea7b360e01b602082015273e592427a0aece92de3edee1f18e0157c0586156460248201526000604482015260448152610879816111f6565b60405190610886826111be565b6001600160a01b038716825260006020830152604082015260405163095ea7b360e01b602082015273e592427a0aece92de3edee1f18e0157c058615646024820152826044820152604481526108db816111f6565b604051906108e8826111be565b6001600160a01b0388168252600060208301526040820152855160011015610d44576040860152845115610d445760208501526109236114ad565b50604051908161010081011067ffffffffffffffff610100840111176106f95760209361010083016040526001600160a01b03871683526001600160a01b03858401911681526001600160a01b0360408401610bb8815262ffffff606086019133835283608088019542875260a089019788528160c08a019960008b5260e081019b8c527f414bf389000000000000000000000000000000000000000000000000000000006040519d8e0152511660248c0152511660448a015251166064880152511660848601525160a48501525160c48401525160e4830152516001600160a01b03610104911681830152815261014081019080821067ffffffffffffffff8311176106f95781604052610a37826111be565b73e592427a0aece92de3edee1f18e0157c0586156482526000610160820152610180810152610a6582611295565b52610a6f81611295565b5060405160208101907f010000000000000000000000000000000000000000000000000000000000000082526000602182015260006022820152600060268201526000602a82015260208152610ac4816111da565b5190519060208110610d32575b5090604051906040820160208084015281518091526060830190602060608260051b8601019301916000905b828210610ce3575050505081610b65926000920393610b24601f1995868101845283611212565b60405193849283927fd691c9640000000000000000000000000000000000000000000000000000000084526004840152604060248401526044830190611159565b038183335af1908115610cd757600091610bd2575b50610b859150611295565b516020818051810103126100c35760206001600160a01b03910151915b60405192835216907f08e2ed806097a381d22900fff99d42ccd16283e24fdd2912277d39995588bb2860203392a3005b90503d806000833e610be48183611212565b8101906020818303126100c35780519067ffffffffffffffff82116100c35701601f9282601f830112156100c3578151610c1d816112b9565b94610c2b6040519687611212565b81865260208087019260051b850101938585116100c35760208101925b858410610c605750505050505050610b859083610b7a565b835167ffffffffffffffff81116100c35782019087603f830112156100c35760208201519067ffffffffffffffff82116106f957604051610ca8602089888601160182611212565b82815289604084860101116100c357610ccc60209493859460408685019101611136565b815201930192610c48565b6040513d6000823e3d90fd5b90919293602080610d24600193605f198a8203018652606060408a516001600160a01b03815116845285810151868501520151918160408201520190611159565b960192019201909291610afd565b6000199060200360031b1b1683610ad1565b634e487b7160e01b600052603260045260246000fd5b602090610d656114ad565b82828801015201610820565b505050906001600160a01b0390610ba2565b9092506020813d602011610dbf575b81610d9f60209383611212565b810103126100c357516001600160a01b03811681036100c35791856107f6565b3d9150610d92565b60246040517ff91bd6f1000000000000000000000000000000000000000000000000000000008152336004820152fd5b346100c35760003660031901126100c357610e55604051610e17816111da565b600581527f312e302e300000000000000000000000000000000000000000000000000000006020820152604051918291602083526020830190611159565b0390f35b346100c35760403660031901126100c3576020610e8967ffffffffffffffff610e80611234565b166004356114ce565b604051908152f35b346100c3576020806003193601126100c3576001600160a01b039081610eb561117e565b166000526001808252610ecb6040600020611389565b50926040519280840190808552855180925280604086019601926000905b838210610ef65786880387f35b845181168852968201969382019390850190610ee9565b346100c35760803660031901126100c357610f2661117e565b60603660231901126100c357604051610f3e816111be565b610f46611234565b8152604435916001600160a01b0380841684036100c357602092838101948552606435906fffffffffffffffffffffffffffffffff9081831683036100c357604081019283523360005260018652610fb8604060002060016000526020526001600160a01b0360406000205416151590565b15610dc75781835116156105fa5760019033600052600087526040600020978587169889600052885267ffffffffffffffff60406000209251167fffffffff000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffff00000000000000008454935160401b16921617178155019151166fffffffffffffffffffffffffffffffff198254161790553360005260018352604060002090846001141591826110c1575b5050156110a5575b82337f5d29cb23b5ad294992752fd5187119f150168eb0673b9d5d8599deab0e4d7df4600080a3005b60016110ba92336000525260406000206112d1565b818061107c565b9091508460005283526040600020541615158480611074565b346100c35760003660031901126100c357806110f8610e55926111da565b600d81527f4175746f4443414d6f64756c65000000000000000000000000000000000000006020820152604051918291602083526020830190611159565b60005b8381106111495750506000910152565b8181015183820152602001611139565b9060209161117281518092818552858086019101611136565b601f01601f1916010190565b600435906001600160a01b03821682036100c357565b602435906001600160a01b03821682036100c357565b35906001600160a01b03821682036100c357565b6060810190811067ffffffffffffffff8211176106f957604052565b6040810190811067ffffffffffffffff8211176106f957604052565b6080810190811067ffffffffffffffff8211176106f957604052565b90601f8019910116810190811067ffffffffffffffff8211176106f957604052565b6024359067ffffffffffffffff821682036100c357565b9060206003198301126100c35760043567ffffffffffffffff928382116100c357806023830112156100c35781600401359384116100c357602484830101116100c3576024019190565b805160021015610d445760600190565b8051821015610d445760209160051b010190565b67ffffffffffffffff81116106f95760051b60200190565b906001600160a01b03809116908115801561137f575b6113675760009282845280602052816040852054166113365790604091600185526020528184205416928281528181206001600160a01b03199485825416179055600181522091825416179055565b602483604051907f40d3d1a40000000000000000000000000000000000000000000000000000000082526004820152fd5b60248260405190637c84ecfb60e01b82526004820152fd5b50600182146112e7565b60409160405192610ca0840184811067ffffffffffffffff8211176106f957604093919352606493606481526020610c803660208401378195600093600196879160018752806020526001600160a01b039485604089205416995b611441575b50505050506001818616141580611438575b611403575052565b90935060001982018281116114225761141c90856112a5565b51169252565b634e487b7160e01b600052601160045260246000fd5b508215156113fb565b90919296939885811690811515806114a3575b8061149a575b1561149057508061146b86896112a5565b52600052818152848360002054169860001985146114225793870196929190836113e4565b99508497506113e9565b508a861061145a565b5088821415611454565b604051906114ba826111be565b606060408360008152600060208201520152565b9091906000198382098382029182808310920391808303921461156c57670de0b6b3a7640000908183101561153557947faccb18165bd6fe31ae1cf318dc5b51eee0e1ba569b88cd74c1773b91fac1066994950990828211900360ee1b910360121c170290565b60449086604051917f5173648d00000000000000000000000000000000000000000000000000000000835260048301526024820152fd5b5050670de0b6b3a76400009004915056fea264697066735822122051ca64b96de55b22a7cebc64961b84931a8828b694ee60ee276dcdc6227ff87c64736f6c63430008190033",
  "deployedBytecode": "0x608080604052600436101561001357600080fd5b60003560e01c90816306fdde03146110da5750806337d0f1eb14610f0d578063450efe2114610e91578063541e683314610e5957806354fd4d5014610df757806361d9a3001461070f5780636d61fe70146103e55780638a91b0e3146102c7578063cbf75c9a14610242578063d60b347f146101e8578063e1f2f9fb146100c85763ecd05961146100a357600080fd5b346100c35760203660031901126100c35760206040516002600435148152f35b600080fd5b346100c35760403660031901126100c3576100e161117e565b6100e9611194565b903360005260006020526040600020916001600160a01b03809116928360005260205260006001604082208281550155336000526001602052604060002091831580156101de575b6101c5578116918260005280602052838260406000205416036101ad5783600052602052604060002054169060005260406000206001600160a01b03199182825416179055816000526040600020908154169055337f5d29cb23b5ad294992752fd5187119f150168eb0673b9d5d8599deab0e4d7df4600080a3005b60248460405190637c84ecfb60e01b82526004820152fd5b60249160405191637c84ecfb60e01b8352166004820152fd5b5060018414610131565b346100c35760203660031901126100c3576001600160a01b0361020961117e565b1660005260016020526020610238604060002060016000526020526001600160a01b0360406000205416151590565b6040519015158152f35b346100c35760403660031901126100c357606061025d61117e565b610265611194565b6001600160a01b03809216600052600060205281604060002091166000526020526040600020906fffffffffffffffffffffffffffffffff6001835493015416906040519267ffffffffffffffff8116845260401c1660208301526040820152f35b346100c3576102d53661124b565b505033600052600160208181526102ef6040600020611389565b508051908360005b8381106103ab57508333600052818152604060002091806000528282526001600160a01b03818160406000205416905b61036d575b50506000525260406000206001600160a01b03198154169055337f9d00629762554452d03c3b45626436df6ca1c3795d05d04df882f6db481b1be0600080a2005b8181169081156103a5579060005284845281806040600020541691166000528260406000206001600160a01b03198154169055610327565b5061032c565b336000526000855260406000206001600160a01b036103ca83866112a5565b511660005285526000826040822082815501550184906102f7565b346100c3576103f33661124b565b810160209081838203126100c357823567ffffffffffffffff938482116100c3570181601f820112156100c357803561042b816112b9565b926104396040519485611212565b818452848085019260071b840101928184116100c3578501915b838310610678575050505033600052600192838352604060002091846000528284526001600160a01b0392836040600020541661064e578560005284526040600020856001600160a01b0319825416179055805193606485116106245760005b8581106104e257337f27b541a16df0902e262f34789782092ab25125513b8ed73608e802951771b928600080a2005b846104ed82856112a5565b5151169084836104fd83876112a5565b5101511686604061050e84886112a5565b51015116926fffffffffffffffffffffffffffffffff806060610531868a6112a5565b510151169060405193610543856111be565b84528684019586526040840191808352156105fa578b6105f49481973360005260008a526040600020866000528a528b60406000209251167fffffffff000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffff00000000000000008454935160401b16921617178155019151166fffffffffffffffffffffffffffffffff198254161790553360005283855260406000206112d1565b016104b3565b60046040517f8582dc3d000000000000000000000000000000000000000000000000000000008152fd5b60046040517f748e67b2000000000000000000000000000000000000000000000000000000008152fd5b60046040517f53c85e66000000000000000000000000000000000000000000000000000000008152fd5b60809081848403126100c357604051918201828110898211176106f9576040526106a1846111aa565b82528684013588811681036100c357878301526106c0604085016111aa565b604083015260609081850135926fffffffffffffffffffffffffffffffff841684036100c3576080938993820152815201920191610453565b634e487b7160e01b600052604160045260246000fd5b346100c35760403660031901126100c35761072861117e565b33600052600060205260406000206001600160a01b0382166000526020526040600020604051610757816111be565b60016001600160a01b03835467ffffffffffffffff8116845260401c16928360208401526fffffffffffffffffffffffffffffffff918291015416604083019081528315610dc75760206107ba67ffffffffffffffff60049551166024356114ce565b94604051948580927f38d52e0f0000000000000000000000000000000000000000000000000000000082525afa928315610cd757600093610d83575b506001600160a01b0385811690841614610d7157511660405192610819846111f6565b6003845260005b60608110610d5a57506108316114ad565b5061083a6114ad565b5060405163095ea7b360e01b602082015273e592427a0aece92de3edee1f18e0157c0586156460248201526000604482015260448152610879816111f6565b60405190610886826111be565b6001600160a01b038716825260006020830152604082015260405163095ea7b360e01b602082015273e592427a0aece92de3edee1f18e0157c058615646024820152826044820152604481526108db816111f6565b604051906108e8826111be565b6001600160a01b0388168252600060208301526040820152855160011015610d44576040860152845115610d445760208501526109236114ad565b50604051908161010081011067ffffffffffffffff610100840111176106f95760209361010083016040526001600160a01b03871683526001600160a01b03858401911681526001600160a01b0360408401610bb8815262ffffff606086019133835283608088019542875260a089019788528160c08a019960008b5260e081019b8c527f414bf389000000000000000000000000000000000000000000000000000000006040519d8e0152511660248c0152511660448a015251166064880152511660848601525160a48501525160c48401525160e4830152516001600160a01b03610104911681830152815261014081019080821067ffffffffffffffff8311176106f95781604052610a37826111be565b73e592427a0aece92de3edee1f18e0157c0586156482526000610160820152610180810152610a6582611295565b52610a6f81611295565b5060405160208101907f010000000000000000000000000000000000000000000000000000000000000082526000602182015260006022820152600060268201526000602a82015260208152610ac4816111da565b5190519060208110610d32575b5090604051906040820160208084015281518091526060830190602060608260051b8601019301916000905b828210610ce3575050505081610b65926000920393610b24601f1995868101845283611212565b60405193849283927fd691c9640000000000000000000000000000000000000000000000000000000084526004840152604060248401526044830190611159565b038183335af1908115610cd757600091610bd2575b50610b859150611295565b516020818051810103126100c35760206001600160a01b03910151915b60405192835216907f08e2ed806097a381d22900fff99d42ccd16283e24fdd2912277d39995588bb2860203392a3005b90503d806000833e610be48183611212565b8101906020818303126100c35780519067ffffffffffffffff82116100c35701601f9282601f830112156100c3578151610c1d816112b9565b94610c2b6040519687611212565b81865260208087019260051b850101938585116100c35760208101925b858410610c605750505050505050610b859083610b7a565b835167ffffffffffffffff81116100c35782019087603f830112156100c35760208201519067ffffffffffffffff82116106f957604051610ca8602089888601160182611212565b82815289604084860101116100c357610ccc60209493859460408685019101611136565b815201930192610c48565b6040513d6000823e3d90fd5b90919293602080610d24600193605f198a8203018652606060408a516001600160a01b03815116845285810151868501520151918160408201520190611159565b960192019201909291610afd565b6000199060200360031b1b1683610ad1565b634e487b7160e01b600052603260045260246000fd5b602090610d656114ad565b82828801015201610820565b505050906001600160a01b0390610ba2565b9092506020813d602011610dbf575b81610d9f60209383611212565b810103126100c357516001600160a01b03811681036100c35791856107f6565b3d9150610d92565b60246040517ff91bd6f1000000000000000000000000000000000000000000000000000000008152336004820152fd5b346100c35760003660031901126100c357610e55604051610e17816111da565b600581527f312e302e300000000000000000000000000000000000000000000000000000006020820152604051918291602083526020830190611159565b0390f35b346100c35760403660031901126100c3576020610e8967ffffffffffffffff610e80611234565b166004356114ce565b604051908152f35b346100c3576020806003193601126100c3576001600160a01b039081610eb561117e565b166000526001808252610ecb6040600020611389565b50926040519280840190808552855180925280604086019601926000905b838210610ef65786880387f35b845181168852968201969382019390850190610ee9565b346100c35760803660031901126100c357610f2661117e565b60603660231901126100c357604051610f3e816111be565b610f46611234565b8152604435916001600160a01b0380841684036100c357602092838101948552606435906fffffffffffffffffffffffffffffffff9081831683036100c357604081019283523360005260018652610fb8604060002060016000526020526001600160a01b0360406000205416151590565b15610dc75781835116156105fa5760019033600052600087526040600020978587169889600052885267ffffffffffffffff60406000209251167fffffffff000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffff00000000000000008454935160401b16921617178155019151166fffffffffffffffffffffffffffffffff198254161790553360005260018352604060002090846001141591826110c1575b5050156110a5575b82337f5d29cb23b5ad294992752fd5187119f150168eb0673b9d5d8599deab0e4d7df4600080a3005b60016110ba92336000525260406000206112d1565b818061107c565b9091508460005283526040600020541615158480611074565b346100c35760003660031901126100c357806110f8610e55926111da565b600d81527f4175746f4443414d6f64756c65000000000000000000000000000000000000006020820152604051918291602083526020830190611159565b60005b8381106111495750506000910152565b8181015183820152602001611139565b9060209161117281518092818552858086019101611136565b601f01601f1916010190565b600435906001600160a01b03821682036100c357565b602435906001600160a01b03821682036100c357565b35906001600160a01b03821682036100c357565b6060810190811067ffffffffffffffff8211176106f957604052565b6040810190811067ffffffffffffffff8211176106f957604052565b6080810190811067ffffffffffffffff8211176106f957604052565b90601f8019910116810190811067ffffffffffffffff8211176106f957604052565b6024359067ffffffffffffffff821682036100c357565b9060206003198301126100c35760043567ffffffffffffffff928382116100c357806023830112156100c35781600401359384116100c357602484830101116100c3576024019190565b805160021015610d445760600190565b8051821015610d445760209160051b010190565b67ffffffffffffffff81116106f95760051b60200190565b906001600160a01b03809116908115801561137f575b6113675760009282845280602052816040852054166113365790604091600185526020528184205416928281528181206001600160a01b03199485825416179055600181522091825416179055565b602483604051907f40d3d1a40000000000000000000000000000000000000000000000000000000082526004820152fd5b60248260405190637c84ecfb60e01b82526004820152fd5b50600182146112e7565b60409160405192610ca0840184811067ffffffffffffffff8211176106f957604093919352606493606481526020610c803660208401378195600093600196879160018752806020526001600160a01b039485604089205416995b611441575b50505050506001818616141580611438575b611403575052565b90935060001982018281116114225761141c90856112a5565b51169252565b634e487b7160e01b600052601160045260246000fd5b508215156113fb565b90919296939885811690811515806114a3575b8061149a575b1561149057508061146b86896112a5565b52600052818152848360002054169860001985146114225793870196929190836113e4565b99508497506113e9565b508a861061145a565b5088821415611454565b604051906114ba826111be565b606060408360008152600060208201520152565b9091906000198382098382029182808310920391808303921461156c57670de0b6b3a7640000908183101561153557947faccb18165bd6fe31ae1cf318dc5b51eee0e1ba569b88cd74c1773b91fac1066994950990828211900360ee1b910360121c170290565b60449086604051917f5173648d00000000000000000000000000000000000000000000000000000000835260048301526024820152fd5b5050670de0b6b3a76400009004915056fea264697066735822122051ca64b96de55b22a7cebc64961b84931a8828b694ee60ee276dcdc6227ff87c64736f6c63430008190033",
  "devdoc": {
    "details": "Module that allows users to automatically save a percentage of their received tokens to a vault",
    "kind": "dev",
    "methods": {
      "autoSave(address,uint256)": {
        "params": {
          "amountReceived": "amount received by the user",
          "token": "address of the token received"
        }
      },
      "calcDepositAmount(uint256,uint64)": {
        "params": {
          "amountReceived": "amount received by the user",
          "percentage": "percentage to be saved to the vault"
        },
        "returns": {
          "_0": "amount to be saved to the vault"
        }
      },
      "deleteConfig(address,address)": {
        "details": "the function will revert if the module is not initialized",
        "params": {
          "prevToken": "address of the token stored before the token to be deleted",
          "token": "address of the token to be deleted"
        }
      },
      "getTokens(address)": {
        "details": "the function will revert if the module is not initialized",
        "params": {
          "account": "address of the account"
        }
      },
      "isInitialized(address)": {
        "params": {
          "smartAccount": "address of the smart account"
        },
        "returns": {
          "_0": "true if the module is initialized, false otherwise"
        }
      },
      "isModuleType(uint256)": {
        "params": {
          "typeID": "type of the module"
        },
        "returns": {
          "_0": "true if the type is a module type, false otherwise"
        }
      },
      "name()": {
        "returns": {
          "_0": "name of the module"
        }
      },
      "onInstall(bytes)": {
        "details": "data is encoded as follows: abi.encode([tokens], [configs])if there are more tokens than configs, the function will revertif there are more configs than tokens, the function will ignore the extra configs",
        "params": {
          "data": "encoded data containing the tokens and their configurations"
        }
      },
      "onUninstall(bytes)": {
        "details": "the data parameter is not used"
      },
      "setConfig(address,(uint64,address,uint128))": {
        "details": "the function will revert if the module is not initializedthis function can be used to set a new configuration or update an existing one",
        "params": {
          "_config": "Config struct containing the configuration",
          "token": "address of the token"
        }
      },
      "version()": {
        "returns": {
          "_0": "version of the module"
        }
      }
    },
    "title": "AutoDCAModule",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "PRBMath_MulDiv18_Overflow(uint256,uint256)": [
        {
          "notice": "Thrown when the resultant value in {mulDiv18} overflows uint256."
        }
      ]
    },
    "kind": "user",
    "methods": {
      "autoSave(address,uint256)": {
        "notice": "Executes the auto save logic"
      },
      "calcDepositAmount(uint256,uint64)": {
        "notice": "Calculates the amount to be saved to the vault"
      },
      "deleteConfig(address,address)": {
        "notice": "Deletes the configuration for a token"
      },
      "getTokens(address)": {
        "notice": "Gets a list of all tokens"
      },
      "isInitialized(address)": {
        "notice": "Checks if the module is initialized"
      },
      "isModuleType(uint256)": {
        "notice": "Returns the type of the module"
      },
      "name()": {
        "notice": "Returns the name of the module"
      },
      "onInstall(bytes)": {
        "notice": "Initializes the module with the tokens and their configurations"
      },
      "onUninstall(bytes)": {
        "notice": "Handles the uninstallation of the module and clears the tokens and configurations"
      },
      "setConfig(address,(uint64,address,uint128))": {
        "notice": "Sets the configuration for a token"
      },
      "version()": {
        "notice": "Returns the version of the module"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 11399,
        "contract": "contracts/AutoDCA/AutoDCAModule.sol:AutoDCAModule",
        "label": "config",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_mapping(t_address,t_struct(Config)11382_storage))"
      },
      {
        "astId": 11404,
        "contract": "contracts/AutoDCA/AutoDCAModule.sol:AutoDCAModule",
        "label": "tokens",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_struct(SentinelList)29707_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_address)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_address,t_mapping(t_address,t_struct(Config)11382_storage))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => struct AutoDCAModule.Config))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_struct(Config)11382_storage)"
      },
      "t_mapping(t_address,t_struct(Config)11382_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct AutoDCAModule.Config)",
        "numberOfBytes": "32",
        "value": "t_struct(Config)11382_storage"
      },
      "t_mapping(t_address,t_struct(SentinelList)29707_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct SentinelListLib.SentinelList)",
        "numberOfBytes": "32",
        "value": "t_struct(SentinelList)29707_storage"
      },
      "t_struct(Config)11382_storage": {
        "encoding": "inplace",
        "label": "struct AutoDCAModule.Config",
        "members": [
          {
            "astId": 11377,
            "contract": "contracts/AutoDCA/AutoDCAModule.sol:AutoDCAModule",
            "label": "percentage",
            "offset": 0,
            "slot": "0",
            "type": "t_userDefinedValueType(UD2x18)9063"
          },
          {
            "astId": 11379,
            "contract": "contracts/AutoDCA/AutoDCAModule.sol:AutoDCAModule",
            "label": "vault",
            "offset": 8,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 11381,
            "contract": "contracts/AutoDCA/AutoDCAModule.sol:AutoDCAModule",
            "label": "sqrtPriceLimitX96",
            "offset": 0,
            "slot": "1",
            "type": "t_uint128"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(SentinelList)29707_storage": {
        "encoding": "inplace",
        "label": "struct SentinelListLib.SentinelList",
        "members": [
          {
            "astId": 29706,
            "contract": "contracts/AutoDCA/AutoDCAModule.sol:AutoDCAModule",
            "label": "entries",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_address,t_address)"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_uint128": {
        "encoding": "inplace",
        "label": "uint128",
        "numberOfBytes": "16"
      },
      "t_userDefinedValueType(UD2x18)9063": {
        "encoding": "inplace",
        "label": "UD2x18",
        "numberOfBytes": "8"
      }
    }
  }
}